---
aliases: []
tags: []
date created: 2024-12-20T13:12:42-05:00
date modified: 2025-01-13T16:12:45-05:00
framework: framework_here
---




%% Begin Waypoint %%


%% End Waypoint %%

- Diagnostic Statement:
	- Org has implemented DLP

# DataviewJS

## WORKSPACE

QUERY TEST:

```dataviewjs
////////////////////////////////////////////////////////////////////////////////
// STEP 0: CONFIGURATION
////////////////////////////////////////////////////////////////////////////////

// 0A. Detect the framework key name from YAML or fallback
const framework = dv.current().framework || "framework_here";

/** (COMMENTED OUT) FUTURE SCHEMA SUPPORT 
 * 
 * // You could store some "defined schema" here or load from a file:
 * const frameworkSchema = {
 *   // e.g. "issues" is an object, "reviewed" is boolean, etc.
 *   // This is not yet implemented, just a placeholder for future usage
 * };
 *
 * function validateAgainstSchema(keyPath, proposedValue) {
 *   // e.g. check if schema says that "issues" must be an object
 *   // or "reviewer" must be a string
 *   // ...
 *   return true; // or false if invalid
 * }
 */

// 0B. Regex to identify lines with syntax like framework_here.applies_to:: ...
const lineRegex = new RegExp(
    String.raw`\s*(?:[-*+]\s*)?(?:\[|\()?(?<dotKey>${framework}(?:\.\w+)*)::\s*(?:\[\[(?<wikilink>[^|\]]+)\]\]|\[(?<mdText>[^\]]+?)\]\((?<mdLink>[^)]+?)\)|(?<plainValue>[^"\[\]\(\)\s{}]+))?\s*(?:(?<json>\{[^}]*\})|"(?<quotedValue>[^"]+)")?(?=\]|\)|$)`,
    "gm"
);

// 0C. Helper functions for decoding & checking incoming links
function isEncoded(uri) {
    uri = uri || "";
    return uri !== decodeURIComponent(uri);
}

function fullyDecodeURI(uri) {
    while (isEncoded(uri)) {
        uri = decodeURI(uri);
    }
    return uri;
}

/**
 * Decide if a captured link (wikilink/mdLink/plainLink) points to THIS note.
 */
function isIncomingLink(wikilink, mdLink, plainValue) {
    const thisFileName = dv.current().file.name;
    const thisFilePath = dv.current().file.path;

    // Decode URIs
    wikilink = fullyDecodeURI(wikilink);
    mdLink = fullyDecodeURI(mdLink);
    plainValue = fullyDecodeURI(plainValue);

    if (wikilink) {
        if (wikilink.trim() === thisFileName) return true;
    }
    if (mdLink) {
        if (mdLink.includes(thisFileName) || mdLink.includes(thisFilePath)) return true;
    }
    if (plainValue) {
        if (plainValue.includes(thisFileName) || plainValue.includes(thisFilePath)) return true;
    }
    return false;
}

////////////////////////////////////////////////////////////////////////////////
// STEP 1: GATHER INBOUND LINKS & NON-LINK RELATIONSHIP DEFAULTS
////////////////////////////////////////////////////////////////////////////////

// 1A. Grab all notes that link to the current note
const incomingNotes = dv.current().file.inlinks.values;

// 1B. Store the lines that specifically mention this note + framework
const incomingLinks = [];

// 1C. Store cases of no-link relationship/graph-link defaults
const linkDefaults = [];

// 1D. For each inbound note, read lines and parse
for (const link of incomingNotes) {
    const pageContent = await dv.io.load(link.path);
    if (!pageContent) continue;

    const lines = pageContent.split("\n");
    for (const line of lines) {
        if (!line.includes(framework)) continue; // quick filter on 'framework'

        // matchAll over the line
        const matches = [...line.matchAll(lineRegex)];
        for (const match of matches) {
            const {
                dotKey,
                wikilink,
                mdText,
                mdLink,
                plainValue,
                json,
                quotedValue
            } = match.groups;

            // Store the original text trimmed for debugging
            const rawCapture = match[0].trim();

            // If there's no dotKey, skip
            if (!dotKey) continue;

            const linkTarget = wikilink || mdLink;

            // Attempt JSON parse
            let jsonObject = null;
            if (json) {
                try {
                    jsonObject = JSON.parse(json);
                } catch (err) {
                    console.warn(`Failed to parse JSON: ${json} in file ${link.path}`);
                }
            }

            // CASE 1: If it references *this* note, store it in incomingLinks
            if (isIncomingLink(wikilink, mdLink, plainValue)) {
                incomingLinks.push({
                    sourceFile: link.path,
                    dotKey,
                    linkValue: linkTarget, // e.g. "[[NoteName]]" or "[File.md]"
                    plainValue, // e.g. "True" or "ID 12" if no actual link
                    json: jsonObject || json, // store an object if parse was successful, else the raw string
                    quotedValue,
                    rawCapture // Store the entire matched text (trimmed)
                });
            }
            // CASE 2: If there's no *actual link*, but we have a dotKey + JSON or quotedValue or plainValue
            // This might be your "defaults" or "non-link" relationships for the *sourceFile*
            else if (!linkTarget && (dotKey && (quotedValue || plainValue || json))) {
                linkDefaults.push({
                    sourceFile: link.path,
                    dotKey,
                    linkValue: null, // <--- linkValue isn't present in link defaults
                    plainValue,
                    json: jsonObject || json,
                    quotedValue,
                    rawCapture
                });
            }
        }
    }
}

console.log("Inbound Links => incomingLinks:", incomingLinks);
console.log("Link Default => linkDefaults:", linkDefaults);

// Combine them
const allGraphItems = [...incomingLinks, ...linkDefaults];

////////////////////////////////////////////////////////////////////////////////
// STEP 2: Classify Graph Items & Compute Priority
////////////////////////////////////////////////////////////////////////////////

/**
 * We’ll create a small function that “classifies” the record, 
 * first by whether it has a link, then by JSON/quotedValue/boolean.
 * This modular approach helps you test classification logic alone.
 */


function parseDotKey(dotKey) {
    if (!dotKey) return [];
    return dotKey.split(".");
}

/** 
 * 2A) Priority Config
 * We add parentTypeResolutionMode to handle how to treat
 * collisions where the parent is a primitive but a new item needs sub-keys.
 * 
 *  - "FAVOR_SUBKEYS": Convert the parent to an empty object if new item has >= priority
 *  - "DISALLOW_SUBKEYS_IF_PRIMITIVE": Keep the parent as primitive => skip subkeys
 *  - "UPGRADE_PARENT_IF_HIGHER_PRIORITY": If new item has strictly higher priority, 
 *    upgrade the parent to an object; else keep the old value
 */

const priorityConfig = {
    prioritizeLinks: true,
    prioritizeDeeperPaths: true,
    parentTypeResolutionMode: "FAVOR_SUBKEYS"
    // other possible values:
    // "DISALLOW_SUBKEYS_IF_PRIMITIVE"
    // "UPGRADE_PARENT_IF_HIGHER_PRIORITY"
};

/** 
 * 2B) Priority Computation
 *   - If we want to prioritize deeper dot-keys => + (depth)
 *   - If we want to prioritize links => + 100
 */

function computePriority(item, cfg) {
    const dotParts = parseDotKey(item.dotKey);
    const depth = dotParts.length;
    const hasLink = !!item.linkValue;

    let score = 0;
    if (cfg.prioritizeDeeperPaths) score += depth;
    if (cfg.prioritizeLinks && hasLink) score += 100;

    return score;
}

function classifyRecord(item, cfg) {
    // e.g. store booleans if you want them
    const classification = {
        ...item,
        hasLink: !!item.linkValue,
        isJsonObject: item.json && typeof item.json === "object"
    };
    classification.priorityScore = computePriority(classification, cfg);
    return classification;
}

// 2C) Actually classify all items
const classifiedGraphItems = allGraphItems.map(r => classifyRecord(r, priorityConfig));
console.log("STEP 2) Classified Graph Items:", classifiedGraphItems);

/*
function classifyRecord(record) {
    const dotParts = record.dotKey.split(".");
    const isDot = (dotParts.length > 1);
    const isRootObject = (dotParts.length === 1);
    const hasLink = !!record.linkValue;
    const isJsonObject = record.json && typeof record.json === "object";
    const isJsonStr = record.json && typeof record.json === "string";
    const hasQuoted = record.quotedValue !== undefined && record.quotedValue !== null;
    const isBooleanImplied = isDot && !isJsonObject && !hasQuoted;

    let category = "unknown";

    if (hasLink) {
        if (isJsonObject) {
            category = "inline_dv_tag+link+json";
        } else if (hasQuoted) {
            category = "inline_dv_tag+link+plain_value";
        } else if (isBooleanImplied) {
            category = "inline_dv_tag+link+flag";
        }
    } else {
        // no link
        if (isJsonObject) {
            category = "inline_dv_tag+json";
        } else if (hasQuoted) {
            category = "inline_dv_tag+plain_value";
        } else {
            category = "inline_dv_tag+flag";
        }
    }

    return {
        ...record,
        recordType: category
    };
}
*/

////////////////////////////////////////////////////////////////////////////////
// STEP 3: Merge Graph Items
////////////////////////////////////////////////////////////////////////////////

/*
function ensurePath(obj, priorityObj, path) {
    let curr = obj;
    let currP = priorityObj;
    for (const key of path) {
        if (!(key in curr)) curr[key] = {};
        if (!(key in currP)) currP[key] = {};
        curr = curr[key];
        currP = currP[key];
    }
    return [curr, currP];
}
*/

/**
 * ensurePath(...) 
 * 
 * Creates or upgrades objects along the path so that by the final step,
 * we have an object to store subkeys in. 
 * If at some step we find a primitive with higher or equal priority, we skip
 * further path creation (the caller may also skip).
 */
function ensurePath(obj, prioObj, path, config, newPriority) {
    let curr = obj;
    let currP = prioObj;

    // we iterate up to path.length, because each step 
    // needs to be an object for sub-steps
    for (let i = 0; i < path.length; i++) {
        const key = path[i];
        // 1) If current parent is not an object, handle collision
        if (typeof curr !== "object" || curr === null) {
            // we have a mismatch; try to handle it
            handleParentPrimitiveCollision(
                // parent's parent? Not possible to fix it, 
                // so effectively we skip or override this parent entirely:
                // but let's do the best we can
                // we pass the parent's container & key => 
                // but that might not be straightforward 
                // if we are nested. A simpler approach: "we can't continue"
                // We'll forcibly convert if the newPriority >= oldPrio, or skip

                // For simplicity, let's do an approach that we do not forcibly 
                // create objects at mid-level if the parent is primitive & old
                // is higher/equal priority. => We bail out
                // If newPriority is strictly higher, we override everything
                // in the parent's parent's reference. 
                // This is somewhat advanced. Alternatively, do a
                // top-level approach. Let's do it:

                // We'll just return a "null signal" indicating we can't proceed.
                // Then the caller merges as a top-level property.
            );
            return [null, null];
        }

        // 2) If the key doesn't exist, create sub-object
        if (!(key in curr)) {
            curr[key] = {};
            currP[key] = {};
        } else {
            // If the existing thing is also a primitive, we do a smaller collision fix
            if (typeof curr[key] !== "object" || curr[key] === null) {
                const existingPriority = currP[key] || 0;
                if (existingPriority > newPriority) {
                    // old is higher => we can't override => return
                    return [null, null];
                }

                // If newPriority >= old => upgrade to object if "FAVOR_SUBKEYS"
                // or "UPGRADE_PARENT_IF_HIGHER_PRIORITY"
                // We'll do the same logic as handleParentPrimitiveCollision
                // but inline for clarity:
                const mode = config.parentTypeResolutionMode;
                switch (mode) {
                    case "FAVOR_SUBKEYS":
                        // if newPriority >= existingPriority => upgrade
                        if (newPriority >= existingPriority) {
                            curr[key] = {};
                            currP[key] = newPriority;
                        } else {
                            return [null, null];
                        }
                        break;
                    case "DISALLOW_SUBKEYS_IF_PRIMITIVE":
                        // do nothing => keep the old
                        return [null, null];
                    case "UPGRADE_PARENT_IF_HIGHER_PRIORITY":
                        if (newPriority > existingPriority) {
                            curr[key] = {};
                            currP[key] = newPriority;
                        } else {
                            return [null, null];
                        }
                        break;
                }
            }
        }

        // 3) Move one step deeper
        curr = curr[key];
        if (!currP[key]) currP[key] = {};
        currP = currP[key];
    }

    return [curr, currP];
}

/**
 * Decide how to handle parent is a primitive, but subkey is needed
 * based on config.parentTypeResolutionMode
 */
function handleParentPrimitiveCollision(parentObj, parentPrio, lastKey, newPriority, existingPrio, config) {
    // If parentObj[lastKey] is not an object => conflict
    const mode = config.parentTypeResolutionMode;
    switch (mode) {
        case "FAVOR_SUBKEYS":
            // Always convert to object if new item has >= priority
            if (newPriority >= existingPrio) {
                parentObj[lastKey] = {};
                parentPrio[lastKey] = newPriority;
            } else {
                // do nothing
            }
            break;

        case "DISALLOW_SUBKEYS_IF_PRIMITIVE":
            // We do nothing => subkeys are basically lost if parent is a primitive
            // That means the old primitive “wins”
            break;

        case "UPGRADE_PARENT_IF_HIGHER_PRIORITY":
            // Only if newPriority is strictly greater, convert to an object
            if (newPriority > existingPrio) {
                parentObj[lastKey] = {};
                parentPrio[lastKey] = newPriority;
            }
            break;
    }
}

function mergeOneGraphItem(rootObject, rootPriority, item, config) {
    const path = parseDotKey(item.dotKey);
    const newPriority = item.priorityScore || 0;

    // e.g. skip first segment if you don't want "framework_here" 
    // as an actual object:
    // if (path[0] === "framework_here") path.shift();

    const [parentObj, parentPrio] = ensurePath(
        rootObject,
        rootPriority,
        path.slice(0, -1),
        config,
        newPriority
    );
    // if we got [null, null], skip
    if (!parentObj) {
        return;
    }

    const lastKey = path[path.length - 1];
    const existingPriority = parentPrio[lastKey] || 0;

    // Build newValue
    let newValue = buildNewValue(item);

  	console.log(`${JSON.stringify(rootObject)} ::: ${lastKey} ::: ${JSON.stringify(parentObj)}`)
  
    // 1) If lastKey not in parentObj => set it
    if (!(lastKey in parentObj)) {
        parentObj[lastKey] = newValue;
        parentPrio[lastKey] = newPriority;
        return;
    }

    // 2) Compare priority
    if (existingPriority > newPriority) return; // skip

    // 3) Possibly partial-merge if newValue is object
    if (typeof newValue === "object" && newValue !== null && !Array.isArray(newValue)) {
        // partial subkey merges
        if (typeof parentObj[lastKey] === "object" && parentObj[lastKey] !== null) {
            deepMergeObjects(
                parentObj[lastKey],
                newValue,
                parentPrio[lastKey],
                newPriority,
                config
            );
        } else {
            // old is primitive => handle collision
            const oldPrio = parentPrio[lastKey] || 0;
            if (oldPrio > newPriority) {
                return;
            }
            // else override
            parentObj[lastKey] = newValue;
            parentPrio[lastKey] = newPriority;
        }
    } else {
        // newValue is primitive => override
        parentObj[lastKey] = newValue;
        parentPrio[lastKey] = newPriority;
    }
}

function buildNewValue(item) {
    if (typeof item.json === "object") {
        return item.json;
    } else if (item.quotedValue !== undefined && item.quotedValue !== null) {
        return item.quotedValue;
    } else if (item.plainValue) {
        const pvLower = item.plainValue.toLowerCase();
        if (pvLower === "true") return true;
        if (pvLower === "false") return false;
        if (!isNaN(item.plainValue)) return Number(item.plainValue);
        return item.plainValue;
    }
    return true; // fallback => boolean
}


/**
 * If newVal has { project:2024, project_owner:"Person 3" }, 
 * merges each subkey with the old object if newPriority >= oldPriority.
 */

function deepMergeObjects(oldObj, newObj, oldPrio, newPriority, config) {
    for (const key of Object.keys(newObj)) {
        const val = newObj[key];
        const existingPrio = oldPrio[key] || 0;
        if (existingPrio > newPriority) continue;

        if (val && typeof val === "object" && !Array.isArray(val)) {
            // recursively merge sub-objects
            if (typeof oldObj[key] === "object" && oldObj[key] !== null) {
                deepMergeObjects(oldObj[key], val, oldPrio[key], newPriority, config);
            } else {
                // if oldObj[key] is primitive but newVal is object => apply same logic
                if (typeof oldObj[key] !== "object" || oldObj[key] === null) {
                    handleParentPrimitiveCollision(oldObj, oldPrio, key, newPriority, existingPrio, config);
                    if (typeof oldObj[key] !== "object" || oldObj[key] === null) {
                        // override if newPriority >= existingPrio
                        if (newPriority >= existingPrio) {
                            oldObj[key] = val;
                            oldPrio[key] = newPriority;
                        }
                        continue;
                    }
                }
                // now partial subkey merges
                deepMergeObjects(oldObj[key], val, oldPrio[key], newPriority, config);
            }
        } else {
            // primitive => override
            oldObj[key] = val;
            oldPrio[key] = newPriority;
        }
    }
}

function mergeGraphItems(classifiedItems) {
    // Highest priority last => overwrites
    const sorted = [...classifiedItems].sort((a, b) => (a.priorityScore || 0) - (b.priorityScore || 0));

    console.log(`Sorted Items for Merging =>`, sorted);

    const finalObject = {};
    const finalPriority = {};

    for (const item of sorted) {
        mergeOneGraphItem(finalObject, finalPriority, item, priorityConfig);
    }
    return finalObject;
}

function mergeBySourceFile(items) {
    // group items by item.sourceFile
    const grouped = {};
    for (const it of items) {
        if (!grouped[it.sourceFile]) grouped[it.sourceFile] = [];
        grouped[it.sourceFile].push(it);
    }
    // then merge each group
    const results = {};
    for (const sf in grouped) {
        results[sf] = mergeGraphItems(grouped[sf]);
    }
    return results;
}

////////////////////////////////////////////////////////////////////////////////
// STEP 4: PERFORM MERGE & DISPLAY
////////////////////////////////////////////////////////////////////////////////

// Merge all items from all inbound notes (and defaults).
const mergedResult = mergeGraphItems(classifiedGraphItems);
console.log("Merged Relationship Object:", mergedResult);

// If you want to group by sourceFile, do:
// const groupedResults = mergeBySourceFile(classifiedGraphItems);
// console.log("Grouped by Source File =>", groupedResults);

// Finally, display in a table or as JSON
dv.table(
    ["Property", "Value"],
    Object.entries(mergedResult).map(([k, v]) => [k, JSON.stringify(v)])
);

dv.paragraph("```json\n" + JSON.stringify(mergedResult, null, 2) + "\n```");
```
^^^^^

## Graph-Link Based

### 5) Output Testing

//TODO

### 4) Merging/Priority Logic Testing

- Process
	- Graph-link classification
	- Priority score assignment
	- Grouping
	- Merge into relationship/graph-link objects

```js
////////////////////////////////////////////////////////////////////////////////
// STEP 0: BASIC SETUP
////////////////////////////////////////////////////////////////////////////////

// 0A. Detect the framework key name from YAML or fallback
const framework = dv.current().framework || "framework_here";

// 0B. Regex to identify lines with syntax like framework_here.applies_to:: ...
const lineRegex = new RegExp(
  String.raw`\s*(?:[-*+]\s*)?(?:\[|\()?(?<dotKey>${framework}(?:\.\w+)*)::\s*(?:\[\[(?<wikilink>[^|\]]+)\]\]|\[(?<mdText>[^\]]+?)\]\((?<mdLink>[^)]+?)\)|(?<plainLink>[^"\[\]\(\)\s{}]+))?\s*(?:(?<json>\{[^}]*\})|"(?<quotedValue>[^"]+)")?(?=\]|\)|$)`,
  "gm"
);

// 0C. Helper functions for decoding & checking incoming links

function isEncoded(uri) {
  uri = uri || "";
  return uri !== decodeURIComponent(uri);
}

function fullyDecodeURI(uri) {
  while (isEncoded(uri)) {
    uri = decodeURI(uri);
  }
  return uri;
}

/**
 * Decide if a captured link (wikilink/mdLink/plainLink) points to THIS note.
 */
function isIncomingLink(wikilink, mdLink, plainLink) {
  const thisFileName = dv.current().file.name;
  const thisFilePath = dv.current().file.path;

  // Decode URIs
  wikilink = fullyDecodeURI(wikilink);
  mdLink = fullyDecodeURI(mdLink);
  plainLink = fullyDecodeURI(plainLink);

  if (wikilink) {
    if (wikilink.trim() === thisFileName) return true;
  }
  if (mdLink) {
    if (mdLink.includes(thisFileName) || mdLink.includes(thisFilePath)) return true;
  }
  if (plainLink) {
    if (plainLink.includes(thisFileName) || plainLink.includes(thisFilePath)) return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////
// STEP 1: GATHER INBOUND LINKS
////////////////////////////////////////////////////////////////////////////////

// 1A. Grab all notes that link to the current note
const inlinks = dv.current().file.inlinks.values;

// 1B. We'll store only the lines that specifically mention this note + framework
const incomingConnections = [];

// 1C. For each inbound note, read lines and parse
for (const link of inlinks) {
  const pageContent = await dv.io.load(link.path);
  if (!pageContent) continue;

  const lines = pageContent.split("\n");
  for (const line of lines) {
    if (!line.includes(framework)) continue; // quick filter

    const matches = [...line.matchAll(lineRegex)];
    for (const match of matches) {
      const { dotKey, wikilink, mdText, mdLink, plainLink, json, quotedValue } = match.groups;
      const linkTarget = wikilink || mdText || mdLink || plainLink;

      if (!linkTarget) continue; // e.g. parseLinksOnly scenario
      if (!isIncomingLink(wikilink, mdLink, plainLink)) continue; // skip if not referencing this file

      let jsonObject = null;
      if (json) {
        try {
          jsonObject = JSON.parse(json);
        } catch (err) {
          console.warn(`Failed to parse JSON: ${json} in file ${link.path}`);
        }
      }

      incomingConnections.push({
        sourceFile: link.path,
        dotKey,
        linkValue: linkTarget,
        json: jsonObject || json,   // store an object if parse was successful, else the raw string
        quotedValue
      });
    }
  }
}

console.log("STEP 1) Inbound Links => incomingConnections:", incomingConnections);

////////////////////////////////////////////////////////////////////////////////
// STEP 2: TESTING “GRAPH LINK CLASSIFICATION” (OPTIONAL)
////////////////////////////////////////////////////////////////////////////////

/**
 * We’ll create a small function that “classifies” the record, 
 * first by whether it has a link, then by JSON/quotedValue/boolean.
 * This modular approach helps you test classification logic alone.
 */

function classifyRecordHighLevel(record) {
  // Check if we have a link
  const hasLink = !!record.linkValue;

  // Return a small object with hasLink or noLink, 
  // so the next step can handle the sub-checks.
  return { ...record, hasLink };
}

function classifyRecordLowLevel(record) {
  // Now check JSON vs. quotedValue vs. boolean
  const isJsonObject = record.json && typeof record.json === "object";
  const hasQuotedValue = record.quotedValue !== undefined && record.quotedValue !== null;
  const isBooleanImplied = record.hasLink && !isJsonObject && !hasQuotedValue;

  // Dot-notation level
  const parts = record.dotKey.split(".");
  const isLeafDotNotation = parts.length > 2;
  const isRootDotNotation = parts.length === 2;

  // Priority placeholders
  let recordType = "unknown";
  let priorityScore = 0;

  // If we have a link, check if JSON, quoted, or boolean
  if (record.hasLink) {
    if (isJsonObject) {
      recordType = isLeafDotNotation ? "inline+link+json (leaf)" : "inline+link+json (root)";
      priorityScore = isLeafDotNotation ? 90 : 80;
    } else if (hasQuotedValue) {
      recordType = isLeafDotNotation ? "inline+link+quoted (leaf)" : "inline+link+quoted (root)";
      priorityScore = isLeafDotNotation ? 60 : 50;
    } else if (isBooleanImplied) {
      recordType = isLeafDotNotation ? "inline+link+boolean (leaf)" : "inline+link+boolean (root)";
      priorityScore = isLeafDotNotation ? 30 : 20;
    }
  } else {
    // no link
    if (isJsonObject) {
      recordType = isLeafDotNotation ? "inline+json (leaf)" : "inline+json (root)";
      priorityScore = isLeafDotNotation ? 9 : 8;
    } else if (hasQuotedValue) {
      recordType = isLeafDotNotation ? "inline+quoted (leaf)" : "inline+quoted (root)";
      priorityScore = isLeafDotNotation ? 6 : 5;
    } else {
      recordType = "inline+boolean/no link";
      priorityScore = 1;
    }
  }

  return { ...record, recordType, priorityScore };
}

/**
 * “Full” classification function that calls the high-level
 * then the low-level checks in separate steps.
 */

function classifyRecord(record) {
  const step1 = classifyRecordHighLevel(record); 
  const final = classifyRecordLowLevel(step1);
  return final;
}

// 2A. Let’s classify all incoming connections
const classifiedConnections = incomingConnections.map(r => classifyRecord(r));

console.log("STEP 2) Classified Connections:", classifiedConnections);

// 2B. If you want to *only* test classification, you could build some 
// “testRecords” here and run them through `classifyRecord`.

// Example (optional):
/*
const testRecords = [
  { sourceFile: "A.md", dotKey: "framework_here.applies_to", linkValue: "[[SomeNote]]", json: { control: true } },
  { sourceFile: "B.md", dotKey: "framework_here.reviewer", linkValue: "", quotedValue: "Alice" },
  // etc.
];
const testClassified = testRecords.map(r => classifyRecord(r));
console.log("Test Classification of sample records =>", testClassified);
*/

////////////////////////////////////////////////////////////////////////////////
// STEP 3: MERGING LOGIC TESTING
////////////////////////////////////////////////////////////////////////////////

/**
 * We'll group by (sourceFile, dotKey, linkValue) 
 * and pick how to “merge” collisions (same key).
 * 
 * For demonstration, the simplest approach is “higher priority overrides.” 
 * But you can change how the final object is built based on partial merges, etc.
 */



// If you want to test merging alone, you could similarly create “testClassified” data
// and run the same grouping logic. That’s easy to do by just building an array of 
// artificially “colliding” items.

////////////////////////////////////////////////////////////////////////////////
// STEP 4: BUILD RELATIONSHIP OBJECTS
////////////////////////////////////////////////////////////////////////////////

/**
 * Now we turn each merged record into a “relationship object.”
 * You can define more advanced logic to reflect partial merges
 * or hierarchical data if needed.
 */

function buildRelationshipObject(mergedRec) {
  let metaData = {};

  // If there's JSON, store it inside metaData
  if (typeof mergedRec.json === "object") {
    metaData = mergedRec.json;
  }
  // If there's a quotedValue
  else if (mergedRec.quotedValue) {
    metaData.value = mergedRec.quotedValue;
  }
  // Otherwise, possibly implied boolean
  else {
    metaData.value = true;
  }

  return {
    source: mergedRec.sourceFile,
    target: dv.current().file.path,  // or .file.name
    dotKey: mergedRec.dotKey,
    linkValue: mergedRec.linkValue === "_NO_LINK_" ? null : mergedRec.linkValue,
    priorityScore: mergedRec.priorityScore,
    recordType: mergedRec.recordType,
    metaData
  };
}


// 4A. Convert the merged items to “relationship objects.”
const relationshipObjects = mergedList.map(buildRelationshipObject);
console.log("STEP 4) Relationship Objects:", relationshipObjects);

////////////////////////////////////////////////////////////////////////////////
// STEP 5: OUTPUT / DISPLAY
////////////////////////////////////////////////////////////////////////////////

// 5A. Show a table of the final relationship objects
dv.table(
  ["Source", "Target", "DotKey", "LinkValue", "Priority", "RecordType", "MetaData"],
  relationshipObjects.map(obj => [
    obj.source,
    obj.target,
    obj.dotKey,
    obj.linkValue,
    obj.priorityScore,
    obj.recordType,
    JSON.stringify(obj.metaData)
  ])
);

// 5B. (Optional) Show them as JSON in a code block
dv.paragraph("```json\n" + JSON.stringify(relationshipObjects, null, 2) + "\n```");+
```

#### OLD

```
// 1) Basic setup from above remains the same
const framework = dv.current().framework || "framework_here";
const lineRegex = new RegExp( String.raw`\s*(?:[-*+]\s*)?(?:\[|\()?(?<dotKey>framework_here(?:\.\w+)*)::\s*(?:\[\[(?<wikilink>[^|\]]+)\]\]|\[(?<mdText>[^\]]+?)\]\((?<mdLink>[^)]+?)\)|(?<plainLink>[^"\[\]\(\)\s{}]+))?\s*(?:(?<json>\{[^}]*\})|"(?<quotedValue>[^"]+)")?(?=\]|\)|$)`, "gm" );

// Return if URI is encoded
function isEncoded(uri) {
  uri = uri || '';
  return uri !== decodeURIComponent(uri);
}

// Decode URI encoded links
function fullyDecodeURI(uri){
  while (isEncoded(uri)){
    uri = decodeURI(uri);
  }
  return uri;
}

// 2) Utility function to decide if a captured link points to THIS note
function isIncomingLink(wikilink, mdLink, plainLink) {
  // We'll do some naive checks. Adjust them for your vault.
  const thisFileName = dv.current().file.name;         // e.g. "My Note"
  const thisFilePath = dv.current().file.path;         // e.g. "Folder/My Note"
  // Possibly remove ".md" from path, handle spaces, etc.

  // Decode any links that might be URI encoded
  wikilink = fullyDecodeURI(wikilink)
  mdLink = fullyDecodeURI(mdLink)
  plainLink = fullyDecodeURI(plainLink)

  // If there's a wikilink, check if it matches this note name exactly
  if (wikilink) {
	console.log(`WIKILINK -- ${wikilink.trim()} :::: ${thisFileName} :::: ${wikilink.trim() === thisFileName}`)
	if (wikilink.trim() === thisFileName) {
	    return true;
    }
  }
  // If there's a markdown link, compare it to the path or filename
  if (mdLink) {
	console.log(`MD LINK -- ${mdLink} :::: ${thisFileName} :::: ${mdLink.includes(thisFileName) || mdLink.includes(thisFilePath)}`)
	if (mdLink.includes(thisFileName) || mdLink.includes(thisFilePath)) {
	    return true;
    }
  }
  // If there's a plainLink, you might interpret it the same way
  if (plainLink) {
		console.log(`PLAINLINK -- ${plainLink} :::: ${thisFileName} :::: ${plainLink.includes(thisFileName) || plainLink.includes(thisFilePath)}`)
	if (plainLink.includes(thisFileName) || plainLink.includes(thisFilePath)) {
	    return true;
    }
  }

  return false;
}

// 3) Gather inbound notes from Dataview
const inlinks = dv.current().file.inlinks.values;

// 4) Clear & build an array to store only truly “incoming” references
const incomingConnections = [];

// 5) For each inbound note, read lines, apply regex
for (const link of inlinks) {
  const pageContent = await dv.io.load(link.path);
  if (!pageContent) continue;

  const lines = pageContent.split("\n");
  for (const line of lines) {
    if (!line.includes(framework)) continue;

    const matches = [...line.matchAll(lineRegex)];
    for (const match of matches) {
      const { dotKey, wikilink, mdText, mdLink, plainLink, json, quotedValue } = match.groups;

      // Decide if there is a link portion
      const linkTarget = wikilink || mdText || mdLink || plainLink;
      if (!linkTarget) {
        // If parseLinksOnly is set to true, skip lines w/o link
        // OR handle them as “default” references. Your choice.
        continue;
      }

      // 6) Check if linkTarget references the current note
      if (!isIncomingLink(wikilink, mdLink, plainLink)) {
        // Not an incoming link to this note. Skip it.
        continue;
      }

      // (Optional) Parse JSON if present
      let jsonObject = null;
      if (json) {
        try {
          jsonObject = JSON.parse(json);
        } catch (err) {
          console.warn(`Failed to parse JSON: ${json}`);
        }
      }

      // 7) Build & store the result
      incomingConnections.push({
        sourceFile: link.path,
        dotKey,
        linkValue: linkTarget,
        json: jsonObject || json,
        quotedValue
      });
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
// PART 4: MERGING / PRIORITY LOGIC (MODULAR EXAMPLE)
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// 2) CLASSIFY & PRIORITIZE
////////////////////////////////////////////////////////////////////////////////

function classifyRecord(record) {
  // Basic checks
  const hasLink = !!record.linkValue;
  const isJsonObject = record.json && typeof record.json === "object";
  const hasQuotedValue = record.quotedValue !== undefined && record.quotedValue !== null;
  const isBooleanImplied = hasLink && !isJsonObject && !hasQuotedValue;

  const dotParts = record.dotKey.split(".");
  const isLeafDotNotation = dotParts.length > 2;
  const isRootDotNotation = dotParts.length === 2;

  let recordType = "unknown";
  let priorityScore = 0;

  // Just one example of how you might prioritize:
  if (hasLink) {
    if (isJsonObject) {
      priorityScore = isLeafDotNotation ? 90 : 80;
      recordType = isLeafDotNotation 
        ? "inline+link+json (leaf)" 
        : "inline+link+json (root)";
    }
    else if (hasQuotedValue) {
      priorityScore = isLeafDotNotation ? 60 : 50;
      recordType = isLeafDotNotation 
        ? "inline+link+quoted (leaf)" 
        : "inline+link+quoted (root)";
    }
    else if (isBooleanImplied) {
      priorityScore = isLeafDotNotation ? 30 : 20;
      recordType = isLeafDotNotation 
        ? "inline+link+boolean (leaf)"
        : "inline+link+boolean (root)";
    }
  } else {
    // no link
    if (isJsonObject) {
      priorityScore = isLeafDotNotation ? 9 : 8;
      recordType = isLeafDotNotation 
        ? "inline+json (leaf)"
        : "inline+json (root)";
    }
    else if (hasQuotedValue) {
      priorityScore = isLeafDotNotation ? 6 : 5;
      recordType = isLeafDotNotation
        ? "inline+quoted (leaf)"
        : "inline+quoted (root)";
    }
    else {
      // fallback
      priorityScore = 1;
      recordType = "inline+boolean/no link";
    }
  }

  return {
    ...record,
    recordType,
    priorityScore
  };
}

// Convert each raw record into a "classified" record
let classifiedConnections = incomingConnections.map(r => classifyRecord(r));

// Show them in console for debugging
console.log("Classified Connections:", classifiedConnections);

////////////////////////////////////////////////////////////////////////////////
// 3) GROUP & MERGE
////////////////////////////////////////////////////////////////////////////////

// We'll group by (sourceFile, dotKey, linkValue) 
// and define a simple "highest priority wins" approach.

function mergeTwoRecords(a, b) {
  // If b has a higher priority, b overrides a
  if (b.priorityScore > a.priorityScore) return b;
  return a;
}

// Build a dictionary: { [key] -> mergedRecord }, where key is (source, dotKey, linkValue)
const grouped = {};
for (const c of classifiedConnections) {
  const sf = c.sourceFile;
  const dk = c.dotKey;
  const lv = c.linkValue || "_NO_LINK_";

  // Our unique grouping key
  const key = `${sf}|${dk}|${lv}`;

  if (!grouped[key]) {
    grouped[key] = c;
  } else {
    grouped[key] = mergeTwoRecords(grouped[key], c);
  }
}

// Now we have a dictionary with final merged records
const mergedList = Object.values(grouped);
console.log("Merged List (highest priority):", mergedList);

////////////////////////////////////////////////////////////////////////////////
// 4) BUILD RELATIONSHIP OBJECTS
////////////////////////////////////////////////////////////////////////////////

// In a graph sense, each "edge" might be: 
// { source, target, dotKey, priorityScore, metaData: {...} }

// 'target' is presumably dv.current().file.path or name
// We'll do a small function that turns a merged record 
// into a "relationship object" with a 'metaData' field.
function buildRelationshipObject(mergedRec) {
  let metaData = {};

  // If there's JSON, store it in metaData
  if (typeof mergedRec.json === "object") {
    metaData = mergedRec.json;
  }
  // If there's a quotedValue, maybe store it as metaData.value
  else if (mergedRec.quotedValue) {
    metaData.value = mergedRec.quotedValue;
  }
  // If none, but there's an implied boolean => metaData.value = true
  else if (mergedRec.priorityScore >= 20 || mergedRec.priorityScore >= 1) {
    // you can refine logic
    metaData.value = true;
  }

  // Return the object
  return {
    source: mergedRec.sourceFile,
    target: dv.current().file.path,
    dotKey: mergedRec.dotKey,
    linkValue: mergedRec.linkValue === "_NO_LINK_" ? null : mergedRec.linkValue,
    priorityScore: mergedRec.priorityScore,
    recordType: mergedRec.recordType,
    metaData
  };
}

// Transform each merged record into a relationship object
const relationshipObjects = mergedList.map(mr => buildRelationshipObject(mr));

// Now we have an array of "edge" objects describing the relationships 
console.log("Final Relationship Objects:", relationshipObjects);

////////////////////////////////////////////////////////////////////////////////
// 5) OUTPUT
////////////////////////////////////////////////////////////////////////////////

// For demonstration, let's show a table of these relationship objects:
dv.table(
  ["Source", "Target", "DotKey", "Link", "Priority", "Metadata"],
  relationshipObjects.map(obj => [
    obj.source,
    obj.target,
    obj.dotKey,
    obj.linkValue,
    obj.priorityScore,
    JSON.stringify(obj.metaData)
  ])
);

// If you want to render the entire object as JSON in a code block:
dv.paragraph("```json\n" + JSON.stringify(relationshipObjects, null, 2) + "\n```");
```




```
////////////////////////////////////////////////////////////////////////////////
// PART 3: PARSE ONLY "INCOMING LINKS" THAT REFERENCE THE CURRENT NOTE
////////////////////////////////////////////////////////////////////////////////

// 1) Basic setup from above remains the same
const framework = dv.current().framework || "framework_here";
const lineRegex = new RegExp( String.raw`\s*(?:[-*+]\s*)?(?:\[|\()?(?<dotKey>framework_here(?:\.\w+)*)::\s*(?:\[\[(?<wikilink>[^|\]]+)\]\]|\[(?<mdText>[^\]]+?)\]\((?<mdLink>[^)]+?)\)|(?<plainLink>[^"\[\]\(\)\s{}]+))?\s*(?:(?<json>\{[^}]*\})|"(?<quotedValue>[^"]+)")?(?=\]|\)|$)`, "gm" );

// Return if URI is encoded
function isEncoded(uri) {
  uri = uri || '';
  return uri !== decodeURIComponent(uri);
}

// Decode URI encoded links
function fullyDecodeURI(uri){
  while (isEncoded(uri)){
    uri = decodeURI(uri);
  }
  return uri;
}

// 2) Utility function to decide if a captured link points to THIS note
function isIncomingLink(wikilink, mdLink, plainLink) {
  // We'll do some naive checks. Adjust them for your vault.
  const thisFileName = dv.current().file.name;         // e.g. "My Note"
  const thisFilePath = dv.current().file.path;         // e.g. "Folder/My Note"
  // Possibly remove ".md" from path, handle spaces, etc.

  // Decode any links that might be URI encoded
  wikilink = fullyDecodeURI(wikilink)
  mdLink = fullyDecodeURI(mdLink)
  plainLink = fullyDecodeURI(plainLink)

  // If there's a wikilink, check if it matches this note name exactly
  if (wikilink) {
	console.log(`WIKILINK -- ${wikilink.trim()} :::: ${thisFileName} :::: ${wikilink.trim() === thisFileName}`)
	if (wikilink.trim() === thisFileName) {
	    return true;
    }
  }
  // If there's a markdown link, compare it to the path or filename
  if (mdLink) {
	console.log(`MD LINK -- ${mdLink} :::: ${thisFileName} :::: ${mdLink.includes(thisFileName) || mdLink.includes(thisFilePath)}`)
	if (mdLink.includes(thisFileName) || mdLink.includes(thisFilePath)) {
	    return true;
    }
  }
  // If there's a plainLink, you might interpret it the same way
  if (plainLink) {
		console.log(`PLAINLINK -- ${plainLink} :::: ${thisFileName} :::: ${plainLink.includes(thisFileName) || plainLink.includes(thisFilePath)}`)
	if (plainLink.includes(thisFileName) || plainLink.includes(thisFilePath)) {
	    return true;
    }
  }

  return false;
}

// 3) Gather inbound notes from Dataview
const inlinks = dv.current().file.inlinks.values;

// 4) Clear & build an array to store only truly “incoming” references
const incomingConnections = [];

// 5) For each inbound note, read lines, apply regex
for (const link of inlinks) {
  const pageContent = await dv.io.load(link.path);
  if (!pageContent) continue;

  const lines = pageContent.split("\n");
  for (const line of lines) {
    if (!line.includes(framework)) continue;

    const matches = [...line.matchAll(lineRegex)];
    for (const match of matches) {
      const { dotKey, wikilink, mdText, mdLink, plainLink, json, quotedValue } = match.groups;

      // Decide if there is a link portion
      const linkTarget = wikilink || mdText || mdLink || plainLink;
      if (!linkTarget) {
        // If parseLinksOnly is set to true, skip lines w/o link
        // OR handle them as “default” references. Your choice.
        continue;
      }

      // 6) Check if linkTarget references the current note
      if (!isIncomingLink(wikilink, mdLink, plainLink)) {
        // Not an incoming link to this note. Skip it.
        continue;
      }

      // (Optional) Parse JSON if present
      let jsonObject = null;
      if (json) {
        try {
          jsonObject = JSON.parse(json);
        } catch (err) {
          console.warn(`Failed to parse JSON: ${json}`);
        }
      }

      // 7) Build & store the result
      incomingConnections.push({
        sourceFile: link.path,
        dotKey,
        linkValue: linkTarget,
        json: jsonObject || json,
        quotedValue
      });
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
// PART 4: MERGING / PRIORITY LOGIC (MODULAR EXAMPLE)
////////////////////////////////////////////////////////////////////////////////

/** 
 * 0) We'll assume we have "incomingConnections" from your previous snippet:
 *    Each item has: 
 *      - sourceFile
 *      - dotKey
 *      - linkValue
 *      - json
 *      - quotedValue
 */

/**
 * 1) We define a helper function "classifyRecord" 
 *    which returns an object describing the "type" of record 
 *    and a numeric "priorityScore" for merging.
 */
function classifyRecord(record) {
  // We'll identify the presence of link vs. no link, JSON vs. quotedValue, etc.

  const hasLink = record.linkValue ? true : false;
  const isJsonObject = record.json && typeof record.json === "object";
  const hasQuotedValue = record.quotedValue !== undefined; // or record.quotedValue != null
  const isBooleanImplied = !isJsonObject && !hasQuotedValue && hasLink; 
    // e.g. if there's a link but no JSON or quotedValue => treat as boolean

  // We'll also see if dotKey includes subkeys: "framework_here.something.somethingElse" 
  // or just "framework_here.something".
  // You might do more advanced checks for "leaf" or "child" keys.
  const parts = record.dotKey.split(".");
  const isLeafDotNotation = parts.length > 2; // e.g. framework_here.something.child means 3 parts
  const isRootDotNotation = parts.length === 2; // e.g. framework_here.applies_to means 2 parts

  let recordType = "unknown";
  let priorityScore = 0;

  // We'll define some rough categories + priorities:
  if (hasLink) {
    if (isJsonObject) {
      if (isLeafDotNotation) {
        recordType = "inline+link+json (leaf)";
        priorityScore = 90;
      } else if (isRootDotNotation) {
        recordType = "inline+link+json (root)";
        priorityScore = 80;
      } else {
        recordType = "inline+link+json (unknown dot level)";
        priorityScore = 70;
      }
    } else if (hasQuotedValue) {
      if (isLeafDotNotation) {
        recordType = "inline+link+quoted (leaf)";
        priorityScore = 60;
      } else if (isRootDotNotation) {
        recordType = "inline+link+quoted (root)";
        priorityScore = 50;
      } else {
        recordType = "inline+link+quoted (unknown dot level)";
        priorityScore = 40;
      }
    } else if (isBooleanImplied) {
      if (isLeafDotNotation) {
        recordType = "inline+link+boolean (leaf)";
        priorityScore = 30;
      } else if (isRootDotNotation) {
        recordType = "inline+link+boolean (root)";
        priorityScore = 20;
      } else {
        recordType = "inline+link+boolean (unknown dot level)";
        priorityScore = 10;
      }
    }
  } else {
    // No link
    if (isJsonObject) {
      if (isLeafDotNotation) {
        recordType = "inline+json (leaf)";
        priorityScore = 9;
      } else if (isRootDotNotation) {
        recordType = "inline+json (root)";
        priorityScore = 8;
      } else {
        recordType = "inline+json (unknown dot level)";
        priorityScore = 7;
      }
    } else if (hasQuotedValue) {
      if (isLeafDotNotation) {
        recordType = "inline+quoted (leaf)";
        priorityScore = 6;
      } else if (isRootDotNotation) {
        recordType = "inline+quoted (root)";
        priorityScore = 5;
      } else {
        recordType = "inline+quoted (unknown dot level)";
        priorityScore = 4;
      }
    } else {
      // fallback: implied boolean?
      recordType = "inline+boolean/no link";
      priorityScore = 1;
    }
  }

  return {
    recordType,
    priorityScore
  };
}

/**
 * 2) We'll create a "normalized" record that includes these classification details.
 */
function normalizeRecord(record) {
  const { recordType, priorityScore } = classifyRecord(record);

  return {
    // keep original fields
    sourceFile: record.sourceFile,
    dotKey: record.dotKey,
    linkValue: record.linkValue,
    json: record.json,
    quotedValue: record.quotedValue,
    // new fields
    recordType,
    priorityScore
  };
}

/**
 * 3) We'll define our "merge" function for 2 records with the same (dotKey, linkValue) 
 *    or (dotKey) depending on your grouping choice.
 *    By default, let's say "higher priorityScore" overrides.
 *    (You can do partial merges if you want.)
 */
function mergeTwoRecords(existing, incoming) {
  // If incoming has a higher priorityScore, return it. 
  // Otherwise keep existing.
  if (incoming.priorityScore > existing.priorityScore) {
    return incoming;
  } else {
    return existing;
  }
}

/**
 * 4) We'll define a hierarchical data structure:
 *    mergedData = {
 *       [sourceFile]: {
 *         [dotKey]: {
 *            [linkValue or '_NO_LINK_']: normalizedRecord
 *         }
 *       }
 *    }
 */
const mergedData = {};

// Suppose "incomingConnections" is the array from your code snippet:
for (let r of incomingConnections) {
  // Convert to a normalized record
  const rec = normalizeRecord(r);

  // For grouping, let's define a function that returns the grouping keys
  const sf = rec.sourceFile;
  const dk = rec.dotKey;
  const lv = rec.linkValue || "_NO_LINK_";

  // Ensure sub-objects exist:
  if (!mergedData[sf]) mergedData[sf] = {};
  if (!mergedData[sf][dk]) mergedData[sf][dk] = {};
  if (!mergedData[sf][dk][lv]) {
    // no existing record, store it
    mergedData[sf][dk][lv] = rec;
  } else {
    // already have a record for (sf, dk, lv), so merge
    const existing = mergedData[sf][dk][lv];
    mergedData[sf][dk][lv] = mergeTwoRecords(existing, rec);
  }
}

// 5) At this point, "mergedData" is a nested object where collisions are resolved 
//    by your priority logic. 
//    Let's see it in console:
console.log("Merged Data with Priority:", mergedData);


/**
 * 6) OPTIONAL: Render as JSON or a Flattened Table
 */

// 6a) Show JSON
//dv.paragraph("## Merged Relationship Object (JSON)");
//dv.code(JSON.stringify(mergedData, null, 2), "json");

// 6b) Flatten into a table
let tableRows = [];
for (const sf in mergedData) {
  for (const dk in mergedData[sf]) {
    for (const lv in mergedData[sf][dk]) {
      const rec = mergedData[sf][dk][lv];
      tableRows.push({
        sourceFile: sf,
        dotKey: dk,
        linkValue: lv === "_NO_LINK_" ? "" : lv,
        recordType: rec.recordType,
        priority: rec.priorityScore,
        quotedValue: rec.quotedValue,
        json: typeof rec.json === "object" ? JSON.stringify(rec.json) : rec.json
      });
    }
  }
}

dv.table(
  ["Source File", "dotKey", "Link Value", "Record Type", "Priority", "quotedValue", "JSON"],
  tableRows.map(row => [
    row.sourceFile,
    row.dotKey,
    row.linkValue,
    row.recordType,
    row.priority,
    row.quotedValue,
    row.json
  ])
);
```

### 3) Parse Only Incoming Links

```js
////////////////////////////////////////////////////////////////////////////////
// PART 3: PARSE ONLY "INCOMING LINKS" THAT REFERENCE THE CURRENT NOTE
////////////////////////////////////////////////////////////////////////////////

// 1) Basic setup from above remains the same
const framework = dv.current().framework || "framework_here";
const lineRegex = new RegExp( String.raw`\s*(?:[-*+]\s*)?(?:\[|\()?(?<dotKey>framework_here(?:\.\w+)*)::\s*(?:\[\[(?<wikilink>[^|\]]+)\]\]|\[(?<mdText>[^\]]+?)\]\((?<mdLink>[^)]+?)\)|(?<plainLink>[^"\[\]\(\)\s{}]+))?\s*(?:(?<json>\{[^}]*\})|"(?<quotedValue>[^"]+)")?(?=\]|\)|$)`, "gm" );

// Return if URI is encoded
function isEncoded(uri) {
  uri = uri || '';
  return uri !== decodeURIComponent(uri);
}

// Decode URI encoded links
function fullyDecodeURI(uri){
  while (isEncoded(uri)){
    uri = decodeURI(uri);
  }
  return uri;
}

// 2) Utility function to decide if a captured link points to THIS note
function isIncomingLink(wikilink, mdLink, plainLink) {
  // We'll do some naive checks. Adjust them for your vault.
  const thisFileName = dv.current().file.name;         // e.g. "My Note"
  const thisFilePath = dv.current().file.path;         // e.g. "Folder/My Note"
  // Possibly remove ".md" from path, handle spaces, etc.

  // Decode any links that might be URI encoded
  wikilink = fullyDecodeURI(wikilink)
  mdLink = fullyDecodeURI(mdLink)
  plainLink = fullyDecodeURI(plainLink)

  // If there's a wikilink, check if it matches this note name exactly
  if (wikilink) {
	console.log(`WIKILINK -- ${wikilink.trim()} :::: ${thisFileName} :::: ${wikilink.trim() === thisFileName}`)
	if (wikilink.trim() === thisFileName) {
	    return true;
    }
  }
  // If there's a markdown link, compare it to the path or filename
  if (mdLink) {
	console.log(`MD LINK -- ${mdLink} :::: ${thisFileName} :::: ${mdLink.includes(thisFileName) || mdLink.includes(thisFilePath)}`)
	if (mdLink.includes(thisFileName) || mdLink.includes(thisFilePath)) {
	    return true;
    }
  }
  // If there's a plainLink, you might interpret it the same way
  if (plainLink) {
		console.log(`PLAINLINK -- ${plainLink} :::: ${thisFileName} :::: ${plainLink.includes(thisFileName) || plainLink.includes(thisFilePath)}`)
	if (plainLink.includes(thisFileName) || plainLink.includes(thisFilePath)) {
	    return true;
    }
  }

  return false;
}

// 3) Gather inbound notes from Dataview
const inlinks = dv.current().file.inlinks.values;

// 4) Clear & build an array to store only truly “incoming” references
const incomingConnections = [];

// 5) For each inbound note, read lines, apply regex
for (const link of inlinks) {
  const pageContent = await dv.io.load(link.path);
  if (!pageContent) continue;

  const lines = pageContent.split("\n");
  for (const line of lines) {
    if (!line.includes(framework)) continue;

    const matches = [...line.matchAll(lineRegex)];
    for (const match of matches) {
      const { dotKey, wikilink, mdText, mdLink, plainLink, json, quotedValue } = match.groups;

      // Decide if there is a link portion
      const linkTarget = wikilink || mdText || mdLink || plainLink;
      if (!linkTarget) {
        // If parseLinksOnly is set to true, skip lines w/o link
        // OR handle them as “default” references. Your choice.
        continue;
      }

      // 6) Check if linkTarget references the current note
      if (!isIncomingLink(wikilink, mdLink, plainLink)) {
        // Not an incoming link to this note. Skip it.
        continue;
      }

      // (Optional) Parse JSON if present
      let jsonObject = null;
      if (json) {
        try {
          jsonObject = JSON.parse(json);
        } catch (err) {
          console.warn(`Failed to parse JSON: ${json}`);
        }
      }

      // 7) Build & store the result
      incomingConnections.push({
        sourceFile: link.path,
        dotKey,
        linkValue: linkTarget,
        json: jsonObject || json,
        quotedValue
      });
    }
  }
}

// 8) Show result
console.log("Incoming Connections (explicitly referencing this file):", incomingConnections);
dv.table(
  ["Source File", "dotKey", "Link Value", "JSON", "Quoted Value"],
  incomingConnections.map(c => [
    c.sourceFile,
    c.dotKey,
    c.linkValue,
    JSON.stringify(c.json),
    c.quotedValue
  ])
);
```

### 2) Parsing All Links from Incoming Pages

```js
////////////////////////////////////////////////////////////////////////////////
// PART 2: PARSE ALL INLINKS TO THE CURRENT NOTE
////////////////////////////////////////////////////////////////////////////////

// 1) CONFIGURATION / SETUP
const framework = dv.current().framework || "framework_here";

// The same or a similar regex (paste or reference from Part 1)
const lineRegex2 = new RegExp( String.raw`\s*(?:[-*+]\s*)?(?:\[|\()?(?<dotKey>framework_here(?:\.\w+)*)::\s*(?:\[\[(?<wikilink>[^|\]]+)\]\]|\[(?<mdText>[^\]]+?)\]\((?<mdLink>[^)]+?)\)|(?<plainLink>[^"\[\]\(\)\s{}]+))?\s*(?:(?<json>\{[^}]*\})|"(?<quotedValue>[^"]+)")?(?=\]|\)|$)`, "gm" );

// OPTIONAL Flags
const parseStringifiedJSON = true; // If true, attempt to parse {...}
const parseLinksOnly = false;     // If true, skip lines w/o any link portion

// 2) GET INLINKS FOR THE CURRENT NOTE
//    'file.inlinks.values' is a Dataview array of file links referencing this note
const inlinks = dv.current().file.inlinks.values;

// We'll store the parsed results here
const parsedConnections = [];

// 3) FOR EACH INBOUND NOTE, LOAD ITS TEXT & SCAN LINE-BY-LINE
for (const inlink of inlinks) {
  // Dataview I/O call to load file content as a string
  const pageContent = await dv.io.load(inlink.path);
  if (!pageContent) {
    console.log(`No content found for file: ${inlink.path}`);
    continue;
  }

  // Split by line
  const lines = pageContent.split("\n");
  for (const line of lines) {
    // If you want to skip lines that don't contain your framework key, do:
    if (!line.includes(framework)) continue;

    // Use matchAll to find 1+ matches in a single line
    const matches = [...line.matchAll(lineRegex2)];
    for (const match of matches) {
      const {
        dotKey,
        wikilink,
        mdText,
        mdLink,
        plainLink,
        json,
        quotedValue
      } = match.groups;

      // If parseLinksOnly is true and there's no link portion, skip
      if (parseLinksOnly && !wikilink && !mdText && !mdLink && !plainLink) {
        continue;
      }

      let jsonObject = null;
      if (json && parseStringifiedJSON) {
        try {
          jsonObject = JSON.parse(json); 
        } catch (err) {
          // Failed to parse as strict JSON, fallback to string
          console.warn(`Failed to parse JSON in ${inlink.path}:`, json);
        }
      }

      // Build a relationship object
      parsedConnections.push({
        sourceFile: inlink.path,             // The note containing the link
        dotKey,                              // e.g. "framework_here.applies_to"
        linkValue: wikilink || mdText || mdLink || plainLink, // The target or string
        json: jsonObject || json,           // Either a parsed object or raw string
        quotedValue                         // e.g. "Person_1"
      });
    }
  }
}

// 4) LOG RESULTS
console.log("Parsed Connections:", parsedConnections);

// 5) OPTIONAL: Render them in a Dataview table
dv.table(
  ["Source File", "dotKey", "Link Value", "JSON / Raw", "Quoted Value"],
  parsedConnections.map(conn => [
    conn.sourceFile,
    conn.dotKey,
    conn.linkValue,
    JSON.stringify(conn.json),  // convert object or string to text
    conn.quotedValue
  ])
);
```

### 1) Regex Testing

```js
////////////////////////////////////////////////////////////////////////////////
// PART 1: TESTING THE REGEX AGAINST SAMPLE STRINGS
////////////////////////////////////////////////////////////////////////////////

// 1) CONFIGURATION - we do not rely on YAML or anything yet, just hard-code "framework_here"
const framework = "framework_here";

// 2) BUILD THE REGEX
// Explanation of the pattern (multiline string for clarity):
//   - Optional leading spaces or bullet chars
//   - Optional "[" or "("
//   - `framework_here` plus optional .subkey
//   - `::` + optional spaces
//   - (Optional) any of: [[Wikilink]], [Markdown link](url), or plain link
//   - Optional JSON block {...} or quoted string "..."
//
//   We use the 'gm' flags to find multiple occurrences across multiple lines.

const lineRegex = new RegExp( String.raw`\s*(?:[-*+]\s*)?(?:\[|\()?(?<dotKey>framework_here(?:\.\w+)*)::\s*(?:\[\[(?<wikilink>[^|\]]+)\]\]|\[(?<mdText>[^\]]+?)\]\((?<mdLink>[^)]+?)\)|(?<plainLink>[^"\[\]\(\)\s{}]+))?\s*(?:(?<json>\{[^}]*\})|"(?<quotedValue>[^"]+)")?(?=\]|\)|$)`, "gm" );

// 3) SAMPLE LINES to test the regex
const sampleLines = [
  `framework_here.reviewer:: "Person_1"`,
  `[framework_here.applies_to:: [ID 12](ID%2012.md)]`,
  `(framework_here.applies_to:: [[ID 13]] {"sufficient": true, "control": true})`,
  `framework_here.reviewed:: [[ID 12]]`,
  `[framework_here.approved:: True]`,
  `(framework_here.score:: 9)`,
  `[framework_here.score:: [[ID 13]] {9}]`,
  // Some extra variations / indentation / bullets:
  `- [framework_here.applies_to:: [[ID 14]] {"test": 123}]`,
  `  framework_here.debug:: "NoLinkJustQuoted"`,
  `[framework_here.score:: [[ID 13]]]`,
  `(framework_here:: [ID 12](ID%2012.md))`
];

// 4) EXECUTE THE REGEX MATCH & PRINT RESULTS
for (const line of sampleLines) {
  console.log("Line:", line);
  let found = false;

  // .matchAll returns an iterator of all matches
  for (const match of line.matchAll(lineRegex)) {
    found = true;
    const {
      dotKey,
      wikilink,
      mdText,
      mdLink,
      plainLink,
      json,
      quotedValue
    } = match.groups;

    console.log("  MATCH =>", {
      dotKey,
      wikilink,
      mdText,
      mdLink,
      plainLink,
      json,
      quotedValue
    });
  }

  if (!found) {
    console.log("  NO MATCH.");
  }
}
```

Pseudocode:

```js

//------------------------------------------
// 1) CONFIGURATION / SETUP
//------------------------------------------

// Get configuration variables from the YAML frontmatter in the note
// - Read framework name from frontmatter; default to "framework_here"
const framework = dv.current().framework || "framework_here";

// Regex to parse out graph-link data

// Build a single-line RegExp that finds lines with our “dotKey:: link { JSON }” format.
// Test @ https://regex101.com/
// Explanation:
//   - Optional "[" or "(" at start
//   - Capture `framework` plus optional `.something`
//   - "::" then optional spaces
//   - (Optional) wiki/markdown/plain link
//   - (Optional) JSON block or quoted string
//   - End in "]" or ")" or line end without consuming them

const lineRegex = new RegExp(
  `\s*(?:[-*+]?\s*)?(?:\[|\()?(?<dotKey>${framework}(?:\.\w+)*)::\s*(?:\[\[(?<wikilink>[^\|\]]+)\]\]|\[(?<mdText>[^\]]+?)\]\((?<mdLink>[^)]+?)\)|(?<plainLink>[^"\[\]\(\)\s{}]+))?\s*(?:(?<json>\{[^}]*\})|"(?<quotedValue>[^"]+)")?(?=\]|\)|$)`, 
  "gm"
); // TODO - ignore whitespace or trime whitespace before processing?

	//----------------------------------
	// 1.a) Link Metadata Priority
	//      
	//      (aliases for this functionality)
	//
	//      Link Aggregation Configuration
	//      Link Metadata Priority Structure Configuration
	//      Link Property Prioritization Config
	//      Relationship Metadata Merging Configuration
	//      Metadata Hierarchy Configuration
	//      Priority for Graph Link Properties
	//
	//      Description:
	//           Defines how to handle link metadata by unifying or ovveriding 
	//           attributes/metadata when merging into the relationship object
	//           Helps to produce a more consolidated flexible representation
	//           of a relationship.
	//
	//-----------------------------------
	
		// Priority order for graph links
			//Explicit tags/links will be prioritized in the below order:
				//1. Inline tag with link with included metadata (JSON, etc.)
				//2. Inline tag w/dot notation to framework key with included value (in curly brackets, etc.)
				//3. Inline tag w/dot notation down to framework node (with tag value being an actual value for that node)
					//- (NOT DOING THIS YET - relates to representing framework as a tag structure)
				// 4. YAML frontmatter to framework keys with values in key value pairs
				// 5. YAML frontmatter down to framework node (with tag value being an actual value for that node)
					// - (NOT DOING THIS YET - relates to representing framework as a tag structure)

	//----------------------------------
	// 1.b) Relationship Query Context
	//      
	//      (aliases for this functionality)
	//
	//      Framework Query Level
	//      Evidence Query Level
	//
	//      Description:
	//           query context (leaf node, higher node, global) 
	//           (affects how links are parsed).
	//           This affects how the processing happens in the 
	//           background and not "necessarily" what's outputted.
	//           This is where you define guidance for the looping
	//           logic to have boundaries on what to iterate
	//           or read.
	//
	//-----------------------------------

// TODO

	//----------------------------------
	// 1.c) Additional Parsing Flags
	//      
	//      (aliases for this functionality)
	//
	//      Description:
	//           Extra flags that might affect parsing behavior
	//
	//-----------------------------------

	const parseStringifiedJSON = True; // Try to parse the { ... } content as JSON if present, Toggle for stringified JSON
	const parseLinksOnly = False; // If true, skip lines that have no link portion; Toggle for parsing only links in content

	//----------------------------------
	// 1.d) Dataview Output Configuration
	//      
	//      (aliases for this functionality)
	//
	//      Description:
	//           Whether to output, in the end, a structured type objects 
	//           (JSON, YAML, etc.), a grouped up type of output from 
	//           dataview syntax, or a flattened version of it in a table.
	//
	//-----------------------------------

// TODO

//------------------------------------------
// 2) INITIALIZE BACKEND VARIABLES / DATA STRUCTURES FOR RUNTIME
//------------------------------------------

// Runtime variables
// - uses dataview api to obtain initial data

// Grab all notes that link to this one:
const inlinks = dv.current().file.inlinks.values;
const parsedConnections = []; // Store incoming link data

//------------------------------------------
// 3) FIND INCOMING LINKS & PARSE
//------------------------------------------

// Loop through pages of inlinks to find lines with links to "framework" or current page
// - There may be a better way to get this data
// - The issue is that the additional metadata/custom syntax is not part of the linked data that is cached by Obsidian or dataview

	// For each line with the quick match to the framework, 
		// if in the leaf node context, then only search for links linking to the current page
		// if in a higher node context like a folder or higher part of the structured framework, search for all links "up to" that level in the framework?
		// if looks globally and not caring about optimization (config variable above) then just look for all matches to framework

		// use configured variables in '1.b' whether to do all of this with parent folder notes also (relies on using parent folder notes to implement)
		// parent folder relationship querying/handling would also need to be part of the defined priority structure logic too

		// Use the regexTemplate to parse out the different data points
		
		// Parse through the metadata/edge data/link data to build structure about the relationship between the source and current context/page

//------------------------------------------
// 4) RENDER OUTPUT
//------------------------------------------

// display the content in a table or as a structured object if need be (it has to be pretty)

```

```js
// Configuration Variables (Modular Behavior) 
const framework = dv.current().framework || "framework_here"; 

// Framework identifier 
const regexTemplate = `^(?:\[|\()?(?<dotKey>${framework}(?:\.\w+)*)::\s*(?:\[\[(?<wikilink>[^|\]]+)\]\]|\[(?<mdText>[^\]]+?)\]\((?<mdLink>[^)]+?)\)|(?<plainLink>[^"\[\]\(\)\s{}]+))?\s*(?:(?<json>\{[^}]*\})|"(?<quotedValue>[^"]+)")?(?=\]|\)|$)`;

// Default regex template 
const parseStringifiedJSON = true; // Toggle for stringified JSON 
const parseLinksOnly = true; // Toggle for parsing only links in content

// Custom Regex Examples (commented out for future use)
// const regexTemplate = `${framework}\\.applies_to:: \\[\\[.*?\\]\\] .*`; // Example for specific keys
// const regexTemplate = `${framework}\\.reviewer:: \\[\\[.*?\\]\\] .*`; // Example for reviewer

// Runtime Variables
const inlinks = dv.current().file.inlinks.values; // Incoming links to the current note
const parsedConnections = []; // Store parsed data

// Getting dv.page for incoming links
for (const link of inlinks) {
    const page = dv.page(link.path); // Get the Dataview page object
    console.log(`Page for ${link.path}:`, page);

    // Display useful properties
    dv.table(
        ["Property", "Value"],
        Object.entries(page || {}).map(([key, value]) => [key, JSON.stringify(value)])
    );
}

// Loop through content of pages of incoming links
for (const link of inlinks) {
    console.log(`Processing link: ${link.path}`);
    const noteContent = await dv.io.load(link.path); // Load the content of the inlink

	if (noteContent) { 
		console.log(`Content of ${link.path}:`); 
		console.log(noteContent);
		
		// Match regex in content
        const matches = noteContent.match(new RegExp(regexTemplate, 'g')) || [];
        console.log(`Matches in ${link.path}:`, matches);

        matches.forEach(match => {
            const parsed = match.match(/\[(.*?)\]\((.*?)\)\{(.*?)\}/); // Parse metadata
            if (parsed) {
                const [_, displayName, target, metadata] = parsed;
                parsedConnections.push({
                    source: link.path,
                    displayName,
                    target,
                    metadata: JSON.parse(metadata),
                });
            }
        });
    } else {
        console.log(`No content found for ${link.path}`);
    }
}

// Finding lines matching `framework_here`
for (const link of inlinks) {
    const content = await dv.io.load(link.path); // Load content of the linked file

    if (content) {
        console.log(`Content of ${link.path}:`, content);

        // Extract lines containing the framework
        const lines = content.split('\n').filter(line => line.includes('framework_here'));
        console.log(`Relevant lines in ${link.path}:`, lines);

        // Display extracted lines
        dv.list(lines);
    }
}

// Parsing metadata
const metadata = '{"name": "Reviewer A"}'; // Example metadata

try {
    const parsedMetadata = JSON.parse(metadata);
    console.log("Parsed Metadata:", parsedMetadata);
} catch (error) {
    console.error("Invalid JSON:", metadata);
}



```

---

Test regex with different templates/syntax:

```
const sampleContent = `
framework_here:: [framework_note](link_to_framework_note_here){sufficient: true, control: true, reviewer: "Person_1"}
framework_here.applies_to:: [[ID 12]] {"reviewer": "Person_1", "sufficient": true}
framework_here.reviewer:: [[ID 12]] {"name": "Reviewer A"}
framework_here.note:: [[Some Note]] [metadata here]
`;

const framework = "framework_here"; // Framework identifier

// Regex templates for different formats (curly brackets, inline metadata, etc.)
const regexTemplates = [
    `${framework}:: \\[.*?\\]\\(.*?\\)\\{.*?\\}`, // JSON with curly brackets
    `${framework}\\.\\w+:: \\[\\[.*?\\]\\] .*`, // JSON with square brackets
    `${framework}\\.\\w+:: \\[\\[.*?\\]\\] \\[.*?\\]`, // Inline metadata in square brackets
];

// Test all regex templates
regexTemplates.forEach((template, index) => {
    const matches = sampleContent.match(new RegExp(template, 'g')) || [];
    console.log(`Regex Template ${index + 1} Matches:`, matches);
    dv.list(matches); // Display matches in the output
});
```

Test regex:

```
const sampleContent = `
framework_here.applies_to:: [[ID 12]] {"reviewer": "Person_1", "sufficient": true}
framework_here.reviewer:: [[ID 12]] {"name": "Reviewer A"}
`;
const framework = "framework_here"; // Framework identifier

// Test regex
const matches = sampleContent.match(new RegExp(`${framework}\\.\\w+:: \\[\\[.*?\\]\\] .*`, 'g')) || [];
console.log("Regex Matches:", matches);

// Display matches
dv.list(matches);
```

Loop over content of the pages of incoming links:

```
const framework = dv.current().framework || "framework_here"; // Current framework identifier
const inlinks = dv.current().file.inlinks.values; // Incoming links to the current note

for (const link of inlinks) {
    console.log(`Processing link: ${link.path}`);
    const noteContent = await dv.io.load(link.path); // Load the content of the inlink

    if (noteContent) {
        console.log(`Content of ${link.path}:`);
        console.log(noteContent); // Log the content of the file
    } else {
        console.log(`No content found for ${link.path}`);
    }
}
```


List out incoming links:

```
const framework = dv.current().framework || "framework_here"; // Current framework identifier
const inlinks = dv.current().file.inlinks.values; // Incoming links to the current note
// Display inlinks in the output
dv.list(inlinks.map(link => link.path)); // This will list the paths of inlinks
```

## Tag-Based System Only