/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name3 in all)
    __defProp(target, name3, { get: all[name3], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/jws/lib/data-stream.js"(exports, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require("stream");
    var util = require("util");
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var SlowBuffer = require("buffer").SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports, module2) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if (typeof signature === "string") {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/jwa/index.js"(exports, module2) {
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto3 = require("crypto");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require("util");
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto3.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign2(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto3.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign2(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto3.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto3.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign2(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto3.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto3.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto3.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto3.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto3.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto3.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign2() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign2() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/jws/lib/tostring.js"(exports, module2) {
    var Buffer2 = require("buffer").Buffer;
    module2.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/jws/lib/sign-stream.js"(exports, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign2() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/jws/lib/verify-stream.js"(exports, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/jws/index.js"(exports) {
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports.ALGORITHMS = ALGORITHMS;
    exports.sign = SignStream.sign;
    exports.verify = VerifyStream.verify;
    exports.decode = VerifyStream.decode;
    exports.isValid = VerifyStream.isValid;
    exports.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/jsonwebtoken/decode.js"(exports, module2) {
    var jws = require_jws();
    module2.exports = function(jwt, options) {
      options = options || {};
      var decoded = jws.decode(jwt, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports, module2) {
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error)
        this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name3) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name3 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken/lib/timespan.js"(exports, module2) {
    var ms = require_ms();
    module2.exports = function(time, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp + time;
      } else {
        return;
      }
    };
  }
});

// node_modules/jsonwebtoken/node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/jsonwebtoken/node_modules/semver/semver.js"(exports, module2) {
    exports = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports.re = [];
    var src = exports.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    var i;
    exports.parse = parse;
    function parse(version3, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 !== "string") {
        return null;
      }
      if (version3.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version3)) {
        return null;
      }
      try {
        return new SemVer(version3, options);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version3, options) {
      var v = parse(version3, options);
      return v ? v.version : null;
    }
    exports.clean = clean;
    function clean(version3, options) {
      var s = parse(version3.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version3, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version3 instanceof SemVer) {
        if (version3.loose === options.loose) {
          return version3;
        } else {
          version3 = version3.version;
        }
      } else if (typeof version3 !== "string") {
        throw new TypeError("Invalid Version: " + version3);
      }
      if (version3.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version3, options);
      }
      debug("SemVer", version3, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version3.trim().match(options.loose ? re[LOOSE] : re[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version3);
      }
      this.raw = version3;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version3, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version3, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version22) {
      if (eq(version1, version22)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version22);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compare(a, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.rcompare(a, b, loose);
      });
    }
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version3) {
      debug("Comparator.test", version3, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version3 === "string") {
        version3 = new SemVer(version3, this.options);
      }
      return cmp(version3, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range2(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range2(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports.Range = Range2;
    function Range2(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range2) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range2(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range2(range.value, options);
      }
      if (!(this instanceof Range2)) {
        return new Range2(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range2.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range2.prototype.toString = function() {
      return this.range;
    };
    Range2.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range2.prototype.intersects = function(range, options) {
      if (!(range instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range2(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range2.prototype.test = function(version3) {
      if (!version3) {
        return false;
      }
      if (typeof version3 === "string") {
        version3 = new SemVer(version3, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version3, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version3, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies;
    function satisfies(version3, range, options) {
      try {
        range = new Range2(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version3);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range2(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range2(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range2(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range2(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version3, range, options) {
      return outside(version3, range, "<", options);
    }
    exports.gtr = gtr;
    function gtr(version3, range, options) {
      return outside(version3, range, ">", options);
    }
    exports.outside = outside;
    function outside(version3, range, hilo, options) {
      version3 = new SemVer(version3, options);
      range = new Range2(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports.prerelease = prerelease;
    function prerelease(version3, options) {
      var parsed = parse(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range2(r1, options);
      r2 = new Range2(r2, options);
      return r1.intersects(r2);
    }
    exports.coerce = coerce;
    function coerce(version3) {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 !== "string") {
        return null;
      }
      var match = version3.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/psSupported.js"(exports, module2) {
    var semver = require_semver();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/jsonwebtoken/verify.js"(exports, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      var done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err)
            throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      var parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      var decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      var header = decodedToken.header;
      var getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        var hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          options.algorithms = ["none"];
        }
        if (!options.algorithms) {
          options.algorithms = ~secretOrPublicKey2.toString().indexOf("BEGIN CERTIFICATE") || ~secretOrPublicKey2.toString().indexOf("BEGIN PUBLIC KEY") ? PUB_KEY_ALGS : ~secretOrPublicKey2.toString().indexOf("BEGIN RSA PUBLIC KEY") ? RSA_KEY_ALGS : HS_ALGS;
        }
        if (!~options.algorithms.indexOf(decodedToken.header.alg)) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        var valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        var payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          var match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          var invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          var maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          var signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.includes/index.js"(exports, module2) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign2 = value < 0 ? -1 : 1;
        return sign2 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module2.exports = includes;
  }
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isboolean/index.js"(exports, module2) {
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean;
  }
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isinteger/index.js"(exports, module2) {
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign2 = value < 0 ? -1 : 1;
        return sign2 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = isInteger;
  }
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.isnumber/index.js"(exports, module2) {
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module2.exports = isNumber;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports, module2) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports, module2) {
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.once/index.js"(exports, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign2 = value < 0 ? -1 : 1;
        return sign2 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = once;
  }
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "node_modules/jsonwebtoken/sign.js"(exports, module2) {
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean = require_lodash2();
    var isInteger = require_lodash3();
    var isNumber = require_lodash4();
    var isPlainObject = require_lodash5();
    var isString = require_lodash6();
    var once = require_lodash7();
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString, message: '"encoding" must be a string' },
      issuer: { isValid: isString, message: '"issuer" must be a string' },
      subject: { isValid: isString, message: '"subject" must be a string' },
      jwtid: { isValid: isString, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
    };
    function validate2(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        var validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate2(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate2(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      var isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      var header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        var invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      var timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        var claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      var encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          callback(null, signature);
        });
      } else {
        return jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
      }
    };
  }
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken/index.js"(exports, module2) {
    module2.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends3;
    var __assign3;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter3;
    var __generator3;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays3;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __classPrivateFieldIn2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends3 = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign3 = Object.assign || function(t2) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t2[p] = s[p];
        }
        return t2;
      };
      __rest2 = function(s, e) {
        var t2 = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t2[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t2[p[i]] = s[p[i]];
          }
        return t2;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter3 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator3 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f, y, t2, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                return t2;
              if (y = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m, p);
      };
      __createBinding2 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values2 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      };
      __spreadArrays3 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn2 = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends3);
      exporter("__assign", __assign3);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter3);
      exporter("__generator", __generator3);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays3);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
    });
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale3, strict) {
        return createLocalOrUTC(input, format2, locale3, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t2 = Object(this), len = t2.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t2 && fun.call(this, t2[i], i, t2)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name3, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name3, msg);
        }
        if (!deprecations[name3]) {
          warn(msg);
          deprecations[name3] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign3 = number >= 0;
        return (sign3 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(func.apply(this, arguments), token2);
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale3) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale3.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }));
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale3) {
        return locale3.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale3) {
        return locale3.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
            this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      });
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        doy: 6
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale3) {
        return locale3.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale3) {
        return locale3.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale3) {
        return locale3.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale3) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale3.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale3) {
        if (typeof input === "string") {
          return locale3.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
            this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
            this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
        this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale3) {
        return locale3._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale3, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale3 = loadLocale(split.slice(0, j).join("-"));
            if (locale3) {
              return locale3;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name3) {
        return name3.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name3) {
        var oldLocale = null, aliasedRequire;
        if (locales[name3] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name3)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name3);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name3] = null;
          }
        }
        return locales[name3];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn("Locale " + key + " not found. Did you forget to load it?");
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name3, config) {
        if (config !== null) {
          var locale3, parentConfig = baseConfig;
          config.abbr = name3;
          if (locales[name3] != null) {
            deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
            parentConfig = locales[name3]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale3 = loadLocale(config.parentLocale);
              if (locale3 != null) {
                parentConfig = locale3._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name: name3,
                  config
                });
                return null;
              }
            }
          }
          locales[name3] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name3]) {
            localeFamilies[name3].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name3);
          return locales[name3];
        } else {
          delete locales[name3];
          return null;
        }
      }
      function updateLocale(name3, config) {
        if (config != null) {
          var locale3, tmpLocale, parentConfig = baseConfig;
          if (locales[name3] != null && locales[name3].parentLocale != null) {
            locales[name3].set(mergeConfigs(locales[name3]._config, config));
          } else {
            tmpLocale = loadLocale(name3);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name3;
            }
            locale3 = new Locale(config);
            locale3.parentLocale = locales[name3];
            locales[name3] = locale3;
          }
          getSetGlobalLocale(name3);
        } else {
          if (locales[name3] != null) {
            if (locales[name3].parentLocale != null) {
              locales[name3] = locales[name3].parentLocale;
              if (name3 === getSetGlobalLocale()) {
                getSetGlobalLocale(name3);
              }
            } else if (locales[name3] != null) {
              delete locales[name3];
            }
          }
        }
        return locales[name3];
      }
      function getLocale(key) {
        var locale3;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale3 = loadLocale(key);
          if (locale3) {
            return locale3;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
      });
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale3, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale3.meridiemHour != null) {
          return locale3.meridiemHour(hour, meridiem2);
        } else if (locale3.isPM != null) {
          isPm = locale3.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function(obj) {
          return obj && parseInt(obj, 10);
        });
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale3, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale3 === true || locale3 === false) {
          strict = locale3;
          locale3 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale3;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale3, strict) {
        return createLocalOrUTC(input, format2, locale3, strict, false);
      }
      var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      });
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign3 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign3 = "-";
          }
          return sign3 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(this, createDuration(input - offset2, "m"), 1, false);
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign3, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign3 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign3,
            h: toInt(match[HOUR]) * sign3,
            m: toInt(match[MINUTE]) * sign3,
            s: toInt(match[SECOND]) * sign3,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign3
          };
        } else if (match = isoRegex.exec(input)) {
          sign3 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign3),
            M: parseIso(match[3], sign3),
            w: parseIso(match[4], sign3),
            d: parseIso(match[5], sign3),
            h: parseIso(match[6], sign3),
            m: parseIso(match[7], sign3),
            s: parseIso(match[8], sign3)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign3) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign3;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name3) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name3, "moment()." + name3 + "(period, number) is deprecated. Please use moment()." + name3 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(output || this.localeData().calendar(format2, this, createLocal(now2)));
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale2(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang2 = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      });
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
            break;
          case "isoWeek":
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
          case "isoWeek":
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      });
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name3, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name3 = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name3 === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name3, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale3) {
        return locale3.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale3) {
        return locale3.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale3) {
        return locale3.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale3) {
        return locale3._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale3) {
        return isStrict ? locale3._dayOfMonthOrdinalParse || locale3._ordinalParse : locale3._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang2;
      proto.locale = locale2;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
      proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
      proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
      proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
      proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale3 = getLocale(), utc = createUTC().set(setter, index);
        return locale3[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale3 = getLocale(), shift = localeSorted ? locale3._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
      hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name3) {
        return function() {
          return this.isValid() ? this._data[name3] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        w: null,
        M: 11
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale3) {
        return locale3.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale3) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale3;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale3, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale3 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale3);
        if (withSuffix) {
          output = locale3.pastFuture(+this, output);
        }
        return locale3.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign2(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign2(this._months) !== sign2(total) ? "-" : "";
        daysSign = sign2(this._days) !== sign2(total) ? "-" : "";
        hmsSign = sign2(this._milliseconds) !== sign2(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale2;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
      proto$2.lang = lang2;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        DATE: "YYYY-MM-DD",
        TIME: "HH:mm",
        TIME_SECONDS: "HH:mm:ss",
        TIME_MS: "HH:mm:ss.SSS",
        WEEK: "GGGG-[W]WW",
        MONTH: "YYYY-MM"
      };
      return hooks;
    });
  }
});

// node_modules/eventemitter2/lib/eventemitter2.js
var require_eventemitter2 = __commonJS({
  "node_modules/eventemitter2/lib/eventemitter2.js"(exports, module2) {
    !function(undefined2) {
      var hasOwnProperty = Object.hasOwnProperty;
      var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      var defaultMaxListeners = 10;
      var nextTickSupported = typeof process == "object" && typeof process.nextTick == "function";
      var symbolsSupported = typeof Symbol === "function";
      var reflectSupported = typeof Reflect === "object";
      var setImmediateSupported = typeof setImmediate === "function";
      var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;
      var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
        var arr = Object.getOwnPropertyNames(obj);
        arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
        return arr;
      } : Object.keys;
      function init() {
        this._events = {};
        if (this._conf) {
          configure.call(this, this._conf);
        }
      }
      function configure(conf) {
        if (conf) {
          this._conf = conf;
          conf.delimiter && (this.delimiter = conf.delimiter);
          if (conf.maxListeners !== undefined2) {
            this._maxListeners = conf.maxListeners;
          }
          conf.wildcard && (this.wildcard = conf.wildcard);
          conf.newListener && (this._newListener = conf.newListener);
          conf.removeListener && (this._removeListener = conf.removeListener);
          conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
          conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
          if (this.wildcard) {
            this.listenerTree = {};
          }
        }
      }
      function logPossibleMemoryLeak(count, eventName) {
        var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
        if (this.verboseMemoryLeak) {
          errorMsg += " Event name: " + eventName + ".";
        }
        if (typeof process !== "undefined" && process.emitWarning) {
          var e = new Error(errorMsg);
          e.name = "MaxListenersExceededWarning";
          e.emitter = this;
          e.count = count;
          process.emitWarning(e);
        } else {
          console.error(errorMsg);
          if (console.trace) {
            console.trace();
          }
        }
      }
      var toArray = function(a, b, c) {
        var n = arguments.length;
        switch (n) {
          case 0:
            return [];
          case 1:
            return [a];
          case 2:
            return [a, b];
          case 3:
            return [a, b, c];
          default:
            var arr = new Array(n);
            while (n--) {
              arr[n] = arguments[n];
            }
            return arr;
        }
      };
      function toObject(keys, values) {
        var obj = {};
        var key;
        var len = keys.length;
        var valuesCount = values ? values.length : 0;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          obj[key] = i < valuesCount ? values[i] : undefined2;
        }
        return obj;
      }
      function TargetObserver(emitter, target, options) {
        this._emitter = emitter;
        this._target = target;
        this._listeners = {};
        this._listenersCount = 0;
        var on, off;
        if (options.on || options.off) {
          on = options.on;
          off = options.off;
        }
        if (target.addEventListener) {
          on = target.addEventListener;
          off = target.removeEventListener;
        } else if (target.addListener) {
          on = target.addListener;
          off = target.removeListener;
        } else if (target.on) {
          on = target.on;
          off = target.off;
        }
        if (!on && !off) {
          throw Error("target does not implement any known event API");
        }
        if (typeof on !== "function") {
          throw TypeError("on method must be a function");
        }
        if (typeof off !== "function") {
          throw TypeError("off method must be a function");
        }
        this._on = on;
        this._off = off;
        var _observers = emitter._observers;
        if (_observers) {
          _observers.push(this);
        } else {
          emitter._observers = [this];
        }
      }
      Object.assign(TargetObserver.prototype, {
        subscribe: function(event, localEvent, reducer) {
          var observer = this;
          var target = this._target;
          var emitter = this._emitter;
          var listeners = this._listeners;
          var handler = function() {
            var args = toArray.apply(null, arguments);
            var eventObj = {
              data: args,
              name: localEvent,
              original: event
            };
            if (reducer) {
              var result = reducer.call(target, eventObj);
              if (result !== false) {
                emitter.emit.apply(emitter, [eventObj.name].concat(args));
              }
              return;
            }
            emitter.emit.apply(emitter, [localEvent].concat(args));
          };
          if (listeners[event]) {
            throw Error("Event '" + event + "' is already listening");
          }
          this._listenersCount++;
          if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {
            this._onNewListener = function(_event) {
              if (_event === localEvent && listeners[event] === null) {
                listeners[event] = handler;
                observer._on.call(target, event, handler);
              }
            };
            emitter.on("newListener", this._onNewListener);
            this._onRemoveListener = function(_event) {
              if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {
                listeners[event] = null;
                observer._off.call(target, event, handler);
              }
            };
            listeners[event] = null;
            emitter.on("removeListener", this._onRemoveListener);
          } else {
            listeners[event] = handler;
            observer._on.call(target, event, handler);
          }
        },
        unsubscribe: function(event) {
          var observer = this;
          var listeners = this._listeners;
          var emitter = this._emitter;
          var handler;
          var events;
          var off = this._off;
          var target = this._target;
          var i;
          if (event && typeof event !== "string") {
            throw TypeError("event must be a string");
          }
          function clearRefs() {
            if (observer._onNewListener) {
              emitter.off("newListener", observer._onNewListener);
              emitter.off("removeListener", observer._onRemoveListener);
              observer._onNewListener = null;
              observer._onRemoveListener = null;
            }
            var index = findTargetIndex.call(emitter, observer);
            emitter._observers.splice(index, 1);
          }
          if (event) {
            handler = listeners[event];
            if (!handler)
              return;
            off.call(target, event, handler);
            delete listeners[event];
            if (!--this._listenersCount) {
              clearRefs();
            }
          } else {
            events = ownKeys(listeners);
            i = events.length;
            while (i-- > 0) {
              event = events[i];
              off.call(target, event, listeners[event]);
            }
            this._listeners = {};
            this._listenersCount = 0;
            clearRefs();
          }
        }
      });
      function resolveOptions(options, schema, reducers, allowUnknown) {
        var computedOptions = Object.assign({}, schema);
        if (!options)
          return computedOptions;
        if (typeof options !== "object") {
          throw TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var length = keys.length;
        var option, value;
        var reducer;
        function reject(reason) {
          throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
        }
        for (var i = 0; i < length; i++) {
          option = keys[i];
          if (!allowUnknown && !hasOwnProperty.call(schema, option)) {
            throw Error('Unknown "' + option + '" option');
          }
          value = options[option];
          if (value !== undefined2) {
            reducer = reducers[option];
            computedOptions[option] = reducer ? reducer(value, reject) : value;
          }
        }
        return computedOptions;
      }
      function constructorReducer(value, reject) {
        if (typeof value !== "function" || !value.hasOwnProperty("prototype")) {
          reject("value must be a constructor");
        }
        return value;
      }
      function makeTypeReducer(types) {
        var message = "value must be type of " + types.join("|");
        var len = types.length;
        var firstType = types[0];
        var secondType = types[1];
        if (len === 1) {
          return function(v, reject) {
            if (typeof v === firstType) {
              return v;
            }
            reject(message);
          };
        }
        if (len === 2) {
          return function(v, reject) {
            var kind = typeof v;
            if (kind === firstType || kind === secondType)
              return v;
            reject(message);
          };
        }
        return function(v, reject) {
          var kind = typeof v;
          var i = len;
          while (i-- > 0) {
            if (kind === types[i])
              return v;
          }
          reject(message);
        };
      }
      var functionReducer = makeTypeReducer(["function"]);
      var objectFunctionReducer = makeTypeReducer(["object", "function"]);
      function makeCancelablePromise(Promise2, executor, options) {
        var isCancelable;
        var callbacks;
        var timer = 0;
        var subscriptionClosed;
        var promise = new Promise2(function(resolve, reject, onCancel) {
          options = resolveOptions(options, {
            timeout: 0,
            overload: false
          }, {
            timeout: function(value, reject2) {
              value *= 1;
              if (typeof value !== "number" || value < 0 || !Number.isFinite(value)) {
                reject2("timeout must be a positive number");
              }
              return value;
            }
          });
          isCancelable = !options.overload && typeof Promise2.prototype.cancel === "function" && typeof onCancel === "function";
          function cleanup() {
            if (callbacks) {
              callbacks = null;
            }
            if (timer) {
              clearTimeout(timer);
              timer = 0;
            }
          }
          var _resolve = function(value) {
            cleanup();
            resolve(value);
          };
          var _reject = function(err) {
            cleanup();
            reject(err);
          };
          if (isCancelable) {
            executor(_resolve, _reject, onCancel);
          } else {
            callbacks = [function(reason) {
              _reject(reason || Error("canceled"));
            }];
            executor(_resolve, _reject, function(cb) {
              if (subscriptionClosed) {
                throw Error("Unable to subscribe on cancel event asynchronously");
              }
              if (typeof cb !== "function") {
                throw TypeError("onCancel callback must be a function");
              }
              callbacks.push(cb);
            });
            subscriptionClosed = true;
          }
          if (options.timeout > 0) {
            timer = setTimeout(function() {
              var reason = Error("timeout");
              reason.code = "ETIMEDOUT";
              timer = 0;
              promise.cancel(reason);
              reject(reason);
            }, options.timeout);
          }
        });
        if (!isCancelable) {
          promise.cancel = function(reason) {
            if (!callbacks) {
              return;
            }
            var length = callbacks.length;
            for (var i = 1; i < length; i++) {
              callbacks[i](reason);
            }
            callbacks[0](reason);
            callbacks = null;
          };
        }
        return promise;
      }
      function findTargetIndex(observer) {
        var observers = this._observers;
        if (!observers) {
          return -1;
        }
        var len = observers.length;
        for (var i = 0; i < len; i++) {
          if (observers[i]._target === observer)
            return i;
        }
        return -1;
      }
      function searchListenerTree(handlers, type, tree, i, typeLength) {
        if (!tree) {
          return null;
        }
        if (i === 0) {
          var kind = typeof type;
          if (kind === "string") {
            var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
            if ((n = type.indexOf(delimiter)) !== -1) {
              ns = new Array(5);
              do {
                ns[l++] = type.slice(j, n);
                j = n + dl;
              } while ((n = type.indexOf(delimiter, j)) !== -1);
              ns[l++] = type.slice(j);
              type = ns;
              typeLength = l;
            } else {
              type = [type];
              typeLength = 1;
            }
          } else if (kind === "object") {
            typeLength = type.length;
          } else {
            type = [type];
            typeLength = 1;
          }
        }
        var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i], nextType = type[i + 1], branches, _listeners;
        if (i === typeLength) {
          if (tree._listeners) {
            if (typeof tree._listeners === "function") {
              handlers && handlers.push(tree._listeners);
              listeners = [tree];
            } else {
              handlers && handlers.push.apply(handlers, tree._listeners);
              listeners = [tree];
            }
          }
        } else {
          if (currentType === "*") {
            branches = ownKeys(tree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (currentType === "**") {
            endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === "*";
            if (endReached && tree._listeners) {
              listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
            }
            branches = ownKeys(tree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                if (branch === "*" || branch === "**") {
                  if (tree[branch]._listeners && !endReached) {
                    _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                    if (_listeners) {
                      if (listeners) {
                        listeners.push.apply(listeners, _listeners);
                      } else {
                        listeners = _listeners;
                      }
                    }
                  }
                  _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                } else if (branch === nextType) {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);
                } else {
                  _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
                }
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (tree[currentType]) {
            listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);
          }
        }
        xTree = tree["*"];
        if (xTree) {
          searchListenerTree(handlers, type, xTree, i + 1, typeLength);
        }
        xxTree = tree["**"];
        if (xxTree) {
          if (i < typeLength) {
            if (xxTree._listeners) {
              searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
            }
            branches = ownKeys(xxTree);
            n = branches.length;
            while (n-- > 0) {
              branch = branches[n];
              if (branch !== "_listeners") {
                if (branch === nextType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);
                } else if (branch === currentType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);
                } else {
                  isolatedBranch = {};
                  isolatedBranch[branch] = xxTree[branch];
                  searchListenerTree(handlers, type, { "**": isolatedBranch }, i + 1, typeLength);
                }
              }
            }
          } else if (xxTree._listeners) {
            searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
          } else if (xxTree["*"] && xxTree["*"]._listeners) {
            searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
          }
        }
        return listeners;
      }
      function growListenerTree(type, listener, prepend) {
        var len = 0, j = 0, i, delimiter = this.delimiter, dl = delimiter.length, ns;
        if (typeof type === "string") {
          if ((i = type.indexOf(delimiter)) !== -1) {
            ns = new Array(5);
            do {
              ns[len++] = type.slice(j, i);
              j = i + dl;
            } while ((i = type.indexOf(delimiter, j)) !== -1);
            ns[len++] = type.slice(j);
          } else {
            ns = [type];
            len = 1;
          }
        } else {
          ns = type;
          len = type.length;
        }
        if (len > 1) {
          for (i = 0; i + 1 < len; i++) {
            if (ns[i] === "**" && ns[i + 1] === "**") {
              return;
            }
          }
        }
        var tree = this.listenerTree, name3;
        for (i = 0; i < len; i++) {
          name3 = ns[i];
          tree = tree[name3] || (tree[name3] = {});
          if (i === len - 1) {
            if (!tree._listeners) {
              tree._listeners = listener;
            } else {
              if (typeof tree._listeners === "function") {
                tree._listeners = [tree._listeners];
              }
              if (prepend) {
                tree._listeners.unshift(listener);
              } else {
                tree._listeners.push(listener);
              }
              if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                tree._listeners.warned = true;
                logPossibleMemoryLeak.call(this, tree._listeners.length, name3);
              }
            }
            return true;
          }
        }
        return true;
      }
      function collectTreeEvents(tree, events, root, asArray) {
        var branches = ownKeys(tree);
        var i = branches.length;
        var branch, branchName, path;
        var hasListeners = tree["_listeners"];
        var isArrayPath;
        while (i-- > 0) {
          branchName = branches[i];
          branch = tree[branchName];
          if (branchName === "_listeners") {
            path = root;
          } else {
            path = root ? root.concat(branchName) : [branchName];
          }
          isArrayPath = asArray || typeof branchName === "symbol";
          hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));
          if (typeof branch === "object") {
            collectTreeEvents.call(this, branch, events, path, isArrayPath);
          }
        }
        return events;
      }
      function recursivelyGarbageCollect(root) {
        var keys = ownKeys(root);
        var i = keys.length;
        var obj, key, flag;
        while (i-- > 0) {
          key = keys[i];
          obj = root[key];
          if (obj) {
            flag = true;
            if (key !== "_listeners" && !recursivelyGarbageCollect(obj)) {
              delete root[key];
            }
          }
        }
        return flag;
      }
      function Listener(emitter, event, listener) {
        this.emitter = emitter;
        this.event = event;
        this.listener = listener;
      }
      Listener.prototype.off = function() {
        this.emitter.off(this.event, this.listener);
        return this;
      };
      function setupListener(event, listener, options) {
        if (options === true) {
          promisify = true;
        } else if (options === false) {
          async = true;
        } else {
          if (!options || typeof options !== "object") {
            throw TypeError("options should be an object or true");
          }
          var async = options.async;
          var promisify = options.promisify;
          var nextTick = options.nextTick;
          var objectify = options.objectify;
        }
        if (async || nextTick || promisify) {
          var _listener = listener;
          var _origin = listener._origin || listener;
          if (nextTick && !nextTickSupported) {
            throw Error("process.nextTick is not supported");
          }
          if (promisify === undefined2) {
            promisify = listener.constructor.name === "AsyncFunction";
          }
          listener = function() {
            var args = arguments;
            var context = this;
            var event2 = this.event;
            return promisify ? nextTick ? Promise.resolve() : new Promise(function(resolve) {
              _setImmediate(resolve);
            }).then(function() {
              context.event = event2;
              return _listener.apply(context, args);
            }) : (nextTick ? process.nextTick : _setImmediate)(function() {
              context.event = event2;
              _listener.apply(context, args);
            });
          };
          listener._async = true;
          listener._origin = _origin;
        }
        return [listener, objectify ? new Listener(this, event, listener) : this];
      }
      function EventEmitter(conf) {
        this._events = {};
        this._newListener = false;
        this._removeListener = false;
        this.verboseMemoryLeak = false;
        configure.call(this, conf);
      }
      EventEmitter.EventEmitter2 = EventEmitter;
      EventEmitter.prototype.listenTo = function(target, events, options) {
        if (typeof target !== "object") {
          throw TypeError("target musts be an object");
        }
        var emitter = this;
        options = resolveOptions(options, {
          on: undefined2,
          off: undefined2,
          reducers: undefined2
        }, {
          on: functionReducer,
          off: functionReducer,
          reducers: objectFunctionReducer
        });
        function listen(events2) {
          if (typeof events2 !== "object") {
            throw TypeError("events must be an object");
          }
          var reducers = options.reducers;
          var index = findTargetIndex.call(emitter, target);
          var observer;
          if (index === -1) {
            observer = new TargetObserver(emitter, target, options);
          } else {
            observer = emitter._observers[index];
          }
          var keys = ownKeys(events2);
          var len = keys.length;
          var event;
          var isSingleReducer = typeof reducers === "function";
          for (var i = 0; i < len; i++) {
            event = keys[i];
            observer.subscribe(event, events2[event] || event, isSingleReducer ? reducers : reducers && reducers[event]);
          }
        }
        isArray(events) ? listen(toObject(events)) : typeof events === "string" ? listen(toObject(events.split(/\s+/))) : listen(events);
        return this;
      };
      EventEmitter.prototype.stopListeningTo = function(target, event) {
        var observers = this._observers;
        if (!observers) {
          return false;
        }
        var i = observers.length;
        var observer;
        var matched = false;
        if (target && typeof target !== "object") {
          throw TypeError("target should be an object");
        }
        while (i-- > 0) {
          observer = observers[i];
          if (!target || observer._target === target) {
            observer.unsubscribe(event);
            matched = true;
          }
        }
        return matched;
      };
      EventEmitter.prototype.delimiter = ".";
      EventEmitter.prototype.setMaxListeners = function(n) {
        if (n !== undefined2) {
          this._maxListeners = n;
          if (!this._conf)
            this._conf = {};
          this._conf.maxListeners = n;
        }
      };
      EventEmitter.prototype.getMaxListeners = function() {
        return this._maxListeners;
      };
      EventEmitter.prototype.event = "";
      EventEmitter.prototype.once = function(event, fn, options) {
        return this._once(event, fn, false, options);
      };
      EventEmitter.prototype.prependOnceListener = function(event, fn, options) {
        return this._once(event, fn, true, options);
      };
      EventEmitter.prototype._once = function(event, fn, prepend, options) {
        return this._many(event, 1, fn, prepend, options);
      };
      EventEmitter.prototype.many = function(event, ttl, fn, options) {
        return this._many(event, ttl, fn, false, options);
      };
      EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {
        return this._many(event, ttl, fn, true, options);
      };
      EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {
        var self2 = this;
        if (typeof fn !== "function") {
          throw new Error("many only accepts instances of Function");
        }
        function listener() {
          if (--ttl === 0) {
            self2.off(event, listener);
          }
          return fn.apply(this, arguments);
        }
        listener._origin = fn;
        return this._on(event, listener, prepend, options);
      };
      EventEmitter.prototype.emit = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init.call(this);
        var type = arguments[0], ns, wildcard = this.wildcard;
        var args, l, i, j, containsSymbol;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return false;
          }
        }
        if (wildcard) {
          ns = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l = type.length;
              if (symbolsSupported) {
                for (i = 0; i < l; i++) {
                  if (typeof type[i] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var al = arguments.length;
        var handler;
        if (this._all && this._all.length) {
          handler = this._all.slice();
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i].call(this, type);
                break;
              case 2:
                handler[i].call(this, type, arguments[1]);
                break;
              case 3:
                handler[i].call(this, type, arguments[1], arguments[2]);
                break;
              default:
                handler[i].apply(this, arguments);
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);
        } else {
          handler = this._events[type];
          if (typeof handler === "function") {
            this.event = type;
            switch (al) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                args = new Array(al - 1);
                for (j = 1; j < al; j++)
                  args[j - 1] = arguments[j];
                handler.apply(this, args);
            }
            return true;
          } else if (handler) {
            handler = handler.slice();
          }
        }
        if (handler && handler.length) {
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++)
              args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                handler[i].call(this);
                break;
              case 2:
                handler[i].call(this, arguments[1]);
                break;
              case 3:
                handler[i].call(this, arguments[1], arguments[2]);
                break;
              default:
                handler[i].apply(this, args);
            }
          }
          return true;
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
        }
        return !!this._all;
      };
      EventEmitter.prototype.emitAsync = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init.call(this);
        var type = arguments[0], wildcard = this.wildcard, ns, containsSymbol;
        var args, l, i, j;
        if (type === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return Promise.resolve([false]);
          }
        }
        if (wildcard) {
          ns = type;
          if (type !== "newListener" && type !== "removeListener") {
            if (typeof type === "object") {
              l = type.length;
              if (symbolsSupported) {
                for (i = 0; i < l; i++) {
                  if (typeof type[i] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type = type.join(this.delimiter);
              }
            }
          }
        }
        var promises = [];
        var al = arguments.length;
        var handler;
        if (this._all) {
          for (i = 0, l = this._all.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(this._all[i].call(this, type));
                break;
              case 2:
                promises.push(this._all[i].call(this, type, arguments[1]));
                break;
              case 3:
                promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
                break;
              default:
                promises.push(this._all[i].apply(this, arguments));
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else {
          handler = this._events[type];
        }
        if (typeof handler === "function") {
          this.event = type;
          switch (al) {
            case 1:
              promises.push(handler.call(this));
              break;
            case 2:
              promises.push(handler.call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler.call(this, arguments[1], arguments[2]));
              break;
            default:
              args = new Array(al - 1);
              for (j = 1; j < al; j++)
                args[j - 1] = arguments[j];
              promises.push(handler.apply(this, args));
          }
        } else if (handler && handler.length) {
          handler = handler.slice();
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++)
              args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
              case 1:
                promises.push(handler[i].call(this));
                break;
              case 2:
                promises.push(handler[i].call(this, arguments[1]));
                break;
              case 3:
                promises.push(handler[i].call(this, arguments[1], arguments[2]));
                break;
              default:
                promises.push(handler[i].apply(this, args));
            }
          }
        } else if (!this.ignoreErrors && !this._all && type === "error") {
          if (arguments[1] instanceof Error) {
            return Promise.reject(arguments[1]);
          } else {
            return Promise.reject("Uncaught, unspecified 'error' event.");
          }
        }
        return Promise.all(promises);
      };
      EventEmitter.prototype.on = function(type, listener, options) {
        return this._on(type, listener, false, options);
      };
      EventEmitter.prototype.prependListener = function(type, listener, options) {
        return this._on(type, listener, true, options);
      };
      EventEmitter.prototype.onAny = function(fn) {
        return this._onAny(fn, false);
      };
      EventEmitter.prototype.prependAny = function(fn) {
        return this._onAny(fn, true);
      };
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prototype._onAny = function(fn, prepend) {
        if (typeof fn !== "function") {
          throw new Error("onAny only accepts instances of Function");
        }
        if (!this._all) {
          this._all = [];
        }
        if (prepend) {
          this._all.unshift(fn);
        } else {
          this._all.push(fn);
        }
        return this;
      };
      EventEmitter.prototype._on = function(type, listener, prepend, options) {
        if (typeof type === "function") {
          this._onAny(type, listener);
          return this;
        }
        if (typeof listener !== "function") {
          throw new Error("on only accepts instances of Function");
        }
        this._events || init.call(this);
        var returnValue = this, temp;
        if (options !== undefined2) {
          temp = setupListener.call(this, type, listener, options);
          listener = temp[0];
          returnValue = temp[1];
        }
        if (this._newListener) {
          this.emit("newListener", type, listener);
        }
        if (this.wildcard) {
          growListenerTree.call(this, type, listener, prepend);
          return returnValue;
        }
        if (!this._events[type]) {
          this._events[type] = listener;
        } else {
          if (typeof this._events[type] === "function") {
            this._events[type] = [this._events[type]];
          }
          if (prepend) {
            this._events[type].unshift(listener);
          } else {
            this._events[type].push(listener);
          }
          if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
            this._events[type].warned = true;
            logPossibleMemoryLeak.call(this, this._events[type].length, type);
          }
        }
        return returnValue;
      };
      EventEmitter.prototype.off = function(type, listener) {
        if (typeof listener !== "function") {
          throw new Error("removeListener only takes instances of Function");
        }
        var handlers, leafs = [];
        if (this.wildcard) {
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
          if (!leafs)
            return this;
        } else {
          if (!this._events[type])
            return this;
          handlers = this._events[type];
          leafs.push({ _listeners: handlers });
        }
        for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          handlers = leaf._listeners;
          if (isArray(handlers)) {
            var position = -1;
            for (var i = 0, length = handlers.length; i < length; i++) {
              if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
                position = i;
                break;
              }
            }
            if (position < 0) {
              continue;
            }
            if (this.wildcard) {
              leaf._listeners.splice(position, 1);
            } else {
              this._events[type].splice(position, 1);
            }
            if (handlers.length === 0) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type];
              }
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
            return this;
          } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type];
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
          }
        }
        this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        return this;
      };
      EventEmitter.prototype.offAny = function(fn) {
        var i = 0, l = 0, fns;
        if (fn && this._all && this._all.length > 0) {
          fns = this._all;
          for (i = 0, l = fns.length; i < l; i++) {
            if (fn === fns[i]) {
              fns.splice(i, 1);
              if (this._removeListener)
                this.emit("removeListenerAny", fn);
              return this;
            }
          }
        } else {
          fns = this._all;
          if (this._removeListener) {
            for (i = 0, l = fns.length; i < l; i++)
              this.emit("removeListenerAny", fns[i]);
          }
          this._all = [];
        }
        return this;
      };
      EventEmitter.prototype.removeListener = EventEmitter.prototype.off;
      EventEmitter.prototype.removeAllListeners = function(type) {
        if (type === undefined2) {
          !this._events || init.call(this);
          return this;
        }
        if (this.wildcard) {
          var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;
          if (!leafs)
            return this;
          for (i = 0; i < leafs.length; i++) {
            leaf = leafs[i];
            leaf._listeners = null;
          }
          this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        } else if (this._events) {
          this._events[type] = null;
        }
        return this;
      };
      EventEmitter.prototype.listeners = function(type) {
        var _events = this._events;
        var keys, listeners, allListeners;
        var i;
        var listenerTree;
        if (type === undefined2) {
          if (this.wildcard) {
            throw Error("event name required for wildcard emitter");
          }
          if (!_events) {
            return [];
          }
          keys = ownKeys(_events);
          i = keys.length;
          allListeners = [];
          while (i-- > 0) {
            listeners = _events[keys[i]];
            if (typeof listeners === "function") {
              allListeners.push(listeners);
            } else {
              allListeners.push.apply(allListeners, listeners);
            }
          }
          return allListeners;
        } else {
          if (this.wildcard) {
            listenerTree = this.listenerTree;
            if (!listenerTree)
              return [];
            var handlers = [];
            var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
            searchListenerTree.call(this, handlers, ns, listenerTree, 0);
            return handlers;
          }
          if (!_events) {
            return [];
          }
          listeners = _events[type];
          if (!listeners) {
            return [];
          }
          return typeof listeners === "function" ? [listeners] : listeners;
        }
      };
      EventEmitter.prototype.eventNames = function(nsAsArray) {
        var _events = this._events;
        return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
      };
      EventEmitter.prototype.listenerCount = function(type) {
        return this.listeners(type).length;
      };
      EventEmitter.prototype.hasListeners = function(type) {
        if (this.wildcard) {
          var handlers = [];
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
          return handlers.length > 0;
        }
        var _events = this._events;
        var _all = this._all;
        return !!(_all && _all.length || _events && (type === undefined2 ? ownKeys(_events).length : _events[type]));
      };
      EventEmitter.prototype.listenersAny = function() {
        if (this._all) {
          return this._all;
        } else {
          return [];
        }
      };
      EventEmitter.prototype.waitFor = function(event, options) {
        var self2 = this;
        var type = typeof options;
        if (type === "number") {
          options = { timeout: options };
        } else if (type === "function") {
          options = { filter: options };
        }
        options = resolveOptions(options, {
          timeout: 0,
          filter: undefined2,
          handleError: false,
          Promise,
          overload: false
        }, {
          filter: functionReducer,
          Promise: constructorReducer
        });
        return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
          function listener() {
            var filter = options.filter;
            if (filter && !filter.apply(self2, arguments)) {
              return;
            }
            self2.off(event, listener);
            if (options.handleError) {
              var err = arguments[0];
              err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));
            } else {
              resolve(toArray.apply(null, arguments));
            }
          }
          onCancel(function() {
            self2.off(event, listener);
          });
          self2._on(event, listener, false);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      };
      function once(emitter, name3, options) {
        options = resolveOptions(options, {
          Promise,
          timeout: 0,
          overload: false
        }, {
          Promise: constructorReducer
        });
        var _Promise = options.Promise;
        return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
          var handler;
          if (typeof emitter.addEventListener === "function") {
            handler = function() {
              resolve(toArray.apply(null, arguments));
            };
            onCancel(function() {
              emitter.removeEventListener(name3, handler);
            });
            emitter.addEventListener(name3, handler, { once: true });
            return;
          }
          var eventListener = function() {
            errorListener && emitter.removeListener("error", errorListener);
            resolve(toArray.apply(null, arguments));
          };
          var errorListener;
          if (name3 !== "error") {
            errorListener = function(err) {
              emitter.removeListener(name3, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          onCancel(function() {
            errorListener && emitter.removeListener("error", errorListener);
            emitter.removeListener(name3, eventListener);
          });
          emitter.once(name3, eventListener);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      }
      var prototype = EventEmitter.prototype;
      Object.defineProperties(EventEmitter, {
        defaultMaxListeners: {
          get: function() {
            return prototype._maxListeners;
          },
          set: function(n) {
            if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
              throw TypeError("n must be a non-negative number");
            }
            prototype._maxListeners = n;
          },
          enumerable: true
        },
        once: {
          value: once,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperties(prototype, {
        _maxListeners: {
          value: defaultMaxListeners,
          writable: true,
          configurable: true
        },
        _observers: { value: null, writable: true, configurable: true }
      });
      if (typeof define === "function" && define.amd) {
        define(function() {
          return EventEmitter;
        });
      } else if (typeof exports === "object") {
        module2.exports = EventEmitter;
      } else {
        var _global = new Function("", "return this")();
        _global.EventEmitter2 = EventEmitter;
      }
    }();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MsTodoSync
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// node_modules/@azure/msal-common/dist/_virtual/_tslib.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign3(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}

// node_modules/@azure/msal-common/dist/utils/Constants.js
var Constants = {
  LIBRARY_NAME: "MSAL.JS",
  SKU: "msal.js.common",
  CACHE_PREFIX: "msal",
  DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
  DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
  DEFAULT_COMMON_TENANT: "common",
  ADFS: "adfs",
  DSTS: "dstsv2",
  AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
  RESOURCE_DELIM: "|",
  NO_ACCOUNT: "NO_ACCOUNT",
  CLAIMS: "claims",
  CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
  OPENID_SCOPE: "openid",
  PROFILE_SCOPE: "profile",
  OFFLINE_ACCESS_SCOPE: "offline_access",
  EMAIL_SCOPE: "email",
  CODE_RESPONSE_TYPE: "code",
  CODE_GRANT_TYPE: "authorization_code",
  RT_GRANT_TYPE: "refresh_token",
  FRAGMENT_RESPONSE_MODE: "fragment",
  S256_CODE_CHALLENGE_METHOD: "S256",
  URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
  AUTHORIZATION_PENDING: "authorization_pending",
  NOT_DEFINED: "not_defined",
  EMPTY_STRING: "",
  FORWARD_SLASH: "/",
  IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
  IMDS_VERSION: "2020-06-01",
  IMDS_TIMEOUT: 2e3,
  AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
  REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
  REGIONAL_AUTH_NON_MSI_QUERY_STRING: "allowestsrnonmsi=true",
  KNOWN_PUBLIC_CLOUDS: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"],
  TOKEN_RESPONSE_TYPE: "token",
  ID_TOKEN_RESPONSE_TYPE: "id_token",
  SHR_NONCE_VALIDITY: 240
};
var OIDC_DEFAULT_SCOPES = [
  Constants.OPENID_SCOPE,
  Constants.PROFILE_SCOPE,
  Constants.OFFLINE_ACCESS_SCOPE
];
var OIDC_SCOPES = __spreadArrays(OIDC_DEFAULT_SCOPES, [
  Constants.EMAIL_SCOPE
]);
var HeaderNames;
(function(HeaderNames2) {
  HeaderNames2["CONTENT_TYPE"] = "Content-Type";
  HeaderNames2["RETRY_AFTER"] = "Retry-After";
  HeaderNames2["CCS_HEADER"] = "X-AnchorMailbox";
  HeaderNames2["WWWAuthenticate"] = "WWW-Authenticate";
  HeaderNames2["AuthenticationInfo"] = "Authentication-Info";
  HeaderNames2["X_MS_REQUEST_ID"] = "x-ms-request-id";
})(HeaderNames || (HeaderNames = {}));
var PersistentCacheKeys;
(function(PersistentCacheKeys2) {
  PersistentCacheKeys2["ID_TOKEN"] = "idtoken";
  PersistentCacheKeys2["CLIENT_INFO"] = "client.info";
  PersistentCacheKeys2["ADAL_ID_TOKEN"] = "adal.idtoken";
  PersistentCacheKeys2["ERROR"] = "error";
  PersistentCacheKeys2["ERROR_DESC"] = "error.description";
  PersistentCacheKeys2["ACTIVE_ACCOUNT"] = "active-account";
  PersistentCacheKeys2["ACTIVE_ACCOUNT_FILTERS"] = "active-account-filters";
})(PersistentCacheKeys || (PersistentCacheKeys = {}));
var AADAuthorityConstants;
(function(AADAuthorityConstants2) {
  AADAuthorityConstants2["COMMON"] = "common";
  AADAuthorityConstants2["ORGANIZATIONS"] = "organizations";
  AADAuthorityConstants2["CONSUMERS"] = "consumers";
})(AADAuthorityConstants || (AADAuthorityConstants = {}));
var AADServerParamKeys;
(function(AADServerParamKeys2) {
  AADServerParamKeys2["CLIENT_ID"] = "client_id";
  AADServerParamKeys2["REDIRECT_URI"] = "redirect_uri";
  AADServerParamKeys2["RESPONSE_TYPE"] = "response_type";
  AADServerParamKeys2["RESPONSE_MODE"] = "response_mode";
  AADServerParamKeys2["GRANT_TYPE"] = "grant_type";
  AADServerParamKeys2["CLAIMS"] = "claims";
  AADServerParamKeys2["SCOPE"] = "scope";
  AADServerParamKeys2["ERROR"] = "error";
  AADServerParamKeys2["ERROR_DESCRIPTION"] = "error_description";
  AADServerParamKeys2["ACCESS_TOKEN"] = "access_token";
  AADServerParamKeys2["ID_TOKEN"] = "id_token";
  AADServerParamKeys2["REFRESH_TOKEN"] = "refresh_token";
  AADServerParamKeys2["EXPIRES_IN"] = "expires_in";
  AADServerParamKeys2["STATE"] = "state";
  AADServerParamKeys2["NONCE"] = "nonce";
  AADServerParamKeys2["PROMPT"] = "prompt";
  AADServerParamKeys2["SESSION_STATE"] = "session_state";
  AADServerParamKeys2["CLIENT_INFO"] = "client_info";
  AADServerParamKeys2["CODE"] = "code";
  AADServerParamKeys2["CODE_CHALLENGE"] = "code_challenge";
  AADServerParamKeys2["CODE_CHALLENGE_METHOD"] = "code_challenge_method";
  AADServerParamKeys2["CODE_VERIFIER"] = "code_verifier";
  AADServerParamKeys2["CLIENT_REQUEST_ID"] = "client-request-id";
  AADServerParamKeys2["X_CLIENT_SKU"] = "x-client-SKU";
  AADServerParamKeys2["X_CLIENT_VER"] = "x-client-VER";
  AADServerParamKeys2["X_CLIENT_OS"] = "x-client-OS";
  AADServerParamKeys2["X_CLIENT_CPU"] = "x-client-CPU";
  AADServerParamKeys2["X_CLIENT_CURR_TELEM"] = "x-client-current-telemetry";
  AADServerParamKeys2["X_CLIENT_LAST_TELEM"] = "x-client-last-telemetry";
  AADServerParamKeys2["X_MS_LIB_CAPABILITY"] = "x-ms-lib-capability";
  AADServerParamKeys2["X_APP_NAME"] = "x-app-name";
  AADServerParamKeys2["X_APP_VER"] = "x-app-ver";
  AADServerParamKeys2["POST_LOGOUT_URI"] = "post_logout_redirect_uri";
  AADServerParamKeys2["ID_TOKEN_HINT"] = "id_token_hint";
  AADServerParamKeys2["DEVICE_CODE"] = "device_code";
  AADServerParamKeys2["CLIENT_SECRET"] = "client_secret";
  AADServerParamKeys2["CLIENT_ASSERTION"] = "client_assertion";
  AADServerParamKeys2["CLIENT_ASSERTION_TYPE"] = "client_assertion_type";
  AADServerParamKeys2["TOKEN_TYPE"] = "token_type";
  AADServerParamKeys2["REQ_CNF"] = "req_cnf";
  AADServerParamKeys2["OBO_ASSERTION"] = "assertion";
  AADServerParamKeys2["REQUESTED_TOKEN_USE"] = "requested_token_use";
  AADServerParamKeys2["ON_BEHALF_OF"] = "on_behalf_of";
  AADServerParamKeys2["FOCI"] = "foci";
  AADServerParamKeys2["CCS_HEADER"] = "X-AnchorMailbox";
  AADServerParamKeys2["RETURN_SPA_CODE"] = "return_spa_code";
  AADServerParamKeys2["NATIVE_BROKER"] = "nativebroker";
  AADServerParamKeys2["LOGOUT_HINT"] = "logout_hint";
})(AADServerParamKeys || (AADServerParamKeys = {}));
var ClaimsRequestKeys;
(function(ClaimsRequestKeys2) {
  ClaimsRequestKeys2["ACCESS_TOKEN"] = "access_token";
  ClaimsRequestKeys2["XMS_CC"] = "xms_cc";
})(ClaimsRequestKeys || (ClaimsRequestKeys = {}));
var PromptValue = {
  LOGIN: "login",
  SELECT_ACCOUNT: "select_account",
  CONSENT: "consent",
  NONE: "none",
  CREATE: "create",
  NO_SESSION: "no_session"
};
var SSOTypes;
(function(SSOTypes2) {
  SSOTypes2["ACCOUNT"] = "account";
  SSOTypes2["SID"] = "sid";
  SSOTypes2["LOGIN_HINT"] = "login_hint";
  SSOTypes2["ID_TOKEN"] = "id_token";
  SSOTypes2["DOMAIN_HINT"] = "domain_hint";
  SSOTypes2["ORGANIZATIONS"] = "organizations";
  SSOTypes2["CONSUMERS"] = "consumers";
  SSOTypes2["ACCOUNT_ID"] = "accountIdentifier";
  SSOTypes2["HOMEACCOUNT_ID"] = "homeAccountIdentifier";
})(SSOTypes || (SSOTypes = {}));
var CodeChallengeMethodValues = {
  PLAIN: "plain",
  S256: "S256"
};
var ResponseMode;
(function(ResponseMode2) {
  ResponseMode2["QUERY"] = "query";
  ResponseMode2["FRAGMENT"] = "fragment";
  ResponseMode2["FORM_POST"] = "form_post";
})(ResponseMode || (ResponseMode = {}));
var GrantType;
(function(GrantType2) {
  GrantType2["IMPLICIT_GRANT"] = "implicit";
  GrantType2["AUTHORIZATION_CODE_GRANT"] = "authorization_code";
  GrantType2["CLIENT_CREDENTIALS_GRANT"] = "client_credentials";
  GrantType2["RESOURCE_OWNER_PASSWORD_GRANT"] = "password";
  GrantType2["REFRESH_TOKEN_GRANT"] = "refresh_token";
  GrantType2["DEVICE_CODE_GRANT"] = "device_code";
  GrantType2["JWT_BEARER"] = "urn:ietf:params:oauth:grant-type:jwt-bearer";
})(GrantType || (GrantType = {}));
var CacheAccountType;
(function(CacheAccountType2) {
  CacheAccountType2["MSSTS_ACCOUNT_TYPE"] = "MSSTS";
  CacheAccountType2["ADFS_ACCOUNT_TYPE"] = "ADFS";
  CacheAccountType2["MSAV1_ACCOUNT_TYPE"] = "MSA";
  CacheAccountType2["GENERIC_ACCOUNT_TYPE"] = "Generic";
})(CacheAccountType || (CacheAccountType = {}));
var Separators;
(function(Separators2) {
  Separators2["CACHE_KEY_SEPARATOR"] = "-";
  Separators2["CLIENT_INFO_SEPARATOR"] = ".";
})(Separators || (Separators = {}));
var CredentialType;
(function(CredentialType2) {
  CredentialType2["ID_TOKEN"] = "IdToken";
  CredentialType2["ACCESS_TOKEN"] = "AccessToken";
  CredentialType2["ACCESS_TOKEN_WITH_AUTH_SCHEME"] = "AccessToken_With_AuthScheme";
  CredentialType2["REFRESH_TOKEN"] = "RefreshToken";
})(CredentialType || (CredentialType = {}));
var CacheSchemaType;
(function(CacheSchemaType2) {
  CacheSchemaType2["ACCOUNT"] = "Account";
  CacheSchemaType2["CREDENTIAL"] = "Credential";
  CacheSchemaType2["ID_TOKEN"] = "IdToken";
  CacheSchemaType2["ACCESS_TOKEN"] = "AccessToken";
  CacheSchemaType2["REFRESH_TOKEN"] = "RefreshToken";
  CacheSchemaType2["APP_METADATA"] = "AppMetadata";
  CacheSchemaType2["TEMPORARY"] = "TempCache";
  CacheSchemaType2["TELEMETRY"] = "Telemetry";
  CacheSchemaType2["UNDEFINED"] = "Undefined";
  CacheSchemaType2["THROTTLING"] = "Throttling";
})(CacheSchemaType || (CacheSchemaType = {}));
var CacheType;
(function(CacheType2) {
  CacheType2[CacheType2["ADFS"] = 1001] = "ADFS";
  CacheType2[CacheType2["MSA"] = 1002] = "MSA";
  CacheType2[CacheType2["MSSTS"] = 1003] = "MSSTS";
  CacheType2[CacheType2["GENERIC"] = 1004] = "GENERIC";
  CacheType2[CacheType2["ACCESS_TOKEN"] = 2001] = "ACCESS_TOKEN";
  CacheType2[CacheType2["REFRESH_TOKEN"] = 2002] = "REFRESH_TOKEN";
  CacheType2[CacheType2["ID_TOKEN"] = 2003] = "ID_TOKEN";
  CacheType2[CacheType2["APP_METADATA"] = 3001] = "APP_METADATA";
  CacheType2[CacheType2["UNDEFINED"] = 9999] = "UNDEFINED";
})(CacheType || (CacheType = {}));
var APP_METADATA = "appmetadata";
var CLIENT_INFO = "client_info";
var THE_FAMILY_ID = "1";
var AUTHORITY_METADATA_CONSTANTS = {
  CACHE_KEY: "authority-metadata",
  REFRESH_TIME_SECONDS: 3600 * 24
};
var AuthorityMetadataSource;
(function(AuthorityMetadataSource2) {
  AuthorityMetadataSource2["CONFIG"] = "config";
  AuthorityMetadataSource2["CACHE"] = "cache";
  AuthorityMetadataSource2["NETWORK"] = "network";
  AuthorityMetadataSource2["HARDCODED_VALUES"] = "hardcoded_values";
})(AuthorityMetadataSource || (AuthorityMetadataSource = {}));
var SERVER_TELEM_CONSTANTS = {
  SCHEMA_VERSION: 5,
  MAX_CUR_HEADER_BYTES: 80,
  MAX_LAST_HEADER_BYTES: 330,
  MAX_CACHED_ERRORS: 50,
  CACHE_KEY: "server-telemetry",
  CATEGORY_SEPARATOR: "|",
  VALUE_SEPARATOR: ",",
  OVERFLOW_TRUE: "1",
  OVERFLOW_FALSE: "0",
  UNKNOWN_ERROR: "unknown_error"
};
var AuthenticationScheme;
(function(AuthenticationScheme2) {
  AuthenticationScheme2["BEARER"] = "Bearer";
  AuthenticationScheme2["POP"] = "pop";
  AuthenticationScheme2["SSH"] = "ssh-cert";
})(AuthenticationScheme || (AuthenticationScheme = {}));
var ThrottlingConstants = {
  DEFAULT_THROTTLE_TIME_SECONDS: 60,
  DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
  THROTTLING_PREFIX: "throttling",
  X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
};
var Errors = {
  INVALID_GRANT_ERROR: "invalid_grant",
  CLIENT_MISMATCH_ERROR: "client_mismatch"
};
var PasswordGrantConstants;
(function(PasswordGrantConstants2) {
  PasswordGrantConstants2["username"] = "username";
  PasswordGrantConstants2["password"] = "password";
})(PasswordGrantConstants || (PasswordGrantConstants = {}));
var ResponseCodes;
(function(ResponseCodes2) {
  ResponseCodes2[ResponseCodes2["httpSuccess"] = 200] = "httpSuccess";
  ResponseCodes2[ResponseCodes2["httpBadRequest"] = 400] = "httpBadRequest";
})(ResponseCodes || (ResponseCodes = {}));
var RegionDiscoverySources;
(function(RegionDiscoverySources2) {
  RegionDiscoverySources2["FAILED_AUTO_DETECTION"] = "1";
  RegionDiscoverySources2["INTERNAL_CACHE"] = "2";
  RegionDiscoverySources2["ENVIRONMENT_VARIABLE"] = "3";
  RegionDiscoverySources2["IMDS"] = "4";
})(RegionDiscoverySources || (RegionDiscoverySources = {}));
var RegionDiscoveryOutcomes;
(function(RegionDiscoveryOutcomes2) {
  RegionDiscoveryOutcomes2["CONFIGURED_MATCHES_DETECTED"] = "1";
  RegionDiscoveryOutcomes2["CONFIGURED_NO_AUTO_DETECTION"] = "2";
  RegionDiscoveryOutcomes2["CONFIGURED_NOT_DETECTED"] = "3";
  RegionDiscoveryOutcomes2["AUTO_DETECTION_REQUESTED_SUCCESSFUL"] = "4";
  RegionDiscoveryOutcomes2["AUTO_DETECTION_REQUESTED_FAILED"] = "5";
})(RegionDiscoveryOutcomes || (RegionDiscoveryOutcomes = {}));
var CacheOutcome;
(function(CacheOutcome2) {
  CacheOutcome2["NO_CACHE_HIT"] = "0";
  CacheOutcome2["FORCE_REFRESH"] = "1";
  CacheOutcome2["NO_CACHED_ACCESS_TOKEN"] = "2";
  CacheOutcome2["CACHED_ACCESS_TOKEN_EXPIRED"] = "3";
  CacheOutcome2["REFRESH_CACHED_ACCESS_TOKEN"] = "4";
})(CacheOutcome || (CacheOutcome = {}));
var JsonTypes;
(function(JsonTypes2) {
  JsonTypes2["Jwt"] = "JWT";
  JsonTypes2["Jwk"] = "JWK";
})(JsonTypes || (JsonTypes = {}));

// node_modules/@azure/msal-common/dist/error/AuthError.js
var AuthErrorMessage = {
  unexpectedError: {
    code: "unexpected_error",
    desc: "Unexpected error in authentication."
  },
  postRequestFailed: {
    code: "post_request_failed",
    desc: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
  }
};
var AuthError = function(_super) {
  __extends(AuthError2, _super);
  function AuthError2(errorCode, errorMessage, suberror) {
    var _this = this;
    var errorString = errorMessage ? errorCode + ": " + errorMessage : errorCode;
    _this = _super.call(this, errorString) || this;
    Object.setPrototypeOf(_this, AuthError2.prototype);
    _this.errorCode = errorCode || Constants.EMPTY_STRING;
    _this.errorMessage = errorMessage || Constants.EMPTY_STRING;
    _this.subError = suberror || Constants.EMPTY_STRING;
    _this.name = "AuthError";
    return _this;
  }
  AuthError2.prototype.setCorrelationId = function(correlationId) {
    this.correlationId = correlationId;
  };
  AuthError2.createUnexpectedError = function(errDesc) {
    return new AuthError2(AuthErrorMessage.unexpectedError.code, AuthErrorMessage.unexpectedError.desc + ": " + errDesc);
  };
  AuthError2.createPostRequestFailed = function(errDesc) {
    return new AuthError2(AuthErrorMessage.postRequestFailed.code, AuthErrorMessage.postRequestFailed.desc + ": " + errDesc);
  };
  return AuthError2;
}(Error);

// node_modules/@azure/msal-common/dist/crypto/ICrypto.js
var DEFAULT_CRYPTO_IMPLEMENTATION = {
  createNewGuid: function() {
    var notImplErr = "Crypto interface - createNewGuid() has not been implemented";
    throw AuthError.createUnexpectedError(notImplErr);
  },
  base64Decode: function() {
    var notImplErr = "Crypto interface - base64Decode() has not been implemented";
    throw AuthError.createUnexpectedError(notImplErr);
  },
  base64Encode: function() {
    var notImplErr = "Crypto interface - base64Encode() has not been implemented";
    throw AuthError.createUnexpectedError(notImplErr);
  },
  generatePkceCodes: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a) {
        notImplErr = "Crypto interface - generatePkceCodes() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  },
  getPublicKeyThumbprint: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a) {
        notImplErr = "Crypto interface - getPublicKeyThumbprint() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  },
  removeTokenBindingKey: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a) {
        notImplErr = "Crypto interface - removeTokenBindingKey() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  },
  clearKeystore: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a) {
        notImplErr = "Crypto interface - clearKeystore() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  },
  signJwt: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a) {
        notImplErr = "Crypto interface - signJwt() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  },
  hashString: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a) {
        notImplErr = "Crypto interface - hashString() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  }
};

// node_modules/@azure/msal-common/dist/error/ClientAuthError.js
var ClientAuthErrorMessage = {
  clientInfoDecodingError: {
    code: "client_info_decoding_error",
    desc: "The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause."
  },
  clientInfoEmptyError: {
    code: "client_info_empty_error",
    desc: "The client info was empty. Please review the trace to determine the root cause."
  },
  tokenParsingError: {
    code: "token_parsing_error",
    desc: "Token cannot be parsed. Please review stack trace to determine root cause."
  },
  nullOrEmptyToken: {
    code: "null_or_empty_token",
    desc: "The token is null or empty. Please review the trace to determine the root cause."
  },
  endpointResolutionError: {
    code: "endpoints_resolution_error",
    desc: "Error: could not resolve endpoints. Please check network and try again."
  },
  networkError: {
    code: "network_error",
    desc: "Network request failed. Please check network trace to determine root cause."
  },
  unableToGetOpenidConfigError: {
    code: "openid_config_error",
    desc: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints."
  },
  hashNotDeserialized: {
    code: "hash_not_deserialized",
    desc: "The hash parameters could not be deserialized. Please review the trace to determine the root cause."
  },
  blankGuidGenerated: {
    code: "blank_guid_generated",
    desc: "The guid generated was blank. Please review the trace to determine the root cause."
  },
  invalidStateError: {
    code: "invalid_state",
    desc: "State was not the expected format. Please check the logs to determine whether the request was sent using ProtocolUtils.setRequestState()."
  },
  stateMismatchError: {
    code: "state_mismatch",
    desc: "State mismatch error. Please check your network. Continued requests may cause cache overflow."
  },
  stateNotFoundError: {
    code: "state_not_found",
    desc: "State not found"
  },
  nonceMismatchError: {
    code: "nonce_mismatch",
    desc: "Nonce mismatch error. This may be caused by a race condition in concurrent requests."
  },
  nonceNotFoundError: {
    code: "nonce_not_found",
    desc: "nonce not found"
  },
  authTimeNotFoundError: {
    code: "auth_time_not_found",
    desc: "Max Age was requested and the ID token is missing the auth_time variable. auth_time is an optional claim and is not enabled by default - it must be enabled. See https://aka.ms/msaljs/optional-claims for more information."
  },
  maxAgeTranspiredError: {
    code: "max_age_transpired",
    desc: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication."
  },
  noTokensFoundError: {
    code: "no_tokens_found",
    desc: "No tokens were found for the given scopes, and no authorization code was passed to acquireToken. You must retrieve an authorization code before making a call to acquireToken()."
  },
  multipleMatchingTokens: {
    code: "multiple_matching_tokens",
    desc: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account."
  },
  multipleMatchingAccounts: {
    code: "multiple_matching_accounts",
    desc: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account"
  },
  multipleMatchingAppMetadata: {
    code: "multiple_matching_appMetadata",
    desc: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata"
  },
  tokenRequestCannotBeMade: {
    code: "request_cannot_be_made",
    desc: "Token request cannot be made without authorization code or refresh token."
  },
  appendEmptyScopeError: {
    code: "cannot_append_empty_scope",
    desc: "Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info."
  },
  removeEmptyScopeError: {
    code: "cannot_remove_empty_scope",
    desc: "Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info."
  },
  appendScopeSetError: {
    code: "cannot_append_scopeset",
    desc: "Cannot append ScopeSet due to error."
  },
  emptyInputScopeSetError: {
    code: "empty_input_scopeset",
    desc: "Empty input ScopeSet cannot be processed."
  },
  DeviceCodePollingCancelled: {
    code: "device_code_polling_cancelled",
    desc: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true."
  },
  DeviceCodeExpired: {
    code: "device_code_expired",
    desc: "Device code is expired."
  },
  DeviceCodeUnknownError: {
    code: "device_code_unknown_error",
    desc: "Device code stopped polling for unknown reasons."
  },
  NoAccountInSilentRequest: {
    code: "no_account_in_silent_request",
    desc: "Please pass an account object, silent flow is not supported without account information"
  },
  invalidCacheRecord: {
    code: "invalid_cache_record",
    desc: "Cache record object was null or undefined."
  },
  invalidCacheEnvironment: {
    code: "invalid_cache_environment",
    desc: "Invalid environment when attempting to create cache entry"
  },
  noAccountFound: {
    code: "no_account_found",
    desc: "No account found in cache for given key."
  },
  CachePluginError: {
    code: "no cache plugin set on CacheManager",
    desc: "ICachePlugin needs to be set before using readFromStorage or writeFromStorage"
  },
  noCryptoObj: {
    code: "no_crypto_object",
    desc: "No crypto object detected. This is required for the following operation: "
  },
  invalidCacheType: {
    code: "invalid_cache_type",
    desc: "Invalid cache type"
  },
  unexpectedAccountType: {
    code: "unexpected_account_type",
    desc: "Unexpected account type."
  },
  unexpectedCredentialType: {
    code: "unexpected_credential_type",
    desc: "Unexpected credential type."
  },
  invalidAssertion: {
    code: "invalid_assertion",
    desc: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515"
  },
  invalidClientCredential: {
    code: "invalid_client_credential",
    desc: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential"
  },
  tokenRefreshRequired: {
    code: "token_refresh_required",
    desc: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired."
  },
  userTimeoutReached: {
    code: "user_timeout_reached",
    desc: "User defined timeout for device code polling reached"
  },
  tokenClaimsRequired: {
    code: "token_claims_cnf_required_for_signedjwt",
    desc: "Cannot generate a POP jwt if the token_claims are not populated"
  },
  noAuthorizationCodeFromServer: {
    code: "authorization_code_missing_from_server_response",
    desc: "Server response does not contain an authorization code to proceed"
  },
  noAzureRegionDetected: {
    code: "no_azure_region_detected",
    desc: "No azure region was detected and no fallback was made available"
  },
  accessTokenEntityNullError: {
    code: "access_token_entity_null",
    desc: "Access token entity is null, please check logs and cache to ensure a valid access token is present."
  },
  bindingKeyNotRemovedError: {
    code: "binding_key_not_removed",
    desc: "Could not remove the credential's binding key from storage."
  },
  logoutNotSupported: {
    code: "end_session_endpoint_not_supported",
    desc: "Provided authority does not support logout."
  },
  keyIdMissing: {
    code: "key_id_missing",
    desc: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key."
  }
};
var ClientAuthError = function(_super) {
  __extends(ClientAuthError2, _super);
  function ClientAuthError2(errorCode, errorMessage) {
    var _this = _super.call(this, errorCode, errorMessage) || this;
    _this.name = "ClientAuthError";
    Object.setPrototypeOf(_this, ClientAuthError2.prototype);
    return _this;
  }
  ClientAuthError2.createClientInfoDecodingError = function(caughtError) {
    return new ClientAuthError2(ClientAuthErrorMessage.clientInfoDecodingError.code, ClientAuthErrorMessage.clientInfoDecodingError.desc + " Failed with error: " + caughtError);
  };
  ClientAuthError2.createClientInfoEmptyError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.clientInfoEmptyError.code, "" + ClientAuthErrorMessage.clientInfoEmptyError.desc);
  };
  ClientAuthError2.createTokenParsingError = function(caughtExtractionError) {
    return new ClientAuthError2(ClientAuthErrorMessage.tokenParsingError.code, ClientAuthErrorMessage.tokenParsingError.desc + " Failed with error: " + caughtExtractionError);
  };
  ClientAuthError2.createTokenNullOrEmptyError = function(invalidRawTokenString) {
    return new ClientAuthError2(ClientAuthErrorMessage.nullOrEmptyToken.code, ClientAuthErrorMessage.nullOrEmptyToken.desc + " Raw Token Value: " + invalidRawTokenString);
  };
  ClientAuthError2.createEndpointDiscoveryIncompleteError = function(errDetail) {
    return new ClientAuthError2(ClientAuthErrorMessage.endpointResolutionError.code, ClientAuthErrorMessage.endpointResolutionError.desc + " Detail: " + errDetail);
  };
  ClientAuthError2.createNetworkError = function(endpoint, errDetail) {
    return new ClientAuthError2(ClientAuthErrorMessage.networkError.code, ClientAuthErrorMessage.networkError.desc + " | Fetch client threw: " + errDetail + " | Attempted to reach: " + endpoint.split("?")[0]);
  };
  ClientAuthError2.createUnableToGetOpenidConfigError = function(errDetail) {
    return new ClientAuthError2(ClientAuthErrorMessage.unableToGetOpenidConfigError.code, ClientAuthErrorMessage.unableToGetOpenidConfigError.desc + " Attempted to retrieve endpoints from: " + errDetail);
  };
  ClientAuthError2.createHashNotDeserializedError = function(hashParamObj) {
    return new ClientAuthError2(ClientAuthErrorMessage.hashNotDeserialized.code, ClientAuthErrorMessage.hashNotDeserialized.desc + " Given Object: " + hashParamObj);
  };
  ClientAuthError2.createInvalidStateError = function(invalidState, errorString) {
    return new ClientAuthError2(ClientAuthErrorMessage.invalidStateError.code, ClientAuthErrorMessage.invalidStateError.desc + " Invalid State: " + invalidState + ", Root Err: " + errorString);
  };
  ClientAuthError2.createStateMismatchError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.stateMismatchError.code, ClientAuthErrorMessage.stateMismatchError.desc);
  };
  ClientAuthError2.createStateNotFoundError = function(missingState) {
    return new ClientAuthError2(ClientAuthErrorMessage.stateNotFoundError.code, ClientAuthErrorMessage.stateNotFoundError.desc + ":  " + missingState);
  };
  ClientAuthError2.createNonceMismatchError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.nonceMismatchError.code, ClientAuthErrorMessage.nonceMismatchError.desc);
  };
  ClientAuthError2.createAuthTimeNotFoundError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.authTimeNotFoundError.code, ClientAuthErrorMessage.authTimeNotFoundError.desc);
  };
  ClientAuthError2.createMaxAgeTranspiredError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.maxAgeTranspiredError.code, ClientAuthErrorMessage.maxAgeTranspiredError.desc);
  };
  ClientAuthError2.createNonceNotFoundError = function(missingNonce) {
    return new ClientAuthError2(ClientAuthErrorMessage.nonceNotFoundError.code, ClientAuthErrorMessage.nonceNotFoundError.desc + ":  " + missingNonce);
  };
  ClientAuthError2.createMultipleMatchingTokensInCacheError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.multipleMatchingTokens.code, ClientAuthErrorMessage.multipleMatchingTokens.desc + ".");
  };
  ClientAuthError2.createMultipleMatchingAccountsInCacheError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.multipleMatchingAccounts.code, ClientAuthErrorMessage.multipleMatchingAccounts.desc);
  };
  ClientAuthError2.createMultipleMatchingAppMetadataInCacheError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.multipleMatchingAppMetadata.code, ClientAuthErrorMessage.multipleMatchingAppMetadata.desc);
  };
  ClientAuthError2.createTokenRequestCannotBeMadeError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.tokenRequestCannotBeMade.code, ClientAuthErrorMessage.tokenRequestCannotBeMade.desc);
  };
  ClientAuthError2.createAppendEmptyScopeToSetError = function(givenScope) {
    return new ClientAuthError2(ClientAuthErrorMessage.appendEmptyScopeError.code, ClientAuthErrorMessage.appendEmptyScopeError.desc + " Given Scope: " + givenScope);
  };
  ClientAuthError2.createRemoveEmptyScopeFromSetError = function(givenScope) {
    return new ClientAuthError2(ClientAuthErrorMessage.removeEmptyScopeError.code, ClientAuthErrorMessage.removeEmptyScopeError.desc + " Given Scope: " + givenScope);
  };
  ClientAuthError2.createAppendScopeSetError = function(appendError) {
    return new ClientAuthError2(ClientAuthErrorMessage.appendScopeSetError.code, ClientAuthErrorMessage.appendScopeSetError.desc + " Detail Error: " + appendError);
  };
  ClientAuthError2.createEmptyInputScopeSetError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.emptyInputScopeSetError.code, "" + ClientAuthErrorMessage.emptyInputScopeSetError.desc);
  };
  ClientAuthError2.createDeviceCodeCancelledError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.DeviceCodePollingCancelled.code, "" + ClientAuthErrorMessage.DeviceCodePollingCancelled.desc);
  };
  ClientAuthError2.createDeviceCodeExpiredError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.DeviceCodeExpired.code, "" + ClientAuthErrorMessage.DeviceCodeExpired.desc);
  };
  ClientAuthError2.createDeviceCodeUnknownError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.DeviceCodeUnknownError.code, "" + ClientAuthErrorMessage.DeviceCodeUnknownError.desc);
  };
  ClientAuthError2.createNoAccountInSilentRequestError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.NoAccountInSilentRequest.code, "" + ClientAuthErrorMessage.NoAccountInSilentRequest.desc);
  };
  ClientAuthError2.createNullOrUndefinedCacheRecord = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.invalidCacheRecord.code, ClientAuthErrorMessage.invalidCacheRecord.desc);
  };
  ClientAuthError2.createInvalidCacheEnvironmentError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.invalidCacheEnvironment.code, ClientAuthErrorMessage.invalidCacheEnvironment.desc);
  };
  ClientAuthError2.createNoAccountFoundError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.noAccountFound.code, ClientAuthErrorMessage.noAccountFound.desc);
  };
  ClientAuthError2.createCachePluginError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.CachePluginError.code, "" + ClientAuthErrorMessage.CachePluginError.desc);
  };
  ClientAuthError2.createNoCryptoObjectError = function(operationName) {
    return new ClientAuthError2(ClientAuthErrorMessage.noCryptoObj.code, "" + ClientAuthErrorMessage.noCryptoObj.desc + operationName);
  };
  ClientAuthError2.createInvalidCacheTypeError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.invalidCacheType.code, "" + ClientAuthErrorMessage.invalidCacheType.desc);
  };
  ClientAuthError2.createUnexpectedAccountTypeError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.unexpectedAccountType.code, "" + ClientAuthErrorMessage.unexpectedAccountType.desc);
  };
  ClientAuthError2.createUnexpectedCredentialTypeError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.unexpectedCredentialType.code, "" + ClientAuthErrorMessage.unexpectedCredentialType.desc);
  };
  ClientAuthError2.createInvalidAssertionError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.invalidAssertion.code, "" + ClientAuthErrorMessage.invalidAssertion.desc);
  };
  ClientAuthError2.createInvalidCredentialError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.invalidClientCredential.code, "" + ClientAuthErrorMessage.invalidClientCredential.desc);
  };
  ClientAuthError2.createRefreshRequiredError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.tokenRefreshRequired.code, ClientAuthErrorMessage.tokenRefreshRequired.desc);
  };
  ClientAuthError2.createUserTimeoutReachedError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.userTimeoutReached.code, ClientAuthErrorMessage.userTimeoutReached.desc);
  };
  ClientAuthError2.createTokenClaimsRequiredError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.tokenClaimsRequired.code, ClientAuthErrorMessage.tokenClaimsRequired.desc);
  };
  ClientAuthError2.createNoAuthCodeInServerResponseError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.noAuthorizationCodeFromServer.code, ClientAuthErrorMessage.noAuthorizationCodeFromServer.desc);
  };
  ClientAuthError2.createBindingKeyNotRemovedError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.bindingKeyNotRemovedError.code, ClientAuthErrorMessage.bindingKeyNotRemovedError.desc);
  };
  ClientAuthError2.createLogoutNotSupportedError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.logoutNotSupported.code, ClientAuthErrorMessage.logoutNotSupported.desc);
  };
  ClientAuthError2.createKeyIdMissingError = function() {
    return new ClientAuthError2(ClientAuthErrorMessage.keyIdMissing.code, ClientAuthErrorMessage.keyIdMissing.desc);
  };
  return ClientAuthError2;
}(AuthError);

// node_modules/@azure/msal-common/dist/utils/StringUtils.js
var StringUtils = function() {
  function StringUtils2() {
  }
  StringUtils2.decodeAuthToken = function(authToken) {
    if (StringUtils2.isEmpty(authToken)) {
      throw ClientAuthError.createTokenNullOrEmptyError(authToken);
    }
    var tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
    var matches = tokenPartsRegex.exec(authToken);
    if (!matches || matches.length < 4) {
      throw ClientAuthError.createTokenParsingError("Given token is malformed: " + JSON.stringify(authToken));
    }
    var crackedToken = {
      header: matches[1],
      JWSPayload: matches[2],
      JWSSig: matches[3]
    };
    return crackedToken;
  };
  StringUtils2.isEmpty = function(str) {
    return typeof str === "undefined" || !str || str.length === 0;
  };
  StringUtils2.isEmptyObj = function(strObj) {
    if (strObj && !StringUtils2.isEmpty(strObj)) {
      try {
        var obj = JSON.parse(strObj);
        return Object.keys(obj).length === 0;
      } catch (e) {
      }
    }
    return true;
  };
  StringUtils2.startsWith = function(str, search) {
    return str.indexOf(search) === 0;
  };
  StringUtils2.endsWith = function(str, search) {
    return str.length >= search.length && str.lastIndexOf(search) === str.length - search.length;
  };
  StringUtils2.queryStringToObject = function(query) {
    var obj = {};
    var params = query.split("&");
    var decode = function(s) {
      return decodeURIComponent(s.replace(/\+/g, " "));
    };
    params.forEach(function(pair) {
      if (pair.trim()) {
        var _a = pair.split(/=(.+)/g, 2), key = _a[0], value = _a[1];
        if (key && value) {
          obj[decode(key)] = decode(value);
        }
      }
    });
    return obj;
  };
  StringUtils2.trimArrayEntries = function(arr) {
    return arr.map(function(entry) {
      return entry.trim();
    });
  };
  StringUtils2.removeEmptyStringsFromArray = function(arr) {
    return arr.filter(function(entry) {
      return !StringUtils2.isEmpty(entry);
    });
  };
  StringUtils2.jsonParseHelper = function(str) {
    try {
      return JSON.parse(str);
    } catch (e) {
      return null;
    }
  };
  StringUtils2.matchPattern = function(pattern, input) {
    var regex = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?"));
    return regex.test(input);
  };
  return StringUtils2;
}();

// node_modules/@azure/msal-common/dist/logger/Logger.js
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Error"] = 0] = "Error";
  LogLevel2[LogLevel2["Warning"] = 1] = "Warning";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Verbose"] = 3] = "Verbose";
  LogLevel2[LogLevel2["Trace"] = 4] = "Trace";
})(LogLevel || (LogLevel = {}));
var Logger = function() {
  function Logger3(loggerOptions, packageName, packageVersion) {
    this.level = LogLevel.Info;
    var defaultLoggerCallback = function() {
      return;
    };
    this.localCallback = loggerOptions.loggerCallback || defaultLoggerCallback;
    this.piiLoggingEnabled = loggerOptions.piiLoggingEnabled || false;
    this.level = typeof loggerOptions.logLevel === "number" ? loggerOptions.logLevel : LogLevel.Info;
    this.correlationId = loggerOptions.correlationId || Constants.EMPTY_STRING;
    this.packageName = packageName || Constants.EMPTY_STRING;
    this.packageVersion = packageVersion || Constants.EMPTY_STRING;
  }
  Logger3.prototype.clone = function(packageName, packageVersion, correlationId) {
    return new Logger3({ loggerCallback: this.localCallback, piiLoggingEnabled: this.piiLoggingEnabled, logLevel: this.level, correlationId: correlationId || this.correlationId }, packageName, packageVersion);
  };
  Logger3.prototype.logMessage = function(logMessage, options) {
    if (options.logLevel > this.level || !this.piiLoggingEnabled && options.containsPii) {
      return;
    }
    var timestamp = new Date().toUTCString();
    var logHeader;
    if (!StringUtils.isEmpty(options.correlationId)) {
      logHeader = "[" + timestamp + "] : [" + options.correlationId + "]";
    } else if (!StringUtils.isEmpty(this.correlationId)) {
      logHeader = "[" + timestamp + "] : [" + this.correlationId + "]";
    } else {
      logHeader = "[" + timestamp + "]";
    }
    var log2 = logHeader + " : " + this.packageName + "@" + this.packageVersion + " : " + LogLevel[options.logLevel] + " - " + logMessage;
    this.executeCallback(options.logLevel, log2, options.containsPii || false);
  };
  Logger3.prototype.executeCallback = function(level, message, containsPii) {
    if (this.localCallback) {
      this.localCallback(level, message, containsPii);
    }
  };
  Logger3.prototype.error = function(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Error,
      containsPii: false,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  };
  Logger3.prototype.errorPii = function(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Error,
      containsPii: true,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  };
  Logger3.prototype.warning = function(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Warning,
      containsPii: false,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  };
  Logger3.prototype.warningPii = function(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Warning,
      containsPii: true,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  };
  Logger3.prototype.info = function(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Info,
      containsPii: false,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  };
  Logger3.prototype.infoPii = function(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Info,
      containsPii: true,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  };
  Logger3.prototype.verbose = function(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Verbose,
      containsPii: false,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  };
  Logger3.prototype.verbosePii = function(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Verbose,
      containsPii: true,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  };
  Logger3.prototype.trace = function(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Trace,
      containsPii: false,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  };
  Logger3.prototype.tracePii = function(message, correlationId) {
    this.logMessage(message, {
      logLevel: LogLevel.Trace,
      containsPii: true,
      correlationId: correlationId || Constants.EMPTY_STRING
    });
  };
  Logger3.prototype.isPiiLoggingEnabled = function() {
    return this.piiLoggingEnabled || false;
  };
  return Logger3;
}();

// node_modules/@azure/msal-common/dist/packageMetadata.js
var name = "@azure/msal-common";
var version = "7.6.0";

// node_modules/@azure/msal-common/dist/authority/AuthorityOptions.js
var AzureCloudInstance;
(function(AzureCloudInstance2) {
  AzureCloudInstance2[AzureCloudInstance2["None"] = 0] = "None";
  AzureCloudInstance2["AzurePublic"] = "https://login.microsoftonline.com";
  AzureCloudInstance2["AzurePpe"] = "https://login.windows-ppe.net";
  AzureCloudInstance2["AzureChina"] = "https://login.chinacloudapi.cn";
  AzureCloudInstance2["AzureGermany"] = "https://login.microsoftonline.de";
  AzureCloudInstance2["AzureUsGovernment"] = "https://login.microsoftonline.us";
})(AzureCloudInstance || (AzureCloudInstance = {}));

// node_modules/@azure/msal-common/dist/cache/entities/CredentialEntity.js
var CredentialEntity = function() {
  function CredentialEntity2() {
  }
  CredentialEntity2.prototype.generateAccountId = function() {
    return CredentialEntity2.generateAccountIdForCacheKey(this.homeAccountId, this.environment);
  };
  CredentialEntity2.prototype.generateCredentialId = function() {
    return CredentialEntity2.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId);
  };
  CredentialEntity2.prototype.generateTarget = function() {
    return CredentialEntity2.generateTargetForCacheKey(this.target);
  };
  CredentialEntity2.prototype.generateCredentialKey = function() {
    return CredentialEntity2.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId, this.tokenType, this.requestedClaimsHash);
  };
  CredentialEntity2.prototype.generateType = function() {
    switch (this.credentialType) {
      case CredentialType.ID_TOKEN:
        return CacheType.ID_TOKEN;
      case CredentialType.ACCESS_TOKEN:
      case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
        return CacheType.ACCESS_TOKEN;
      case CredentialType.REFRESH_TOKEN:
        return CacheType.REFRESH_TOKEN;
      default: {
        throw ClientAuthError.createUnexpectedCredentialTypeError();
      }
    }
  };
  CredentialEntity2.getCredentialType = function(key) {
    if (key.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) !== -1) {
      if (key.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) !== -1) {
        return CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
      }
      return CredentialType.ACCESS_TOKEN;
    } else if (key.indexOf(CredentialType.ID_TOKEN.toLowerCase()) !== -1) {
      return CredentialType.ID_TOKEN;
    } else if (key.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) !== -1) {
      return CredentialType.REFRESH_TOKEN;
    }
    return Constants.NOT_DEFINED;
  };
  CredentialEntity2.generateCredentialCacheKey = function(homeAccountId, environment, credentialType, clientId, realm, target, familyId, tokenType, requestedClaimsHash) {
    var credentialKey = [
      this.generateAccountIdForCacheKey(homeAccountId, environment),
      this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId),
      this.generateTargetForCacheKey(target),
      this.generateClaimsHashForCacheKey(requestedClaimsHash),
      this.generateSchemeForCacheKey(tokenType)
    ];
    return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
  };
  CredentialEntity2.generateAccountIdForCacheKey = function(homeAccountId, environment) {
    var accountId = [homeAccountId, environment];
    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
  };
  CredentialEntity2.generateCredentialIdForCacheKey = function(credentialType, clientId, realm, familyId) {
    var clientOrFamilyId = credentialType === CredentialType.REFRESH_TOKEN ? familyId || clientId : clientId;
    var credentialId = [
      credentialType,
      clientOrFamilyId,
      realm || Constants.EMPTY_STRING
    ];
    return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
  };
  CredentialEntity2.generateTargetForCacheKey = function(scopes) {
    return (scopes || Constants.EMPTY_STRING).toLowerCase();
  };
  CredentialEntity2.generateClaimsHashForCacheKey = function(requestedClaimsHash) {
    return (requestedClaimsHash || Constants.EMPTY_STRING).toLowerCase();
  };
  CredentialEntity2.generateSchemeForCacheKey = function(tokenType) {
    return tokenType && tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? tokenType.toLowerCase() : Constants.EMPTY_STRING;
  };
  return CredentialEntity2;
}();

// node_modules/@azure/msal-common/dist/error/ClientConfigurationError.js
var ClientConfigurationErrorMessage = {
  redirectUriNotSet: {
    code: "redirect_uri_empty",
    desc: "A redirect URI is required for all calls, and none has been set."
  },
  postLogoutUriNotSet: {
    code: "post_logout_uri_empty",
    desc: "A post logout redirect has not been set."
  },
  claimsRequestParsingError: {
    code: "claims_request_parsing_error",
    desc: "Could not parse the given claims request object."
  },
  authorityUriInsecure: {
    code: "authority_uri_insecure",
    desc: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options"
  },
  urlParseError: {
    code: "url_parse_error",
    desc: "URL could not be parsed into appropriate segments."
  },
  urlEmptyError: {
    code: "empty_url_error",
    desc: "URL was empty or null."
  },
  emptyScopesError: {
    code: "empty_input_scopes_error",
    desc: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token."
  },
  nonArrayScopesError: {
    code: "nonarray_input_scopes_error",
    desc: "Scopes cannot be passed as non-array."
  },
  clientIdSingleScopeError: {
    code: "clientid_input_scopes_error",
    desc: "Client ID can only be provided as a single scope."
  },
  invalidPrompt: {
    code: "invalid_prompt_value",
    desc: "Supported prompt values are 'login', 'select_account', 'consent', 'create', 'none' and 'no_session'.  Please see here for valid configuration options: https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal_common.html#commonauthorizationurlrequest"
  },
  invalidClaimsRequest: {
    code: "invalid_claims",
    desc: "Given claims parameter must be a stringified JSON object."
  },
  tokenRequestEmptyError: {
    code: "token_request_empty",
    desc: "Token request was empty and not found in cache."
  },
  logoutRequestEmptyError: {
    code: "logout_request_empty",
    desc: "The logout request was null or undefined."
  },
  invalidCodeChallengeMethod: {
    code: "invalid_code_challenge_method",
    desc: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".'
  },
  invalidCodeChallengeParams: {
    code: "pkce_params_missing",
    desc: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request"
  },
  invalidCloudDiscoveryMetadata: {
    code: "invalid_cloud_discovery_metadata",
    desc: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields"
  },
  invalidAuthorityMetadata: {
    code: "invalid_authority_metadata",
    desc: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields."
  },
  untrustedAuthority: {
    code: "untrusted_authority",
    desc: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter."
  },
  invalidAzureCloudInstance: {
    code: "invalid_azure_cloud_instance",
    desc: "Invalid AzureCloudInstance provided. Please refer MSAL JS docs: aks.ms/msaljs/azure_cloud_instance for valid values"
  },
  missingSshJwk: {
    code: "missing_ssh_jwk",
    desc: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme."
  },
  missingSshKid: {
    code: "missing_ssh_kid",
    desc: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme."
  },
  missingNonceAuthenticationHeader: {
    code: "missing_nonce_authentication_header",
    desc: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce."
  },
  invalidAuthenticationHeader: {
    code: "invalid_authentication_header",
    desc: "Invalid authentication header provided"
  }
};
var ClientConfigurationError = function(_super) {
  __extends(ClientConfigurationError2, _super);
  function ClientConfigurationError2(errorCode, errorMessage) {
    var _this = _super.call(this, errorCode, errorMessage) || this;
    _this.name = "ClientConfigurationError";
    Object.setPrototypeOf(_this, ClientConfigurationError2.prototype);
    return _this;
  }
  ClientConfigurationError2.createRedirectUriEmptyError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.redirectUriNotSet.code, ClientConfigurationErrorMessage.redirectUriNotSet.desc);
  };
  ClientConfigurationError2.createPostLogoutRedirectUriEmptyError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.postLogoutUriNotSet.code, ClientConfigurationErrorMessage.postLogoutUriNotSet.desc);
  };
  ClientConfigurationError2.createClaimsRequestParsingError = function(claimsRequestParseError) {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.claimsRequestParsingError.code, ClientConfigurationErrorMessage.claimsRequestParsingError.desc + " Given value: " + claimsRequestParseError);
  };
  ClientConfigurationError2.createInsecureAuthorityUriError = function(urlString) {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.authorityUriInsecure.code, ClientConfigurationErrorMessage.authorityUriInsecure.desc + " Given URI: " + urlString);
  };
  ClientConfigurationError2.createUrlParseError = function(urlParseError) {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.urlParseError.code, ClientConfigurationErrorMessage.urlParseError.desc + " Given Error: " + urlParseError);
  };
  ClientConfigurationError2.createUrlEmptyError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.urlEmptyError.code, ClientConfigurationErrorMessage.urlEmptyError.desc);
  };
  ClientConfigurationError2.createEmptyScopesArrayError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.emptyScopesError.code, "" + ClientConfigurationErrorMessage.emptyScopesError.desc);
  };
  ClientConfigurationError2.createClientIdSingleScopeError = function(inputScopes) {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.clientIdSingleScopeError.code, ClientConfigurationErrorMessage.clientIdSingleScopeError.desc + " Given Scopes: " + inputScopes);
  };
  ClientConfigurationError2.createInvalidPromptError = function(promptValue) {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidPrompt.code, ClientConfigurationErrorMessage.invalidPrompt.desc + " Given value: " + promptValue);
  };
  ClientConfigurationError2.createInvalidClaimsRequestError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidClaimsRequest.code, ClientConfigurationErrorMessage.invalidClaimsRequest.desc);
  };
  ClientConfigurationError2.createEmptyLogoutRequestError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.logoutRequestEmptyError.code, ClientConfigurationErrorMessage.logoutRequestEmptyError.desc);
  };
  ClientConfigurationError2.createEmptyTokenRequestError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.tokenRequestEmptyError.code, ClientConfigurationErrorMessage.tokenRequestEmptyError.desc);
  };
  ClientConfigurationError2.createInvalidCodeChallengeMethodError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCodeChallengeMethod.code, ClientConfigurationErrorMessage.invalidCodeChallengeMethod.desc);
  };
  ClientConfigurationError2.createInvalidCodeChallengeParamsError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCodeChallengeParams.code, ClientConfigurationErrorMessage.invalidCodeChallengeParams.desc);
  };
  ClientConfigurationError2.createInvalidCloudDiscoveryMetadataError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.code, ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.desc);
  };
  ClientConfigurationError2.createInvalidAuthorityMetadataError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAuthorityMetadata.code, ClientConfigurationErrorMessage.invalidAuthorityMetadata.desc);
  };
  ClientConfigurationError2.createUntrustedAuthorityError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.untrustedAuthority.code, ClientConfigurationErrorMessage.untrustedAuthority.desc);
  };
  ClientConfigurationError2.createInvalidAzureCloudInstanceError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAzureCloudInstance.code, ClientConfigurationErrorMessage.invalidAzureCloudInstance.desc);
  };
  ClientConfigurationError2.createMissingSshJwkError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.missingSshJwk.code, ClientConfigurationErrorMessage.missingSshJwk.desc);
  };
  ClientConfigurationError2.createMissingSshKidError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.missingSshKid.code, ClientConfigurationErrorMessage.missingSshKid.desc);
  };
  ClientConfigurationError2.createMissingNonceAuthenticationHeadersError = function() {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.code, ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.desc);
  };
  ClientConfigurationError2.createInvalidAuthenticationHeaderError = function(invalidHeaderName, details) {
    return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAuthenticationHeader.code, ClientConfigurationErrorMessage.invalidAuthenticationHeader.desc + ". Invalid header: " + invalidHeaderName + ". Details: " + details);
  };
  return ClientConfigurationError2;
}(ClientAuthError);

// node_modules/@azure/msal-common/dist/request/ScopeSet.js
var ScopeSet = function() {
  function ScopeSet2(inputScopes) {
    var _this = this;
    var scopeArr = inputScopes ? StringUtils.trimArrayEntries(__spreadArrays(inputScopes)) : [];
    var filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
    this.validateInputScopes(filteredInput);
    this.scopes = /* @__PURE__ */ new Set();
    filteredInput.forEach(function(scope) {
      return _this.scopes.add(scope);
    });
  }
  ScopeSet2.fromString = function(inputScopeString) {
    var scopeString = inputScopeString || Constants.EMPTY_STRING;
    var inputScopes = scopeString.split(" ");
    return new ScopeSet2(inputScopes);
  };
  ScopeSet2.prototype.validateInputScopes = function(inputScopes) {
    if (!inputScopes || inputScopes.length < 1) {
      throw ClientConfigurationError.createEmptyScopesArrayError();
    }
  };
  ScopeSet2.prototype.containsScope = function(scope) {
    var lowerCaseScopes = this.printScopesLowerCase().split(" ");
    var lowerCaseScopesSet = new ScopeSet2(lowerCaseScopes);
    return !StringUtils.isEmpty(scope) ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
  };
  ScopeSet2.prototype.containsScopeSet = function(scopeSet) {
    var _this = this;
    if (!scopeSet || scopeSet.scopes.size <= 0) {
      return false;
    }
    return this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every(function(scope) {
      return _this.containsScope(scope);
    });
  };
  ScopeSet2.prototype.containsOnlyOIDCScopes = function() {
    var _this = this;
    var defaultScopeCount = 0;
    OIDC_SCOPES.forEach(function(defaultScope) {
      if (_this.containsScope(defaultScope)) {
        defaultScopeCount += 1;
      }
    });
    return this.scopes.size === defaultScopeCount;
  };
  ScopeSet2.prototype.appendScope = function(newScope) {
    if (!StringUtils.isEmpty(newScope)) {
      this.scopes.add(newScope.trim());
    }
  };
  ScopeSet2.prototype.appendScopes = function(newScopes) {
    var _this = this;
    try {
      newScopes.forEach(function(newScope) {
        return _this.appendScope(newScope);
      });
    } catch (e) {
      throw ClientAuthError.createAppendScopeSetError(e);
    }
  };
  ScopeSet2.prototype.removeScope = function(scope) {
    if (StringUtils.isEmpty(scope)) {
      throw ClientAuthError.createRemoveEmptyScopeFromSetError(scope);
    }
    this.scopes.delete(scope.trim());
  };
  ScopeSet2.prototype.removeOIDCScopes = function() {
    var _this = this;
    OIDC_SCOPES.forEach(function(defaultScope) {
      _this.scopes.delete(defaultScope);
    });
  };
  ScopeSet2.prototype.unionScopeSets = function(otherScopes) {
    if (!otherScopes) {
      throw ClientAuthError.createEmptyInputScopeSetError();
    }
    var unionScopes = /* @__PURE__ */ new Set();
    otherScopes.scopes.forEach(function(scope) {
      return unionScopes.add(scope.toLowerCase());
    });
    this.scopes.forEach(function(scope) {
      return unionScopes.add(scope.toLowerCase());
    });
    return unionScopes;
  };
  ScopeSet2.prototype.intersectingScopeSets = function(otherScopes) {
    if (!otherScopes) {
      throw ClientAuthError.createEmptyInputScopeSetError();
    }
    if (!otherScopes.containsOnlyOIDCScopes()) {
      otherScopes.removeOIDCScopes();
    }
    var unionScopes = this.unionScopeSets(otherScopes);
    var sizeOtherScopes = otherScopes.getScopeCount();
    var sizeThisScopes = this.getScopeCount();
    var sizeUnionScopes = unionScopes.size;
    return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
  };
  ScopeSet2.prototype.getScopeCount = function() {
    return this.scopes.size;
  };
  ScopeSet2.prototype.asArray = function() {
    var array = [];
    this.scopes.forEach(function(val) {
      return array.push(val);
    });
    return array;
  };
  ScopeSet2.prototype.printScopes = function() {
    if (this.scopes) {
      var scopeArr = this.asArray();
      return scopeArr.join(" ");
    }
    return Constants.EMPTY_STRING;
  };
  ScopeSet2.prototype.printScopesLowerCase = function() {
    return this.printScopes().toLowerCase();
  };
  return ScopeSet2;
}();

// node_modules/@azure/msal-common/dist/account/ClientInfo.js
function buildClientInfo(rawClientInfo, crypto3) {
  if (StringUtils.isEmpty(rawClientInfo)) {
    throw ClientAuthError.createClientInfoEmptyError();
  }
  try {
    var decodedClientInfo = crypto3.base64Decode(rawClientInfo);
    return JSON.parse(decodedClientInfo);
  } catch (e) {
    throw ClientAuthError.createClientInfoDecodingError(e.message);
  }
}
function buildClientInfoFromHomeAccountId(homeAccountId) {
  if (StringUtils.isEmpty(homeAccountId)) {
    throw ClientAuthError.createClientInfoDecodingError("Home account ID was empty.");
  }
  var clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
  return {
    uid: clientInfoParts[0],
    utid: clientInfoParts.length < 2 ? Constants.EMPTY_STRING : clientInfoParts[1]
  };
}

// node_modules/@azure/msal-common/dist/authority/AuthorityType.js
var AuthorityType;
(function(AuthorityType2) {
  AuthorityType2[AuthorityType2["Default"] = 0] = "Default";
  AuthorityType2[AuthorityType2["Adfs"] = 1] = "Adfs";
  AuthorityType2[AuthorityType2["Dsts"] = 2] = "Dsts";
})(AuthorityType || (AuthorityType = {}));

// node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.js
var AccountEntity = function() {
  function AccountEntity2() {
  }
  AccountEntity2.prototype.generateAccountId = function() {
    var accountId = [this.homeAccountId, this.environment];
    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
  };
  AccountEntity2.prototype.generateAccountKey = function() {
    return AccountEntity2.generateAccountCacheKey({
      homeAccountId: this.homeAccountId,
      environment: this.environment,
      tenantId: this.realm,
      username: this.username,
      localAccountId: this.localAccountId
    });
  };
  AccountEntity2.prototype.generateType = function() {
    switch (this.authorityType) {
      case CacheAccountType.ADFS_ACCOUNT_TYPE:
        return CacheType.ADFS;
      case CacheAccountType.MSAV1_ACCOUNT_TYPE:
        return CacheType.MSA;
      case CacheAccountType.MSSTS_ACCOUNT_TYPE:
        return CacheType.MSSTS;
      case CacheAccountType.GENERIC_ACCOUNT_TYPE:
        return CacheType.GENERIC;
      default: {
        throw ClientAuthError.createUnexpectedAccountTypeError();
      }
    }
  };
  AccountEntity2.prototype.getAccountInfo = function() {
    return {
      homeAccountId: this.homeAccountId,
      environment: this.environment,
      tenantId: this.realm,
      username: this.username,
      localAccountId: this.localAccountId,
      name: this.name,
      idTokenClaims: this.idTokenClaims,
      nativeAccountId: this.nativeAccountId
    };
  };
  AccountEntity2.generateAccountCacheKey = function(accountInterface) {
    var accountKey = [
      accountInterface.homeAccountId,
      accountInterface.environment || Constants.EMPTY_STRING,
      accountInterface.tenantId || Constants.EMPTY_STRING
    ];
    return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
  };
  AccountEntity2.createAccount = function(clientInfo, homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment, nativeAccountId) {
    var _a, _b, _c, _d, _e, _f;
    var account = new AccountEntity2();
    account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
    account.clientInfo = clientInfo;
    account.homeAccountId = homeAccountId;
    account.nativeAccountId = nativeAccountId;
    var env = environment || authority && authority.getPreferredCache();
    if (!env) {
      throw ClientAuthError.createInvalidCacheEnvironmentError();
    }
    account.environment = env;
    account.realm = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.tid) || Constants.EMPTY_STRING;
    if (idToken) {
      account.idTokenClaims = idToken.claims;
      account.localAccountId = ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.oid) || ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.sub) || Constants.EMPTY_STRING;
      var preferredUsername = (_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.preferred_username;
      var email = ((_e = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _e === void 0 ? void 0 : _e.emails) ? idToken.claims.emails[0] : null;
      account.username = preferredUsername || email || Constants.EMPTY_STRING;
      account.name = (_f = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _f === void 0 ? void 0 : _f.name;
    }
    account.cloudGraphHostName = cloudGraphHostName;
    account.msGraphHost = msGraphHost;
    return account;
  };
  AccountEntity2.createGenericAccount = function(homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment) {
    var _a, _b, _c, _d;
    var account = new AccountEntity2();
    account.authorityType = authority && authority.authorityType === AuthorityType.Adfs ? CacheAccountType.ADFS_ACCOUNT_TYPE : CacheAccountType.GENERIC_ACCOUNT_TYPE;
    account.homeAccountId = homeAccountId;
    account.realm = Constants.EMPTY_STRING;
    var env = environment || authority && authority.getPreferredCache();
    if (!env) {
      throw ClientAuthError.createInvalidCacheEnvironmentError();
    }
    if (idToken) {
      account.localAccountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.oid) || ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.sub) || Constants.EMPTY_STRING;
      account.username = ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.upn) || Constants.EMPTY_STRING;
      account.name = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.name) || Constants.EMPTY_STRING;
      account.idTokenClaims = idToken === null || idToken === void 0 ? void 0 : idToken.claims;
    }
    account.environment = env;
    account.cloudGraphHostName = cloudGraphHostName;
    account.msGraphHost = msGraphHost;
    return account;
  };
  AccountEntity2.generateHomeAccountId = function(serverClientInfo, authType, logger, cryptoObj, idToken) {
    var _a;
    var accountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.sub) ? idToken.claims.sub : Constants.EMPTY_STRING;
    if (authType === AuthorityType.Adfs || authType === AuthorityType.Dsts) {
      return accountId;
    }
    if (serverClientInfo) {
      try {
        var clientInfo = buildClientInfo(serverClientInfo, cryptoObj);
        if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {
          return "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid;
        }
      } catch (e) {
      }
    }
    logger.verbose("No client info in response");
    return accountId;
  };
  AccountEntity2.isAccountEntity = function(entity) {
    if (!entity) {
      return false;
    }
    return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("localAccountId") && entity.hasOwnProperty("username") && entity.hasOwnProperty("authorityType");
  };
  AccountEntity2.accountInfoIsEqual = function(accountA, accountB, compareClaims) {
    if (!accountA || !accountB) {
      return false;
    }
    var claimsMatch = true;
    if (compareClaims) {
      var accountAClaims = accountA.idTokenClaims || {};
      var accountBClaims = accountB.idTokenClaims || {};
      claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;
    }
    return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;
  };
  return AccountEntity2;
}();

// node_modules/@azure/msal-common/dist/account/AuthToken.js
var AuthToken = function() {
  function AuthToken2(rawToken, crypto3) {
    if (StringUtils.isEmpty(rawToken)) {
      throw ClientAuthError.createTokenNullOrEmptyError(rawToken);
    }
    this.rawToken = rawToken;
    this.claims = AuthToken2.extractTokenClaims(rawToken, crypto3);
  }
  AuthToken2.extractTokenClaims = function(encodedToken, crypto3) {
    var decodedToken = StringUtils.decodeAuthToken(encodedToken);
    try {
      var base64TokenPayload = decodedToken.JWSPayload;
      var base64Decoded = crypto3.base64Decode(base64TokenPayload);
      return JSON.parse(base64Decoded);
    } catch (err) {
      throw ClientAuthError.createTokenParsingError(err);
    }
  };
  AuthToken2.checkMaxAge = function(authTime, maxAge) {
    var fiveMinuteSkew = 3e5;
    if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {
      throw ClientAuthError.createMaxAgeTranspiredError();
    }
  };
  return AuthToken2;
}();

// node_modules/@azure/msal-common/dist/cache/CacheManager.js
var CacheManager = function() {
  function CacheManager2(clientId, cryptoImpl) {
    this.clientId = clientId;
    this.cryptoImpl = cryptoImpl;
  }
  CacheManager2.prototype.getAllAccounts = function() {
    var _this = this;
    var currentAccounts = this.getAccountsFilteredBy();
    var accountValues = Object.keys(currentAccounts).map(function(accountKey) {
      return currentAccounts[accountKey];
    });
    var numAccounts = accountValues.length;
    if (numAccounts < 1) {
      return [];
    } else {
      var allAccounts = accountValues.map(function(value) {
        var accountEntity = CacheManager2.toObject(new AccountEntity(), value);
        var accountInfo = accountEntity.getAccountInfo();
        var idToken = _this.readIdTokenFromCache(_this.clientId, accountInfo);
        if (idToken && !accountInfo.idTokenClaims) {
          accountInfo.idToken = idToken.secret;
          accountInfo.idTokenClaims = new AuthToken(idToken.secret, _this.cryptoImpl).claims;
        }
        return accountInfo;
      });
      return allAccounts;
    }
  };
  CacheManager2.prototype.saveCacheRecord = function(cacheRecord) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!cacheRecord) {
              throw ClientAuthError.createNullOrUndefinedCacheRecord();
            }
            if (!!cacheRecord.account) {
              this.setAccount(cacheRecord.account);
            }
            if (!!cacheRecord.idToken) {
              this.setIdTokenCredential(cacheRecord.idToken);
            }
            if (!!!cacheRecord.accessToken)
              return [3, 2];
            return [4, this.saveAccessToken(cacheRecord.accessToken)];
          case 1:
            _a.sent();
            _a.label = 2;
          case 2:
            if (!!cacheRecord.refreshToken) {
              this.setRefreshTokenCredential(cacheRecord.refreshToken);
            }
            if (!!cacheRecord.appMetadata) {
              this.setAppMetadata(cacheRecord.appMetadata);
            }
            return [2];
        }
      });
    });
  };
  CacheManager2.prototype.saveAccessToken = function(credential) {
    return __awaiter(this, void 0, void 0, function() {
      var currentTokenCache, currentScopes, currentAccessTokens, removedAccessTokens_1;
      var _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            currentTokenCache = this.getCredentialsFilteredBy({
              clientId: credential.clientId,
              credentialType: credential.credentialType,
              environment: credential.environment,
              homeAccountId: credential.homeAccountId,
              realm: credential.realm,
              tokenType: credential.tokenType,
              requestedClaimsHash: credential.requestedClaimsHash
            });
            currentScopes = ScopeSet.fromString(credential.target);
            currentAccessTokens = Object.keys(currentTokenCache.accessTokens).map(function(key) {
              return currentTokenCache.accessTokens[key];
            });
            if (!currentAccessTokens)
              return [3, 2];
            removedAccessTokens_1 = [];
            currentAccessTokens.forEach(function(tokenEntity) {
              var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
              if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
                removedAccessTokens_1.push(_this.removeCredential(tokenEntity));
              }
            });
            return [4, Promise.all(removedAccessTokens_1)];
          case 1:
            _a.sent();
            _a.label = 2;
          case 2:
            this.setAccessTokenCredential(credential);
            return [2];
        }
      });
    });
  };
  CacheManager2.prototype.getAccountsFilteredBy = function(accountFilter) {
    return this.getAccountsFilteredByInternal(accountFilter ? accountFilter.homeAccountId : Constants.EMPTY_STRING, accountFilter ? accountFilter.environment : Constants.EMPTY_STRING, accountFilter ? accountFilter.realm : Constants.EMPTY_STRING, accountFilter ? accountFilter.nativeAccountId : Constants.EMPTY_STRING);
  };
  CacheManager2.prototype.getAccountsFilteredByInternal = function(homeAccountId, environment, realm, nativeAccountId) {
    var _this = this;
    var allCacheKeys = this.getKeys();
    var matchingAccounts = {};
    allCacheKeys.forEach(function(cacheKey) {
      var entity = _this.getAccount(cacheKey);
      if (!entity) {
        return;
      }
      if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {
        return;
      }
      if (!!environment && !_this.matchEnvironment(entity, environment)) {
        return;
      }
      if (!!realm && !_this.matchRealm(entity, realm)) {
        return;
      }
      if (!!nativeAccountId && !_this.matchNativeAccountId(entity, nativeAccountId)) {
        return;
      }
      matchingAccounts[cacheKey] = entity;
    });
    return matchingAccounts;
  };
  CacheManager2.prototype.getCredentialsFilteredBy = function(filter) {
    return this.getCredentialsFilteredByInternal(filter.homeAccountId, filter.environment, filter.credentialType, filter.clientId, filter.familyId, filter.realm, filter.target, filter.userAssertionHash, filter.tokenType, filter.keyId, filter.requestedClaimsHash);
  };
  CacheManager2.prototype.getCredentialsFilteredByInternal = function(homeAccountId, environment, credentialType, clientId, familyId, realm, target, userAssertionHash, tokenType, keyId, requestedClaimsHash) {
    var _this = this;
    var allCacheKeys = this.getKeys();
    var matchingCredentials = {
      idTokens: {},
      accessTokens: {},
      refreshTokens: {}
    };
    allCacheKeys.forEach(function(cacheKey) {
      var credType = CredentialEntity.getCredentialType(cacheKey);
      if (credType === Constants.NOT_DEFINED) {
        return;
      }
      var entity = _this.getSpecificCredential(cacheKey, credType);
      if (!entity) {
        return;
      }
      if (!!userAssertionHash && !_this.matchUserAssertionHash(entity, userAssertionHash)) {
        return;
      }
      if (typeof homeAccountId === "string" && !_this.matchHomeAccountId(entity, homeAccountId)) {
        return;
      }
      if (!!environment && !_this.matchEnvironment(entity, environment)) {
        return;
      }
      if (!!realm && !_this.matchRealm(entity, realm)) {
        return;
      }
      if (!!credentialType && !_this.matchCredentialType(entity, credentialType)) {
        return;
      }
      if (!!clientId && !_this.matchClientId(entity, clientId)) {
        return;
      }
      if (!!familyId && !_this.matchFamilyId(entity, familyId)) {
        return;
      }
      if (!!target && !_this.matchTarget(entity, target)) {
        return;
      }
      if (requestedClaimsHash || entity.requestedClaimsHash) {
        if (entity.requestedClaimsHash !== requestedClaimsHash) {
          return;
        }
      }
      if (credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
        if (!!tokenType && !_this.matchTokenType(entity, tokenType)) {
          return;
        }
        if (tokenType === AuthenticationScheme.SSH) {
          if (keyId && !_this.matchKeyId(entity, keyId)) {
            return;
          }
        }
      }
      var updatedCacheKey = _this.updateCredentialCacheKey(cacheKey, entity);
      switch (credType) {
        case CredentialType.ID_TOKEN:
          matchingCredentials.idTokens[updatedCacheKey] = entity;
          break;
        case CredentialType.ACCESS_TOKEN:
        case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
          matchingCredentials.accessTokens[updatedCacheKey] = entity;
          break;
        case CredentialType.REFRESH_TOKEN:
          matchingCredentials.refreshTokens[updatedCacheKey] = entity;
          break;
      }
    });
    return matchingCredentials;
  };
  CacheManager2.prototype.getAppMetadataFilteredBy = function(filter) {
    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);
  };
  CacheManager2.prototype.getAppMetadataFilteredByInternal = function(environment, clientId) {
    var _this = this;
    var allCacheKeys = this.getKeys();
    var matchingAppMetadata = {};
    allCacheKeys.forEach(function(cacheKey) {
      if (!_this.isAppMetadata(cacheKey)) {
        return;
      }
      var entity = _this.getAppMetadata(cacheKey);
      if (!entity) {
        return;
      }
      if (!!environment && !_this.matchEnvironment(entity, environment)) {
        return;
      }
      if (!!clientId && !_this.matchClientId(entity, clientId)) {
        return;
      }
      matchingAppMetadata[cacheKey] = entity;
    });
    return matchingAppMetadata;
  };
  CacheManager2.prototype.getAuthorityMetadataByAlias = function(host) {
    var _this = this;
    var allCacheKeys = this.getAuthorityMetadataKeys();
    var matchedEntity = null;
    allCacheKeys.forEach(function(cacheKey) {
      if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {
        return;
      }
      var entity = _this.getAuthorityMetadata(cacheKey);
      if (!entity) {
        return;
      }
      if (entity.aliases.indexOf(host) === -1) {
        return;
      }
      matchedEntity = entity;
    });
    return matchedEntity;
  };
  CacheManager2.prototype.removeAllAccounts = function() {
    return __awaiter(this, void 0, void 0, function() {
      var allCacheKeys, removedAccounts;
      var _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            allCacheKeys = this.getKeys();
            removedAccounts = [];
            allCacheKeys.forEach(function(cacheKey) {
              var entity = _this.getAccount(cacheKey);
              if (!entity) {
                return;
              }
              removedAccounts.push(_this.removeAccount(cacheKey));
            });
            return [4, Promise.all(removedAccounts)];
          case 1:
            _a.sent();
            return [2, true];
        }
      });
    });
  };
  CacheManager2.prototype.removeAccount = function(accountKey) {
    return __awaiter(this, void 0, void 0, function() {
      var account;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            account = this.getAccount(accountKey);
            if (!account) {
              throw ClientAuthError.createNoAccountFoundError();
            }
            return [4, this.removeAccountContext(account)];
          case 1:
            return [2, _a.sent() && this.removeItem(accountKey, CacheSchemaType.ACCOUNT)];
        }
      });
    });
  };
  CacheManager2.prototype.removeAccountContext = function(account) {
    return __awaiter(this, void 0, void 0, function() {
      var allCacheKeys, accountId, removedCredentials;
      var _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            allCacheKeys = this.getKeys();
            accountId = account.generateAccountId();
            removedCredentials = [];
            allCacheKeys.forEach(function(cacheKey) {
              var credType = CredentialEntity.getCredentialType(cacheKey);
              if (credType === Constants.NOT_DEFINED) {
                return;
              }
              var cacheEntity = _this.getSpecificCredential(cacheKey, credType);
              if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {
                removedCredentials.push(_this.removeCredential(cacheEntity));
              }
            });
            return [4, Promise.all(removedCredentials)];
          case 1:
            _a.sent();
            return [2, true];
        }
      });
    });
  };
  CacheManager2.prototype.removeCredential = function(credential) {
    return __awaiter(this, void 0, void 0, function() {
      var key, accessTokenWithAuthSchemeEntity, kid;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            key = credential.generateCredentialKey();
            if (!(credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()))
              return [3, 4];
            if (!(credential.tokenType === AuthenticationScheme.POP))
              return [3, 4];
            accessTokenWithAuthSchemeEntity = credential;
            kid = accessTokenWithAuthSchemeEntity.keyId;
            if (!kid)
              return [3, 4];
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, , 4]);
            return [4, this.cryptoImpl.removeTokenBindingKey(kid)];
          case 2:
            _a.sent();
            return [3, 4];
          case 3:
            _a.sent();
            throw ClientAuthError.createBindingKeyNotRemovedError();
          case 4:
            return [2, this.removeItem(key, CacheSchemaType.CREDENTIAL)];
        }
      });
    });
  };
  CacheManager2.prototype.removeAppMetadata = function() {
    var _this = this;
    var allCacheKeys = this.getKeys();
    allCacheKeys.forEach(function(cacheKey) {
      if (_this.isAppMetadata(cacheKey)) {
        _this.removeItem(cacheKey, CacheSchemaType.APP_METADATA);
      }
    });
    return true;
  };
  CacheManager2.prototype.readCacheRecord = function(account, clientId, request, environment) {
    var cachedAccount = this.readAccountFromCache(account);
    var cachedIdToken = this.readIdTokenFromCache(clientId, account);
    var cachedAccessToken = this.readAccessTokenFromCache(clientId, account, request);
    var cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);
    var cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);
    if (cachedAccount && cachedIdToken) {
      cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;
    }
    return {
      account: cachedAccount,
      idToken: cachedIdToken,
      accessToken: cachedAccessToken,
      refreshToken: cachedRefreshToken,
      appMetadata: cachedAppMetadata
    };
  };
  CacheManager2.prototype.readAccountFromCache = function(account) {
    var accountKey = AccountEntity.generateAccountCacheKey(account);
    return this.getAccount(accountKey);
  };
  CacheManager2.prototype.readAccountFromCacheWithNativeAccountId = function(nativeAccountId) {
    var accountFilter = {
      nativeAccountId
    };
    var accountCache = this.getAccountsFilteredBy(accountFilter);
    var accounts = Object.keys(accountCache).map(function(key) {
      return accountCache[key];
    });
    if (accounts.length < 1) {
      return null;
    } else if (accounts.length > 1) {
      throw ClientAuthError.createMultipleMatchingAccountsInCacheError();
    }
    return accountCache[0];
  };
  CacheManager2.prototype.readIdTokenFromCache = function(clientId, account) {
    var idTokenFilter = {
      homeAccountId: account.homeAccountId,
      environment: account.environment,
      credentialType: CredentialType.ID_TOKEN,
      clientId,
      realm: account.tenantId
    };
    var credentialCache = this.getCredentialsFilteredBy(idTokenFilter);
    var idTokens = Object.keys(credentialCache.idTokens).map(function(key) {
      return credentialCache.idTokens[key];
    });
    var numIdTokens = idTokens.length;
    if (numIdTokens < 1) {
      return null;
    } else if (numIdTokens > 1) {
      throw ClientAuthError.createMultipleMatchingTokensInCacheError();
    }
    return idTokens[0];
  };
  CacheManager2.prototype.readAccessTokenFromCache = function(clientId, account, request) {
    var scopes = new ScopeSet(request.scopes || []);
    var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
    var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
    var accessTokenFilter = {
      homeAccountId: account.homeAccountId,
      environment: account.environment,
      credentialType,
      clientId,
      realm: account.tenantId,
      target: scopes.printScopesLowerCase(),
      tokenType: authScheme,
      keyId: request.sshKid,
      requestedClaimsHash: request.requestedClaimsHash
    };
    var credentialCache = this.getCredentialsFilteredBy(accessTokenFilter);
    var accessTokens = Object.keys(credentialCache.accessTokens).map(function(key) {
      return credentialCache.accessTokens[key];
    });
    var numAccessTokens = accessTokens.length;
    if (numAccessTokens < 1) {
      return null;
    } else if (numAccessTokens > 1) {
      throw ClientAuthError.createMultipleMatchingTokensInCacheError();
    }
    return accessTokens[0];
  };
  CacheManager2.prototype.readRefreshTokenFromCache = function(clientId, account, familyRT) {
    var id = familyRT ? THE_FAMILY_ID : void 0;
    var refreshTokenFilter = {
      homeAccountId: account.homeAccountId,
      environment: account.environment,
      credentialType: CredentialType.REFRESH_TOKEN,
      clientId,
      familyId: id
    };
    var credentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);
    var refreshTokens = Object.keys(credentialCache.refreshTokens).map(function(key) {
      return credentialCache.refreshTokens[key];
    });
    var numRefreshTokens = refreshTokens.length;
    if (numRefreshTokens < 1) {
      return null;
    }
    return refreshTokens[0];
  };
  CacheManager2.prototype.readAppMetadataFromCache = function(environment, clientId) {
    var appMetadataFilter = {
      environment,
      clientId
    };
    var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
    var appMetadataEntries = Object.keys(appMetadata).map(function(key) {
      return appMetadata[key];
    });
    var numAppMetadata = appMetadataEntries.length;
    if (numAppMetadata < 1) {
      return null;
    } else if (numAppMetadata > 1) {
      throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();
    }
    return appMetadataEntries[0];
  };
  CacheManager2.prototype.isAppMetadataFOCI = function(environment, clientId) {
    var appMetadata = this.readAppMetadataFromCache(environment, clientId);
    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
  };
  CacheManager2.prototype.matchHomeAccountId = function(entity, homeAccountId) {
    return !!(typeof entity.homeAccountId === "string" && homeAccountId === entity.homeAccountId);
  };
  CacheManager2.prototype.matchUserAssertionHash = function(entity, userAssertionHash) {
    return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
  };
  CacheManager2.prototype.matchEnvironment = function(entity, environment) {
    var cloudMetadata = this.getAuthorityMetadataByAlias(environment);
    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
      return true;
    }
    return false;
  };
  CacheManager2.prototype.matchCredentialType = function(entity, credentialType) {
    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();
  };
  CacheManager2.prototype.matchClientId = function(entity, clientId) {
    return !!(entity.clientId && clientId === entity.clientId);
  };
  CacheManager2.prototype.matchFamilyId = function(entity, familyId) {
    return !!(entity.familyId && familyId === entity.familyId);
  };
  CacheManager2.prototype.matchRealm = function(entity, realm) {
    return !!(entity.realm && realm === entity.realm);
  };
  CacheManager2.prototype.matchNativeAccountId = function(entity, nativeAccountId) {
    return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
  };
  CacheManager2.prototype.matchTarget = function(entity, target) {
    var isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
    if (isNotAccessTokenCredential || !entity.target) {
      return false;
    }
    var entityScopeSet = ScopeSet.fromString(entity.target);
    var requestTargetScopeSet = ScopeSet.fromString(target);
    if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {
      requestTargetScopeSet.removeOIDCScopes();
    } else {
      requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);
    }
    return entityScopeSet.containsScopeSet(requestTargetScopeSet);
  };
  CacheManager2.prototype.matchTokenType = function(entity, tokenType) {
    return !!(entity.tokenType && entity.tokenType === tokenType);
  };
  CacheManager2.prototype.matchKeyId = function(entity, keyId) {
    return !!(entity.keyId && entity.keyId === keyId);
  };
  CacheManager2.prototype.isAppMetadata = function(key) {
    return key.indexOf(APP_METADATA) !== -1;
  };
  CacheManager2.prototype.isAuthorityMetadata = function(key) {
    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
  };
  CacheManager2.prototype.generateAuthorityMetadataCacheKey = function(authority) {
    return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + "-" + this.clientId + "-" + authority;
  };
  CacheManager2.prototype.getSpecificCredential = function(key, credType) {
    switch (credType) {
      case CredentialType.ID_TOKEN: {
        return this.getIdTokenCredential(key);
      }
      case CredentialType.ACCESS_TOKEN:
      case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME: {
        return this.getAccessTokenCredential(key);
      }
      case CredentialType.REFRESH_TOKEN: {
        return this.getRefreshTokenCredential(key);
      }
      default:
        return null;
    }
  };
  CacheManager2.toObject = function(obj, json) {
    for (var propertyName in json) {
      obj[propertyName] = json[propertyName];
    }
    return obj;
  };
  return CacheManager2;
}();
var DefaultStorageClass = function(_super) {
  __extends(DefaultStorageClass2, _super);
  function DefaultStorageClass2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DefaultStorageClass2.prototype.setAccount = function() {
    var notImplErr = "Storage interface - setAccount() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.getAccount = function() {
    var notImplErr = "Storage interface - getAccount() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.setIdTokenCredential = function() {
    var notImplErr = "Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.getIdTokenCredential = function() {
    var notImplErr = "Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.setAccessTokenCredential = function() {
    var notImplErr = "Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.getAccessTokenCredential = function() {
    var notImplErr = "Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.setRefreshTokenCredential = function() {
    var notImplErr = "Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.getRefreshTokenCredential = function() {
    var notImplErr = "Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.setAppMetadata = function() {
    var notImplErr = "Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.getAppMetadata = function() {
    var notImplErr = "Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.setServerTelemetry = function() {
    var notImplErr = "Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.getServerTelemetry = function() {
    var notImplErr = "Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.setAuthorityMetadata = function() {
    var notImplErr = "Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.getAuthorityMetadata = function() {
    var notImplErr = "Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.getAuthorityMetadataKeys = function() {
    var notImplErr = "Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.setThrottlingCache = function() {
    var notImplErr = "Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.getThrottlingCache = function() {
    var notImplErr = "Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.removeItem = function() {
    var notImplErr = "Storage interface - removeItem() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.containsKey = function() {
    var notImplErr = "Storage interface - containsKey() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.getKeys = function() {
    var notImplErr = "Storage interface - getKeys() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  DefaultStorageClass2.prototype.clear = function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a) {
        notImplErr = "Storage interface - clear() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  };
  DefaultStorageClass2.prototype.updateCredentialCacheKey = function() {
    var notImplErr = "Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.";
    throw AuthError.createUnexpectedError(notImplErr);
  };
  return DefaultStorageClass2;
}(CacheManager);

// node_modules/@azure/msal-common/dist/config/ClientConfiguration.js
var DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
var DEFAULT_SYSTEM_OPTIONS = {
  tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
  preventCorsPreflight: false,
  proxyUrl: Constants.EMPTY_STRING
};
var DEFAULT_LOGGER_IMPLEMENTATION = {
  loggerCallback: function() {
  },
  piiLoggingEnabled: false,
  logLevel: LogLevel.Info,
  correlationId: Constants.EMPTY_STRING
};
var DEFAULT_NETWORK_IMPLEMENTATION = {
  sendGetRequestAsync: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a) {
        notImplErr = "Network interface - sendGetRequestAsync() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  },
  sendPostRequestAsync: function() {
    return __awaiter(this, void 0, void 0, function() {
      var notImplErr;
      return __generator(this, function(_a) {
        notImplErr = "Network interface - sendPostRequestAsync() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      });
    });
  }
};
var DEFAULT_LIBRARY_INFO = {
  sku: Constants.SKU,
  version,
  cpu: Constants.EMPTY_STRING,
  os: Constants.EMPTY_STRING
};
var DEFAULT_CLIENT_CREDENTIALS = {
  clientSecret: Constants.EMPTY_STRING,
  clientAssertion: void 0
};
var DEFAULT_AZURE_CLOUD_OPTIONS = {
  azureCloudInstance: AzureCloudInstance.None,
  tenant: "" + Constants.DEFAULT_COMMON_TENANT
};
var DEFAULT_TELEMETRY_OPTIONS = {
  application: {
    appName: "",
    appVersion: ""
  }
};
function buildClientConfiguration(_a) {
  var userAuthOptions = _a.authOptions, userSystemOptions = _a.systemOptions, userLoggerOption = _a.loggerOptions, storageImplementation = _a.storageInterface, networkImplementation = _a.networkInterface, cryptoImplementation = _a.cryptoInterface, clientCredentials = _a.clientCredentials, libraryInfo = _a.libraryInfo, telemetry = _a.telemetry, serverTelemetryManager = _a.serverTelemetryManager, persistencePlugin = _a.persistencePlugin, serializableCache = _a.serializableCache;
  var loggerOptions = __assign(__assign({}, DEFAULT_LOGGER_IMPLEMENTATION), userLoggerOption);
  return {
    authOptions: buildAuthOptions(userAuthOptions),
    systemOptions: __assign(__assign({}, DEFAULT_SYSTEM_OPTIONS), userSystemOptions),
    loggerOptions,
    storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION),
    networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
    cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
    clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
    libraryInfo: __assign(__assign({}, DEFAULT_LIBRARY_INFO), libraryInfo),
    telemetry: __assign(__assign({}, DEFAULT_TELEMETRY_OPTIONS), telemetry),
    serverTelemetryManager: serverTelemetryManager || null,
    persistencePlugin: persistencePlugin || null,
    serializableCache: serializableCache || null
  };
}
function buildAuthOptions(authOptions) {
  return __assign({ clientCapabilities: [], azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS, skipAuthorityMetadataCache: false }, authOptions);
}

// node_modules/@azure/msal-common/dist/error/ServerError.js
var ServerError = function(_super) {
  __extends(ServerError2, _super);
  function ServerError2(errorCode, errorMessage, subError) {
    var _this = _super.call(this, errorCode, errorMessage, subError) || this;
    _this.name = "ServerError";
    Object.setPrototypeOf(_this, ServerError2.prototype);
    return _this;
  }
  return ServerError2;
}(AuthError);

// node_modules/@azure/msal-common/dist/network/ThrottlingUtils.js
var ThrottlingUtils = function() {
  function ThrottlingUtils2() {
  }
  ThrottlingUtils2.generateThrottlingStorageKey = function(thumbprint) {
    return ThrottlingConstants.THROTTLING_PREFIX + "." + JSON.stringify(thumbprint);
  };
  ThrottlingUtils2.preProcess = function(cacheManager, thumbprint) {
    var _a;
    var key = ThrottlingUtils2.generateThrottlingStorageKey(thumbprint);
    var value = cacheManager.getThrottlingCache(key);
    if (value) {
      if (value.throttleTime < Date.now()) {
        cacheManager.removeItem(key, CacheSchemaType.THROTTLING);
        return;
      }
      throw new ServerError(((_a = value.errorCodes) === null || _a === void 0 ? void 0 : _a.join(" ")) || Constants.EMPTY_STRING, value.errorMessage, value.subError);
    }
  };
  ThrottlingUtils2.postProcess = function(cacheManager, thumbprint, response) {
    if (ThrottlingUtils2.checkResponseStatus(response) || ThrottlingUtils2.checkResponseForRetryAfter(response)) {
      var thumbprintValue = {
        throttleTime: ThrottlingUtils2.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
        error: response.body.error,
        errorCodes: response.body.error_codes,
        errorMessage: response.body.error_description,
        subError: response.body.suberror
      };
      cacheManager.setThrottlingCache(ThrottlingUtils2.generateThrottlingStorageKey(thumbprint), thumbprintValue);
    }
  };
  ThrottlingUtils2.checkResponseStatus = function(response) {
    return response.status === 429 || response.status >= 500 && response.status < 600;
  };
  ThrottlingUtils2.checkResponseForRetryAfter = function(response) {
    if (response.headers) {
      return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300);
    }
    return false;
  };
  ThrottlingUtils2.calculateThrottleTime = function(throttleTime) {
    var time = throttleTime <= 0 ? 0 : throttleTime;
    var currentSeconds = Date.now() / 1e3;
    return Math.floor(Math.min(currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1e3);
  };
  ThrottlingUtils2.removeThrottle = function(cacheManager, clientId, request, homeAccountIdentifier) {
    var thumbprint = {
      clientId,
      authority: request.authority,
      scopes: request.scopes,
      homeAccountIdentifier,
      claims: request.claims,
      authenticationScheme: request.authenticationScheme,
      resourceRequestMethod: request.resourceRequestMethod,
      resourceRequestUri: request.resourceRequestUri,
      shrClaims: request.shrClaims,
      sshKid: request.sshKid
    };
    var key = this.generateThrottlingStorageKey(thumbprint);
    return cacheManager.removeItem(key, CacheSchemaType.THROTTLING);
  };
  return ThrottlingUtils2;
}();

// node_modules/@azure/msal-common/dist/network/NetworkManager.js
var NetworkManager = function() {
  function NetworkManager2(networkClient, cacheManager) {
    this.networkClient = networkClient;
    this.cacheManager = cacheManager;
  }
  NetworkManager2.prototype.sendPostRequest = function(thumbprint, tokenEndpoint, options) {
    return __awaiter(this, void 0, void 0, function() {
      var response, e_1;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            ThrottlingUtils.preProcess(this.cacheManager, thumbprint);
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, , 4]);
            return [4, this.networkClient.sendPostRequestAsync(tokenEndpoint, options)];
          case 2:
            response = _a.sent();
            return [3, 4];
          case 3:
            e_1 = _a.sent();
            if (e_1 instanceof AuthError) {
              throw e_1;
            } else {
              throw ClientAuthError.createNetworkError(tokenEndpoint, e_1);
            }
          case 4:
            ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response);
            return [2, response];
        }
      });
    });
  };
  return NetworkManager2;
}();

// node_modules/@azure/msal-common/dist/account/CcsCredential.js
var CcsCredentialType;
(function(CcsCredentialType2) {
  CcsCredentialType2["HOME_ACCOUNT_ID"] = "home_account_id";
  CcsCredentialType2["UPN"] = "UPN";
})(CcsCredentialType || (CcsCredentialType = {}));

// node_modules/@azure/msal-common/dist/client/BaseClient.js
var BaseClient = function() {
  function BaseClient2(configuration, performanceClient) {
    this.config = buildClientConfiguration(configuration);
    this.logger = new Logger(this.config.loggerOptions, name, version);
    this.cryptoUtils = this.config.cryptoInterface;
    this.cacheManager = this.config.storageInterface;
    this.networkClient = this.config.networkInterface;
    this.networkManager = new NetworkManager(this.networkClient, this.cacheManager);
    this.serverTelemetryManager = this.config.serverTelemetryManager;
    this.authority = this.config.authOptions.authority;
    this.performanceClient = performanceClient;
  }
  BaseClient2.prototype.createTokenRequestHeaders = function(ccsCred) {
    var headers = {};
    headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
    if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
      switch (ccsCred.type) {
        case CcsCredentialType.HOME_ACCOUNT_ID:
          try {
            var clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
            headers[HeaderNames.CCS_HEADER] = "Oid:" + clientInfo.uid + "@" + clientInfo.utid;
          } catch (e) {
            this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
          }
          break;
        case CcsCredentialType.UPN:
          headers[HeaderNames.CCS_HEADER] = "UPN: " + ccsCred.credential;
          break;
      }
    }
    return headers;
  };
  BaseClient2.prototype.executePostToTokenEndpoint = function(tokenEndpoint, queryString, headers, thumbprint) {
    return __awaiter(this, void 0, void 0, function() {
      var response;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.networkManager.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers, proxyUrl: this.config.systemOptions.proxyUrl })];
          case 1:
            response = _a.sent();
            if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
              this.config.serverTelemetryManager.clearTelemetryCache();
            }
            return [2, response];
        }
      });
    });
  };
  BaseClient2.prototype.updateAuthority = function(updatedAuthority) {
    if (!updatedAuthority.discoveryComplete()) {
      throw ClientAuthError.createEndpointDiscoveryIncompleteError("Updated authority has not completed endpoint discovery.");
    }
    this.authority = updatedAuthority;
  };
  return BaseClient2;
}();

// node_modules/@azure/msal-common/dist/request/RequestValidator.js
var RequestValidator = function() {
  function RequestValidator2() {
  }
  RequestValidator2.validateRedirectUri = function(redirectUri) {
    if (StringUtils.isEmpty(redirectUri)) {
      throw ClientConfigurationError.createRedirectUriEmptyError();
    }
  };
  RequestValidator2.validatePrompt = function(prompt) {
    var promptValues = [];
    for (var value in PromptValue) {
      promptValues.push(PromptValue[value]);
    }
    if (promptValues.indexOf(prompt) < 0) {
      throw ClientConfigurationError.createInvalidPromptError(prompt);
    }
  };
  RequestValidator2.validateClaims = function(claims) {
    try {
      JSON.parse(claims);
    } catch (e) {
      throw ClientConfigurationError.createInvalidClaimsRequestError();
    }
  };
  RequestValidator2.validateCodeChallengeParams = function(codeChallenge, codeChallengeMethod) {
    if (StringUtils.isEmpty(codeChallenge) || StringUtils.isEmpty(codeChallengeMethod)) {
      throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
    } else {
      this.validateCodeChallengeMethod(codeChallengeMethod);
    }
  };
  RequestValidator2.validateCodeChallengeMethod = function(codeChallengeMethod) {
    if ([
      CodeChallengeMethodValues.PLAIN,
      CodeChallengeMethodValues.S256
    ].indexOf(codeChallengeMethod) < 0) {
      throw ClientConfigurationError.createInvalidCodeChallengeMethodError();
    }
  };
  RequestValidator2.sanitizeEQParams = function(eQParams, queryParams) {
    if (!eQParams) {
      return {};
    }
    queryParams.forEach(function(value, key) {
      if (eQParams[key]) {
        delete eQParams[key];
      }
    });
    return eQParams;
  };
  return RequestValidator2;
}();

// node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.js
var RequestParameterBuilder = function() {
  function RequestParameterBuilder2() {
    this.parameters = /* @__PURE__ */ new Map();
  }
  RequestParameterBuilder2.prototype.addResponseTypeCode = function() {
    this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.CODE_RESPONSE_TYPE));
  };
  RequestParameterBuilder2.prototype.addResponseTypeForTokenAndIdToken = function() {
    this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.TOKEN_RESPONSE_TYPE + " " + Constants.ID_TOKEN_RESPONSE_TYPE));
  };
  RequestParameterBuilder2.prototype.addResponseMode = function(responseMode) {
    this.parameters.set(AADServerParamKeys.RESPONSE_MODE, encodeURIComponent(responseMode ? responseMode : ResponseMode.QUERY));
  };
  RequestParameterBuilder2.prototype.addNativeBroker = function() {
    this.parameters.set(AADServerParamKeys.NATIVE_BROKER, encodeURIComponent("1"));
  };
  RequestParameterBuilder2.prototype.addScopes = function(scopes, addOidcScopes) {
    if (addOidcScopes === void 0) {
      addOidcScopes = true;
    }
    var requestScopes = addOidcScopes ? __spreadArrays(scopes || [], OIDC_DEFAULT_SCOPES) : scopes || [];
    var scopeSet = new ScopeSet(requestScopes);
    this.parameters.set(AADServerParamKeys.SCOPE, encodeURIComponent(scopeSet.printScopes()));
  };
  RequestParameterBuilder2.prototype.addClientId = function(clientId) {
    this.parameters.set(AADServerParamKeys.CLIENT_ID, encodeURIComponent(clientId));
  };
  RequestParameterBuilder2.prototype.addRedirectUri = function(redirectUri) {
    RequestValidator.validateRedirectUri(redirectUri);
    this.parameters.set(AADServerParamKeys.REDIRECT_URI, encodeURIComponent(redirectUri));
  };
  RequestParameterBuilder2.prototype.addPostLogoutRedirectUri = function(redirectUri) {
    RequestValidator.validateRedirectUri(redirectUri);
    this.parameters.set(AADServerParamKeys.POST_LOGOUT_URI, encodeURIComponent(redirectUri));
  };
  RequestParameterBuilder2.prototype.addIdTokenHint = function(idTokenHint) {
    this.parameters.set(AADServerParamKeys.ID_TOKEN_HINT, encodeURIComponent(idTokenHint));
  };
  RequestParameterBuilder2.prototype.addDomainHint = function(domainHint) {
    this.parameters.set(SSOTypes.DOMAIN_HINT, encodeURIComponent(domainHint));
  };
  RequestParameterBuilder2.prototype.addLoginHint = function(loginHint) {
    this.parameters.set(SSOTypes.LOGIN_HINT, encodeURIComponent(loginHint));
  };
  RequestParameterBuilder2.prototype.addCcsUpn = function(loginHint) {
    this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("UPN:" + loginHint));
  };
  RequestParameterBuilder2.prototype.addCcsOid = function(clientInfo) {
    this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("Oid:" + clientInfo.uid + "@" + clientInfo.utid));
  };
  RequestParameterBuilder2.prototype.addSid = function(sid) {
    this.parameters.set(SSOTypes.SID, encodeURIComponent(sid));
  };
  RequestParameterBuilder2.prototype.addClaims = function(claims, clientCapabilities) {
    var mergedClaims = this.addClientCapabilitiesToClaims(claims, clientCapabilities);
    RequestValidator.validateClaims(mergedClaims);
    this.parameters.set(AADServerParamKeys.CLAIMS, encodeURIComponent(mergedClaims));
  };
  RequestParameterBuilder2.prototype.addCorrelationId = function(correlationId) {
    this.parameters.set(AADServerParamKeys.CLIENT_REQUEST_ID, encodeURIComponent(correlationId));
  };
  RequestParameterBuilder2.prototype.addLibraryInfo = function(libraryInfo) {
    this.parameters.set(AADServerParamKeys.X_CLIENT_SKU, libraryInfo.sku);
    this.parameters.set(AADServerParamKeys.X_CLIENT_VER, libraryInfo.version);
    if (libraryInfo.os) {
      this.parameters.set(AADServerParamKeys.X_CLIENT_OS, libraryInfo.os);
    }
    if (libraryInfo.cpu) {
      this.parameters.set(AADServerParamKeys.X_CLIENT_CPU, libraryInfo.cpu);
    }
  };
  RequestParameterBuilder2.prototype.addApplicationTelemetry = function(appTelemetry) {
    if (appTelemetry === null || appTelemetry === void 0 ? void 0 : appTelemetry.appName) {
      this.parameters.set(AADServerParamKeys.X_APP_NAME, appTelemetry.appName);
    }
    if (appTelemetry === null || appTelemetry === void 0 ? void 0 : appTelemetry.appVersion) {
      this.parameters.set(AADServerParamKeys.X_APP_VER, appTelemetry.appVersion);
    }
  };
  RequestParameterBuilder2.prototype.addPrompt = function(prompt) {
    RequestValidator.validatePrompt(prompt);
    this.parameters.set("" + AADServerParamKeys.PROMPT, encodeURIComponent(prompt));
  };
  RequestParameterBuilder2.prototype.addState = function(state) {
    if (!StringUtils.isEmpty(state)) {
      this.parameters.set(AADServerParamKeys.STATE, encodeURIComponent(state));
    }
  };
  RequestParameterBuilder2.prototype.addNonce = function(nonce) {
    this.parameters.set(AADServerParamKeys.NONCE, encodeURIComponent(nonce));
  };
  RequestParameterBuilder2.prototype.addCodeChallengeParams = function(codeChallenge, codeChallengeMethod) {
    RequestValidator.validateCodeChallengeParams(codeChallenge, codeChallengeMethod);
    if (codeChallenge && codeChallengeMethod) {
      this.parameters.set(AADServerParamKeys.CODE_CHALLENGE, encodeURIComponent(codeChallenge));
      this.parameters.set(AADServerParamKeys.CODE_CHALLENGE_METHOD, encodeURIComponent(codeChallengeMethod));
    } else {
      throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
    }
  };
  RequestParameterBuilder2.prototype.addAuthorizationCode = function(code) {
    this.parameters.set(AADServerParamKeys.CODE, encodeURIComponent(code));
  };
  RequestParameterBuilder2.prototype.addDeviceCode = function(code) {
    this.parameters.set(AADServerParamKeys.DEVICE_CODE, encodeURIComponent(code));
  };
  RequestParameterBuilder2.prototype.addRefreshToken = function(refreshToken) {
    this.parameters.set(AADServerParamKeys.REFRESH_TOKEN, encodeURIComponent(refreshToken));
  };
  RequestParameterBuilder2.prototype.addCodeVerifier = function(codeVerifier) {
    this.parameters.set(AADServerParamKeys.CODE_VERIFIER, encodeURIComponent(codeVerifier));
  };
  RequestParameterBuilder2.prototype.addClientSecret = function(clientSecret) {
    this.parameters.set(AADServerParamKeys.CLIENT_SECRET, encodeURIComponent(clientSecret));
  };
  RequestParameterBuilder2.prototype.addClientAssertion = function(clientAssertion) {
    if (!StringUtils.isEmpty(clientAssertion)) {
      this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION, encodeURIComponent(clientAssertion));
    }
  };
  RequestParameterBuilder2.prototype.addClientAssertionType = function(clientAssertionType) {
    if (!StringUtils.isEmpty(clientAssertionType)) {
      this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION_TYPE, encodeURIComponent(clientAssertionType));
    }
  };
  RequestParameterBuilder2.prototype.addOboAssertion = function(oboAssertion) {
    this.parameters.set(AADServerParamKeys.OBO_ASSERTION, encodeURIComponent(oboAssertion));
  };
  RequestParameterBuilder2.prototype.addRequestTokenUse = function(tokenUse) {
    this.parameters.set(AADServerParamKeys.REQUESTED_TOKEN_USE, encodeURIComponent(tokenUse));
  };
  RequestParameterBuilder2.prototype.addGrantType = function(grantType) {
    this.parameters.set(AADServerParamKeys.GRANT_TYPE, encodeURIComponent(grantType));
  };
  RequestParameterBuilder2.prototype.addClientInfo = function() {
    this.parameters.set(CLIENT_INFO, "1");
  };
  RequestParameterBuilder2.prototype.addExtraQueryParameters = function(eQparams) {
    var _this = this;
    RequestValidator.sanitizeEQParams(eQparams, this.parameters);
    Object.keys(eQparams).forEach(function(key) {
      _this.parameters.set(key, eQparams[key]);
    });
  };
  RequestParameterBuilder2.prototype.addClientCapabilitiesToClaims = function(claims, clientCapabilities) {
    var mergedClaims;
    if (!claims) {
      mergedClaims = {};
    } else {
      try {
        mergedClaims = JSON.parse(claims);
      } catch (e) {
        throw ClientConfigurationError.createInvalidClaimsRequestError();
      }
    }
    if (clientCapabilities && clientCapabilities.length > 0) {
      if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
        mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
      }
      mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
        values: clientCapabilities
      };
    }
    return JSON.stringify(mergedClaims);
  };
  RequestParameterBuilder2.prototype.addUsername = function(username) {
    this.parameters.set(PasswordGrantConstants.username, encodeURIComponent(username));
  };
  RequestParameterBuilder2.prototype.addPassword = function(password) {
    this.parameters.set(PasswordGrantConstants.password, encodeURIComponent(password));
  };
  RequestParameterBuilder2.prototype.addPopToken = function(cnfString) {
    if (!StringUtils.isEmpty(cnfString)) {
      this.parameters.set(AADServerParamKeys.TOKEN_TYPE, AuthenticationScheme.POP);
      this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(cnfString));
    }
  };
  RequestParameterBuilder2.prototype.addSshJwk = function(sshJwkString) {
    if (!StringUtils.isEmpty(sshJwkString)) {
      this.parameters.set(AADServerParamKeys.TOKEN_TYPE, AuthenticationScheme.SSH);
      this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(sshJwkString));
    }
  };
  RequestParameterBuilder2.prototype.addServerTelemetry = function(serverTelemetryManager) {
    this.parameters.set(AADServerParamKeys.X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
    this.parameters.set(AADServerParamKeys.X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
  };
  RequestParameterBuilder2.prototype.addThrottling = function() {
    this.parameters.set(AADServerParamKeys.X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
  };
  RequestParameterBuilder2.prototype.addLogoutHint = function(logoutHint) {
    this.parameters.set(AADServerParamKeys.LOGOUT_HINT, encodeURIComponent(logoutHint));
  };
  RequestParameterBuilder2.prototype.createQueryString = function() {
    var queryParameterArray = new Array();
    this.parameters.forEach(function(value, key) {
      queryParameterArray.push(key + "=" + value);
    });
    return queryParameterArray.join("&");
  };
  return RequestParameterBuilder2;
}();

// node_modules/@azure/msal-common/dist/cache/entities/IdTokenEntity.js
var IdTokenEntity = function(_super) {
  __extends(IdTokenEntity2, _super);
  function IdTokenEntity2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IdTokenEntity2.createIdTokenEntity = function(homeAccountId, environment, idToken, clientId, tenantId) {
    var idTokenEntity = new IdTokenEntity2();
    idTokenEntity.credentialType = CredentialType.ID_TOKEN;
    idTokenEntity.homeAccountId = homeAccountId;
    idTokenEntity.environment = environment;
    idTokenEntity.clientId = clientId;
    idTokenEntity.secret = idToken;
    idTokenEntity.realm = tenantId;
    return idTokenEntity;
  };
  IdTokenEntity2.isIdTokenEntity = function(entity) {
    if (!entity) {
      return false;
    }
    return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity["credentialType"] === CredentialType.ID_TOKEN;
  };
  return IdTokenEntity2;
}(CredentialEntity);

// node_modules/@azure/msal-common/dist/utils/TimeUtils.js
var TimeUtils = function() {
  function TimeUtils2() {
  }
  TimeUtils2.nowSeconds = function() {
    return Math.round(new Date().getTime() / 1e3);
  };
  TimeUtils2.isTokenExpired = function(expiresOn, offset) {
    var expirationSec = Number(expiresOn) || 0;
    var offsetCurrentTimeSec = TimeUtils2.nowSeconds() + offset;
    return offsetCurrentTimeSec > expirationSec;
  };
  TimeUtils2.wasClockTurnedBack = function(cachedAt) {
    var cachedAtSec = Number(cachedAt);
    return cachedAtSec > TimeUtils2.nowSeconds();
  };
  TimeUtils2.delay = function(t2, value) {
    return new Promise(function(resolve) {
      return setTimeout(function() {
        return resolve(value);
      }, t2);
    });
  };
  return TimeUtils2;
}();

// node_modules/@azure/msal-common/dist/cache/entities/AccessTokenEntity.js
var AccessTokenEntity = function(_super) {
  __extends(AccessTokenEntity2, _super);
  function AccessTokenEntity2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AccessTokenEntity2.createAccessTokenEntity = function(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
    var _a, _b;
    var atEntity = new AccessTokenEntity2();
    atEntity.homeAccountId = homeAccountId;
    atEntity.credentialType = CredentialType.ACCESS_TOKEN;
    atEntity.secret = accessToken;
    var currentTime = TimeUtils.nowSeconds();
    atEntity.cachedAt = currentTime.toString();
    atEntity.expiresOn = expiresOn.toString();
    atEntity.extendedExpiresOn = extExpiresOn.toString();
    if (refreshOn) {
      atEntity.refreshOn = refreshOn.toString();
    }
    atEntity.environment = environment;
    atEntity.clientId = clientId;
    atEntity.realm = tenantId;
    atEntity.target = scopes;
    atEntity.userAssertionHash = userAssertionHash;
    atEntity.tokenType = StringUtils.isEmpty(tokenType) ? AuthenticationScheme.BEARER : tokenType;
    if (requestedClaims) {
      atEntity.requestedClaims = requestedClaims;
      atEntity.requestedClaimsHash = requestedClaimsHash;
    }
    if (((_a = atEntity.tokenType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== AuthenticationScheme.BEARER.toLowerCase()) {
      atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
      switch (atEntity.tokenType) {
        case AuthenticationScheme.POP:
          var tokenClaims = AuthToken.extractTokenClaims(accessToken, cryptoUtils);
          if (!((_b = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _b === void 0 ? void 0 : _b.kid)) {
            throw ClientAuthError.createTokenClaimsRequiredError();
          }
          atEntity.keyId = tokenClaims.cnf.kid;
          break;
        case AuthenticationScheme.SSH:
          atEntity.keyId = keyId;
      }
    }
    return atEntity;
  };
  AccessTokenEntity2.isAccessTokenEntity = function(entity) {
    if (!entity) {
      return false;
    }
    return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity.hasOwnProperty("target") && (entity["credentialType"] === CredentialType.ACCESS_TOKEN || entity["credentialType"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
  };
  return AccessTokenEntity2;
}(CredentialEntity);

// node_modules/@azure/msal-common/dist/cache/entities/RefreshTokenEntity.js
var RefreshTokenEntity = function(_super) {
  __extends(RefreshTokenEntity2, _super);
  function RefreshTokenEntity2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RefreshTokenEntity2.createRefreshTokenEntity = function(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash) {
    var rtEntity = new RefreshTokenEntity2();
    rtEntity.clientId = clientId;
    rtEntity.credentialType = CredentialType.REFRESH_TOKEN;
    rtEntity.environment = environment;
    rtEntity.homeAccountId = homeAccountId;
    rtEntity.secret = refreshToken;
    rtEntity.userAssertionHash = userAssertionHash;
    if (familyId)
      rtEntity.familyId = familyId;
    return rtEntity;
  };
  RefreshTokenEntity2.isRefreshTokenEntity = function(entity) {
    if (!entity) {
      return false;
    }
    return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity["credentialType"] === CredentialType.REFRESH_TOKEN;
  };
  return RefreshTokenEntity2;
}(CredentialEntity);

// node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.js
var InteractionRequiredServerErrorMessage = [
  "interaction_required",
  "consent_required",
  "login_required"
];
var InteractionRequiredAuthSubErrorMessage = [
  "message_only",
  "additional_action",
  "basic_action",
  "user_password_expired",
  "consent_required"
];
var InteractionRequiredAuthErrorMessage = {
  noTokensFoundError: {
    code: "no_tokens_found",
    desc: "No refresh token found in the cache. Please sign-in."
  },
  native_account_unavailable: {
    code: "native_account_unavailable",
    desc: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API."
  }
};
var InteractionRequiredAuthError = function(_super) {
  __extends(InteractionRequiredAuthError2, _super);
  function InteractionRequiredAuthError2(errorCode, errorMessage, subError) {
    var _this = _super.call(this, errorCode, errorMessage, subError) || this;
    _this.name = "InteractionRequiredAuthError";
    Object.setPrototypeOf(_this, InteractionRequiredAuthError2.prototype);
    return _this;
  }
  InteractionRequiredAuthError2.isInteractionRequiredError = function(errorCode, errorString, subError) {
    var isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
    var isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
    var isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some(function(irErrorCode) {
      return errorString.indexOf(irErrorCode) > -1;
    });
    return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;
  };
  InteractionRequiredAuthError2.createNoTokensFoundError = function() {
    return new InteractionRequiredAuthError2(InteractionRequiredAuthErrorMessage.noTokensFoundError.code, InteractionRequiredAuthErrorMessage.noTokensFoundError.desc);
  };
  InteractionRequiredAuthError2.createNativeAccountUnavailableError = function() {
    return new InteractionRequiredAuthError2(InteractionRequiredAuthErrorMessage.native_account_unavailable.code, InteractionRequiredAuthErrorMessage.native_account_unavailable.desc);
  };
  return InteractionRequiredAuthError2;
}(AuthError);

// node_modules/@azure/msal-common/dist/cache/entities/CacheRecord.js
var CacheRecord = function() {
  function CacheRecord2(accountEntity, idTokenEntity, accessTokenEntity, refreshTokenEntity, appMetadataEntity) {
    this.account = accountEntity || null;
    this.idToken = idTokenEntity || null;
    this.accessToken = accessTokenEntity || null;
    this.refreshToken = refreshTokenEntity || null;
    this.appMetadata = appMetadataEntity || null;
  }
  return CacheRecord2;
}();

// node_modules/@azure/msal-common/dist/utils/ProtocolUtils.js
var ProtocolUtils = function() {
  function ProtocolUtils2() {
  }
  ProtocolUtils2.setRequestState = function(cryptoObj, userState, meta) {
    var libraryState = ProtocolUtils2.generateLibraryState(cryptoObj, meta);
    return !StringUtils.isEmpty(userState) ? "" + libraryState + Constants.RESOURCE_DELIM + userState : libraryState;
  };
  ProtocolUtils2.generateLibraryState = function(cryptoObj, meta) {
    if (!cryptoObj) {
      throw ClientAuthError.createNoCryptoObjectError("generateLibraryState");
    }
    var stateObj = {
      id: cryptoObj.createNewGuid()
    };
    if (meta) {
      stateObj.meta = meta;
    }
    var stateString = JSON.stringify(stateObj);
    return cryptoObj.base64Encode(stateString);
  };
  ProtocolUtils2.parseRequestState = function(cryptoObj, state) {
    if (!cryptoObj) {
      throw ClientAuthError.createNoCryptoObjectError("parseRequestState");
    }
    if (StringUtils.isEmpty(state)) {
      throw ClientAuthError.createInvalidStateError(state, "Null, undefined or empty state");
    }
    try {
      var splitState = state.split(Constants.RESOURCE_DELIM);
      var libraryState = splitState[0];
      var userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;
      var libraryStateString = cryptoObj.base64Decode(libraryState);
      var libraryStateObj = JSON.parse(libraryStateString);
      return {
        userRequestState: !StringUtils.isEmpty(userState) ? userState : Constants.EMPTY_STRING,
        libraryState: libraryStateObj
      };
    } catch (e) {
      throw ClientAuthError.createInvalidStateError(state, e);
    }
  };
  return ProtocolUtils2;
}();

// node_modules/@azure/msal-common/dist/url/UrlString.js
var UrlString = function() {
  function UrlString2(url) {
    this._urlString = url;
    if (StringUtils.isEmpty(this._urlString)) {
      throw ClientConfigurationError.createUrlEmptyError();
    }
    if (StringUtils.isEmpty(this.getHash())) {
      this._urlString = UrlString2.canonicalizeUri(url);
    }
  }
  Object.defineProperty(UrlString2.prototype, "urlString", {
    get: function() {
      return this._urlString;
    },
    enumerable: false,
    configurable: true
  });
  UrlString2.canonicalizeUri = function(url) {
    if (url) {
      var lowerCaseUrl = url.toLowerCase();
      if (StringUtils.endsWith(lowerCaseUrl, "?")) {
        lowerCaseUrl = lowerCaseUrl.slice(0, -1);
      } else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
        lowerCaseUrl = lowerCaseUrl.slice(0, -2);
      }
      if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
        lowerCaseUrl += "/";
      }
      return lowerCaseUrl;
    }
    return url;
  };
  UrlString2.prototype.validateAsUri = function() {
    var components;
    try {
      components = this.getUrlComponents();
    } catch (e) {
      throw ClientConfigurationError.createUrlParseError(e);
    }
    if (!components.HostNameAndPort || !components.PathSegments) {
      throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
    }
    if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
      throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);
    }
  };
  UrlString2.appendQueryString = function(url, queryString) {
    if (StringUtils.isEmpty(queryString)) {
      return url;
    }
    return url.indexOf("?") < 0 ? url + "?" + queryString : url + "&" + queryString;
  };
  UrlString2.removeHashFromUrl = function(url) {
    return UrlString2.canonicalizeUri(url.split("#")[0]);
  };
  UrlString2.prototype.replaceTenantPath = function(tenantId) {
    var urlObject = this.getUrlComponents();
    var pathArray = urlObject.PathSegments;
    if (tenantId && (pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS))) {
      pathArray[0] = tenantId;
    }
    return UrlString2.constructAuthorityUriFromObject(urlObject);
  };
  UrlString2.prototype.getHash = function() {
    return UrlString2.parseHash(this.urlString);
  };
  UrlString2.prototype.getUrlComponents = function() {
    var regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
    var match = this.urlString.match(regEx);
    if (!match) {
      throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
    }
    var urlComponents = {
      Protocol: match[1],
      HostNameAndPort: match[4],
      AbsolutePath: match[5],
      QueryString: match[7]
    };
    var pathSegments = urlComponents.AbsolutePath.split("/");
    pathSegments = pathSegments.filter(function(val) {
      return val && val.length > 0;
    });
    urlComponents.PathSegments = pathSegments;
    if (!StringUtils.isEmpty(urlComponents.QueryString) && urlComponents.QueryString.endsWith("/")) {
      urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
    }
    return urlComponents;
  };
  UrlString2.getDomainFromUrl = function(url) {
    var regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
    var match = url.match(regEx);
    if (!match) {
      throw ClientConfigurationError.createUrlParseError("Given url string: " + url);
    }
    return match[2];
  };
  UrlString2.getAbsoluteUrl = function(relativeUrl, baseUrl) {
    if (relativeUrl[0] === Constants.FORWARD_SLASH) {
      var url = new UrlString2(baseUrl);
      var baseComponents = url.getUrlComponents();
      return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl;
    }
    return relativeUrl;
  };
  UrlString2.parseHash = function(hashString) {
    var hashIndex1 = hashString.indexOf("#");
    var hashIndex2 = hashString.indexOf("#/");
    if (hashIndex2 > -1) {
      return hashString.substring(hashIndex2 + 2);
    } else if (hashIndex1 > -1) {
      return hashString.substring(hashIndex1 + 1);
    }
    return Constants.EMPTY_STRING;
  };
  UrlString2.parseQueryString = function(queryString) {
    var queryIndex1 = queryString.indexOf("?");
    var queryIndex2 = queryString.indexOf("/?");
    if (queryIndex2 > -1) {
      return queryString.substring(queryIndex2 + 2);
    } else if (queryIndex1 > -1) {
      return queryString.substring(queryIndex1 + 1);
    }
    return Constants.EMPTY_STRING;
  };
  UrlString2.constructAuthorityUriFromObject = function(urlObject) {
    return new UrlString2(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
  };
  UrlString2.getDeserializedHash = function(hash) {
    if (StringUtils.isEmpty(hash)) {
      return {};
    }
    var parsedHash = UrlString2.parseHash(hash);
    var deserializedHash = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedHash) ? hash : parsedHash);
    if (!deserializedHash) {
      throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));
    }
    return deserializedHash;
  };
  UrlString2.getDeserializedQueryString = function(query) {
    if (StringUtils.isEmpty(query)) {
      return {};
    }
    var parsedQueryString = UrlString2.parseQueryString(query);
    var deserializedQueryString = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedQueryString) ? query : parsedQueryString);
    if (!deserializedQueryString) {
      throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedQueryString));
    }
    return deserializedQueryString;
  };
  UrlString2.hashContainsKnownProperties = function(hash) {
    if (StringUtils.isEmpty(hash) || hash.indexOf("=") < 0) {
      return false;
    }
    var parameters = UrlString2.getDeserializedHash(hash);
    return !!(parameters.code || parameters.error_description || parameters.error || parameters.state);
  };
  return UrlString2;
}();

// node_modules/@azure/msal-common/dist/crypto/PopTokenGenerator.js
var KeyLocation;
(function(KeyLocation2) {
  KeyLocation2["SW"] = "sw";
  KeyLocation2["UHW"] = "uhw";
})(KeyLocation || (KeyLocation = {}));
var PopTokenGenerator = function() {
  function PopTokenGenerator2(cryptoUtils) {
    this.cryptoUtils = cryptoUtils;
  }
  PopTokenGenerator2.prototype.generateCnf = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      var reqCnf, reqCnfString, _a;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            return [4, this.generateKid(request)];
          case 1:
            reqCnf = _b.sent();
            reqCnfString = this.cryptoUtils.base64Encode(JSON.stringify(reqCnf));
            _a = {
              kid: reqCnf.kid,
              reqCnfString
            };
            return [4, this.cryptoUtils.hashString(reqCnfString)];
          case 2:
            return [2, (_a.reqCnfHash = _b.sent(), _a)];
        }
      });
    });
  };
  PopTokenGenerator2.prototype.generateKid = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      var kidThumbprint;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.cryptoUtils.getPublicKeyThumbprint(request)];
          case 1:
            kidThumbprint = _a.sent();
            return [2, {
              kid: kidThumbprint,
              xms_ksl: KeyLocation.SW
            }];
        }
      });
    });
  };
  PopTokenGenerator2.prototype.signPopToken = function(accessToken, keyId, request) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        return [2, this.signPayload(accessToken, keyId, request)];
      });
    });
  };
  PopTokenGenerator2.prototype.signPayload = function(payload, keyId, request, claims) {
    return __awaiter(this, void 0, void 0, function() {
      var resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, resourceUrlString, resourceUrlComponents;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            resourceRequestMethod = request.resourceRequestMethod, resourceRequestUri = request.resourceRequestUri, shrClaims = request.shrClaims, shrNonce = request.shrNonce;
            resourceUrlString = resourceRequestUri ? new UrlString(resourceRequestUri) : void 0;
            resourceUrlComponents = resourceUrlString === null || resourceUrlString === void 0 ? void 0 : resourceUrlString.getUrlComponents();
            return [4, this.cryptoUtils.signJwt(__assign({ at: payload, ts: TimeUtils.nowSeconds(), m: resourceRequestMethod === null || resourceRequestMethod === void 0 ? void 0 : resourceRequestMethod.toUpperCase(), u: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.HostNameAndPort, nonce: shrNonce || this.cryptoUtils.createNewGuid(), p: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.AbsolutePath, q: (resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.QueryString) ? [[], resourceUrlComponents.QueryString] : void 0, client_claims: shrClaims || void 0 }, claims), keyId, request.correlationId)];
          case 1:
            return [2, _a.sent()];
        }
      });
    });
  };
  return PopTokenGenerator2;
}();

// node_modules/@azure/msal-common/dist/cache/entities/AppMetadataEntity.js
var AppMetadataEntity = function() {
  function AppMetadataEntity2() {
  }
  AppMetadataEntity2.prototype.generateAppMetadataKey = function() {
    return AppMetadataEntity2.generateAppMetadataCacheKey(this.environment, this.clientId);
  };
  AppMetadataEntity2.generateAppMetadataCacheKey = function(environment, clientId) {
    var appMetaDataKeyArray = [
      APP_METADATA,
      environment,
      clientId
    ];
    return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
  };
  AppMetadataEntity2.createAppMetadataEntity = function(clientId, environment, familyId) {
    var appMetadata = new AppMetadataEntity2();
    appMetadata.clientId = clientId;
    appMetadata.environment = environment;
    if (familyId) {
      appMetadata.familyId = familyId;
    }
    return appMetadata;
  };
  AppMetadataEntity2.isAppMetadataEntity = function(key, entity) {
    if (!entity) {
      return false;
    }
    return key.indexOf(APP_METADATA) === 0 && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("environment");
  };
  return AppMetadataEntity2;
}();

// node_modules/@azure/msal-common/dist/cache/persistence/TokenCacheContext.js
var TokenCacheContext = function() {
  function TokenCacheContext2(tokenCache, hasChanged) {
    this.cache = tokenCache;
    this.hasChanged = hasChanged;
  }
  Object.defineProperty(TokenCacheContext2.prototype, "cacheHasChanged", {
    get: function() {
      return this.hasChanged;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TokenCacheContext2.prototype, "tokenCache", {
    get: function() {
      return this.cache;
    },
    enumerable: false,
    configurable: true
  });
  return TokenCacheContext2;
}();

// node_modules/@azure/msal-common/dist/response/ResponseHandler.js
var ResponseHandler = function() {
  function ResponseHandler2(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin) {
    this.clientId = clientId;
    this.cacheStorage = cacheStorage;
    this.cryptoObj = cryptoObj;
    this.logger = logger;
    this.serializableCache = serializableCache;
    this.persistencePlugin = persistencePlugin;
  }
  ResponseHandler2.prototype.validateServerAuthorizationCodeResponse = function(serverResponseHash, cachedState, cryptoObj) {
    if (!serverResponseHash.state || !cachedState) {
      throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError("Server State") : ClientAuthError.createStateNotFoundError("Cached State");
    }
    if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {
      throw ClientAuthError.createStateMismatchError();
    }
    if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {
      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {
        throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);
      }
      throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);
    }
    if (serverResponseHash.client_info) {
      buildClientInfo(serverResponseHash.client_info, cryptoObj);
    }
  };
  ResponseHandler2.prototype.validateTokenResponse = function(serverResponse) {
    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror);
      }
      var errString = serverResponse.error_codes + " - [" + serverResponse.timestamp + "]: " + serverResponse.error_description + " - Correlation ID: " + serverResponse.correlation_id + " - Trace ID: " + serverResponse.trace_id;
      throw new ServerError(serverResponse.error, errString, serverResponse.suberror);
    }
  };
  ResponseHandler2.prototype.handleServerTokenResponse = function(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {
    return __awaiter(this, void 0, void 0, function() {
      var idTokenObj, authTime, requestStateObj, cacheRecord, cacheContext, key, account;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (serverTokenResponse.id_token) {
              idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);
              if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {
                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {
                  throw ClientAuthError.createNonceMismatchError();
                }
              }
              if (request.maxAge || request.maxAge === 0) {
                authTime = idTokenObj.claims.auth_time;
                if (!authTime) {
                  throw ClientAuthError.createAuthTimeNotFoundError();
                }
                AuthToken.checkMaxAge(authTime, request.maxAge);
              }
            }
            this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);
            if (!!authCodePayload && !!authCodePayload.state) {
              requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
            }
            serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || void 0;
            cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 5, 8]);
            if (!(this.persistencePlugin && this.serializableCache))
              return [3, 3];
            this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
            cacheContext = new TokenCacheContext(this.serializableCache, true);
            return [4, this.persistencePlugin.beforeCacheAccess(cacheContext)];
          case 2:
            _a.sent();
            _a.label = 3;
          case 3:
            if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {
              key = cacheRecord.account.generateAccountKey();
              account = this.cacheStorage.getAccount(key);
              if (!account) {
                this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
                return [2, ResponseHandler2.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, void 0, serverRequestId)];
              }
            }
            return [4, this.cacheStorage.saveCacheRecord(cacheRecord)];
          case 4:
            _a.sent();
            return [3, 8];
          case 5:
            if (!(this.persistencePlugin && this.serializableCache && cacheContext))
              return [3, 7];
            this.logger.verbose("Persistence enabled, calling afterCacheAccess");
            return [4, this.persistencePlugin.afterCacheAccess(cacheContext)];
          case 6:
            _a.sent();
            _a.label = 7;
          case 7:
            return [7];
          case 8:
            return [2, ResponseHandler2.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse.spa_code, serverRequestId)];
        }
      });
    });
  };
  ResponseHandler2.prototype.generateCacheRecord = function(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload) {
    var env = authority.getPreferredCache();
    if (StringUtils.isEmpty(env)) {
      throw ClientAuthError.createInvalidCacheEnvironmentError();
    }
    var cachedIdToken;
    var cachedAccount;
    if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {
      cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);
      cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);
    }
    var cachedAccessToken = null;
    if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {
      var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);
      var expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
      var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
      var refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || void 0;
      var tokenExpirationSeconds = reqTimestamp + expiresIn;
      var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
      var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : void 0;
      cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);
    }
    var cachedRefreshToken = null;
    if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {
      cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);
    }
    var cachedAppMetadata = null;
    if (!StringUtils.isEmpty(serverTokenResponse.foci)) {
      cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);
    }
    return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);
  };
  ResponseHandler2.prototype.generateAccountEntity = function(serverTokenResponse, idToken, authority, authCodePayload) {
    var authorityType = authority.authorityType;
    var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;
    var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING;
    if (authorityType === AuthorityType.Adfs) {
      this.logger.verbose("Authority type is ADFS, creating ADFS account");
      return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);
    }
    if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === "AAD") {
      throw ClientAuthError.createClientInfoEmptyError();
    }
    return serverTokenResponse.client_info ? AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) : AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);
  };
  ResponseHandler2.generateAuthenticationResult = function(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, code, requestId) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function() {
      var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;
      return __generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            accessToken = Constants.EMPTY_STRING;
            responseScopes = [];
            expiresOn = null;
            familyId = Constants.EMPTY_STRING;
            if (!cacheRecord.accessToken)
              return [3, 4];
            if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP))
              return [3, 2];
            popTokenGenerator = new PopTokenGenerator(cryptoObj);
            _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;
            if (!keyId) {
              throw ClientAuthError.createKeyIdMissingError();
            }
            return [4, popTokenGenerator.signPopToken(secret, keyId, request)];
          case 1:
            accessToken = _e.sent();
            return [3, 3];
          case 2:
            accessToken = cacheRecord.accessToken.secret;
            _e.label = 3;
          case 3:
            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1e3);
            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1e3);
            _e.label = 4;
          case 4:
            if (cacheRecord.appMetadata) {
              familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;
            }
            uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;
            tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;
            return [2, {
              authority: authority.canonicalAuthority,
              uniqueId: uid,
              tenantId: tid,
              scopes: responseScopes,
              account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,
              idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,
              idTokenClaims: idTokenObj ? idTokenObj.claims : {},
              accessToken,
              fromCache: fromTokenCache,
              expiresOn,
              correlationId: request.correlationId,
              requestId: requestId || Constants.EMPTY_STRING,
              extExpiresOn,
              familyId,
              tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,
              state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,
              cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,
              msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,
              code,
              fromNativeBroker: false
            }];
        }
      });
    });
  };
  return ResponseHandler2;
}();

// node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.js
var AuthorizationCodeClient = function(_super) {
  __extends(AuthorizationCodeClient2, _super);
  function AuthorizationCodeClient2(configuration) {
    var _this = _super.call(this, configuration) || this;
    _this.includeRedirectUri = true;
    return _this;
  }
  AuthorizationCodeClient2.prototype.getAuthCodeUrl = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      var queryString;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.createAuthCodeUrlQueryString(request)];
          case 1:
            queryString = _a.sent();
            return [2, UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString)];
        }
      });
    });
  };
  AuthorizationCodeClient2.prototype.acquireToken = function(request, authCodePayload) {
    var _a;
    return __awaiter(this, void 0, void 0, function() {
      var reqTimestamp, response, requestId, responseHandler;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            this.logger.info("in acquireToken call");
            if (!request || StringUtils.isEmpty(request.code)) {
              throw ClientAuthError.createTokenRequestCannotBeMadeError();
            }
            reqTimestamp = TimeUtils.nowSeconds();
            return [4, this.executeTokenRequest(this.authority, request)];
          case 1:
            response = _b.sent();
            requestId = (_a = response.headers) === null || _a === void 0 ? void 0 : _a[HeaderNames.X_MS_REQUEST_ID];
            responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
            responseHandler.validateTokenResponse(response.body);
            return [4, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, authCodePayload, void 0, void 0, void 0, requestId)];
          case 2:
            return [2, _b.sent()];
        }
      });
    });
  };
  AuthorizationCodeClient2.prototype.handleFragmentResponse = function(hashFragment, cachedState) {
    var responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);
    var hashUrlString = new UrlString(hashFragment);
    var serverParams = UrlString.getDeserializedHash(hashUrlString.getHash());
    responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);
    if (!serverParams.code) {
      throw ClientAuthError.createNoAuthCodeInServerResponseError();
    }
    return __assign(__assign({}, serverParams), {
      code: serverParams.code
    });
  };
  AuthorizationCodeClient2.prototype.getLogoutUri = function(logoutRequest) {
    if (!logoutRequest) {
      throw ClientConfigurationError.createEmptyLogoutRequestError();
    }
    var queryString = this.createLogoutUrlQueryString(logoutRequest);
    return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
  };
  AuthorizationCodeClient2.prototype.executeTokenRequest = function(authority, request) {
    return __awaiter(this, void 0, void 0, function() {
      var thumbprint, requestBody, queryParameters, ccsCredential, clientInfo, headers, endpoint;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            thumbprint = {
              clientId: this.config.authOptions.clientId,
              authority: authority.canonicalAuthority,
              scopes: request.scopes,
              claims: request.claims,
              authenticationScheme: request.authenticationScheme,
              resourceRequestMethod: request.resourceRequestMethod,
              resourceRequestUri: request.resourceRequestUri,
              shrClaims: request.shrClaims,
              sshKid: request.sshKid
            };
            return [4, this.createTokenRequestBody(request)];
          case 1:
            requestBody = _a.sent();
            queryParameters = this.createTokenQueryParameters(request);
            ccsCredential = void 0;
            if (request.clientInfo) {
              try {
                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);
                ccsCredential = {
                  credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,
                  type: CcsCredentialType.HOME_ACCOUNT_ID
                };
              } catch (e) {
                this.logger.verbose("Could not parse client info for CCS Header: " + e);
              }
            }
            headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
            endpoint = StringUtils.isEmpty(queryParameters) ? authority.tokenEndpoint : authority.tokenEndpoint + "?" + queryParameters;
            return [2, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];
        }
      });
    });
  };
  AuthorizationCodeClient2.prototype.createTokenQueryParameters = function(request) {
    var parameterBuilder = new RequestParameterBuilder();
    if (request.tokenQueryParameters) {
      parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);
    }
    return parameterBuilder.createQueryString();
  };
  AuthorizationCodeClient2.prototype.createTokenRequestBody = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      var parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, correlationId, ccsCred, clientInfo, clientInfo;
      var _a;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            parameterBuilder = new RequestParameterBuilder();
            parameterBuilder.addClientId(this.config.authOptions.clientId);
            if (!this.includeRedirectUri) {
              RequestValidator.validateRedirectUri(request.redirectUri);
            } else {
              parameterBuilder.addRedirectUri(request.redirectUri);
            }
            parameterBuilder.addScopes(request.scopes);
            parameterBuilder.addAuthorizationCode(request.code);
            parameterBuilder.addLibraryInfo(this.config.libraryInfo);
            parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
            parameterBuilder.addThrottling();
            if (this.serverTelemetryManager) {
              parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
            }
            if (request.codeVerifier) {
              parameterBuilder.addCodeVerifier(request.codeVerifier);
            }
            if (this.config.clientCredentials.clientSecret) {
              parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
            }
            if (this.config.clientCredentials.clientAssertion) {
              clientAssertion = this.config.clientCredentials.clientAssertion;
              parameterBuilder.addClientAssertion(clientAssertion.assertion);
              parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
            }
            parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);
            parameterBuilder.addClientInfo();
            if (!(request.authenticationScheme === AuthenticationScheme.POP))
              return [3, 2];
            popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
            return [4, popTokenGenerator.generateCnf(request)];
          case 1:
            reqCnfData = _b.sent();
            parameterBuilder.addPopToken(reqCnfData.reqCnfString);
            return [3, 3];
          case 2:
            if (request.authenticationScheme === AuthenticationScheme.SSH) {
              if (request.sshJwk) {
                parameterBuilder.addSshJwk(request.sshJwk);
              } else {
                throw ClientConfigurationError.createMissingSshJwkError();
              }
            }
            _b.label = 3;
          case 3:
            correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
            parameterBuilder.addCorrelationId(correlationId);
            if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
            }
            ccsCred = void 0;
            if (request.clientInfo) {
              try {
                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);
                ccsCred = {
                  credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,
                  type: CcsCredentialType.HOME_ACCOUNT_ID
                };
              } catch (e) {
                this.logger.verbose("Could not parse client info for CCS Header: " + e);
              }
            } else {
              ccsCred = request.ccsCredential;
            }
            if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
              switch (ccsCred.type) {
                case CcsCredentialType.HOME_ACCOUNT_ID:
                  try {
                    clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                    parameterBuilder.addCcsOid(clientInfo);
                  } catch (e) {
                    this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
                  }
                  break;
                case CcsCredentialType.UPN:
                  parameterBuilder.addCcsUpn(ccsCred.credential);
                  break;
              }
            }
            if (request.tokenBodyParameters) {
              parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);
            }
            if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {
              parameterBuilder.addExtraQueryParameters((_a = {}, _a[AADServerParamKeys.RETURN_SPA_CODE] = "1", _a));
            }
            return [2, parameterBuilder.createQueryString()];
        }
      });
    });
  };
  AuthorizationCodeClient2.prototype.createAuthCodeUrlQueryString = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      var parameterBuilder, requestScopes, correlationId, accountSid, accountLoginHintClaim, clientInfo, clientInfo, clientInfo, popTokenGenerator, reqCnfData;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            parameterBuilder = new RequestParameterBuilder();
            parameterBuilder.addClientId(this.config.authOptions.clientId);
            requestScopes = __spreadArrays(request.scopes || [], request.extraScopesToConsent || []);
            parameterBuilder.addScopes(requestScopes);
            parameterBuilder.addRedirectUri(request.redirectUri);
            correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
            parameterBuilder.addCorrelationId(correlationId);
            parameterBuilder.addResponseMode(request.responseMode);
            parameterBuilder.addResponseTypeCode();
            parameterBuilder.addLibraryInfo(this.config.libraryInfo);
            parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
            parameterBuilder.addClientInfo();
            if (request.codeChallenge && request.codeChallengeMethod) {
              parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);
            }
            if (request.prompt) {
              parameterBuilder.addPrompt(request.prompt);
            }
            if (request.domainHint) {
              parameterBuilder.addDomainHint(request.domainHint);
            }
            if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
              if (request.sid && request.prompt === PromptValue.NONE) {
                this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
                parameterBuilder.addSid(request.sid);
              } else if (request.account) {
                accountSid = this.extractAccountSid(request.account);
                accountLoginHintClaim = this.extractLoginHint(request.account);
                if (accountLoginHintClaim) {
                  this.logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
                  parameterBuilder.addLoginHint(accountLoginHintClaim);
                  try {
                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
                    parameterBuilder.addCcsOid(clientInfo);
                  } catch (e) {
                    this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                  }
                } else if (accountSid && request.prompt === PromptValue.NONE) {
                  this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
                  parameterBuilder.addSid(accountSid);
                  try {
                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
                    parameterBuilder.addCcsOid(clientInfo);
                  } catch (e) {
                    this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                  }
                } else if (request.loginHint) {
                  this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
                  parameterBuilder.addLoginHint(request.loginHint);
                  parameterBuilder.addCcsUpn(request.loginHint);
                } else if (request.account.username) {
                  this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
                  parameterBuilder.addLoginHint(request.account.username);
                  try {
                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
                    parameterBuilder.addCcsOid(clientInfo);
                  } catch (e) {
                    this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                  }
                }
              } else if (request.loginHint) {
                this.logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
                parameterBuilder.addLoginHint(request.loginHint);
                parameterBuilder.addCcsUpn(request.loginHint);
              }
            } else {
              this.logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
            }
            if (request.nonce) {
              parameterBuilder.addNonce(request.nonce);
            }
            if (request.state) {
              parameterBuilder.addState(request.state);
            }
            if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
            }
            if (request.extraQueryParameters) {
              parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);
            }
            if (!request.nativeBroker)
              return [3, 2];
            parameterBuilder.addNativeBroker();
            if (!(request.authenticationScheme === AuthenticationScheme.POP))
              return [3, 2];
            popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
            return [4, popTokenGenerator.generateCnf(request)];
          case 1:
            reqCnfData = _a.sent();
            parameterBuilder.addPopToken(reqCnfData.reqCnfHash);
            _a.label = 2;
          case 2:
            return [2, parameterBuilder.createQueryString()];
        }
      });
    });
  };
  AuthorizationCodeClient2.prototype.createLogoutUrlQueryString = function(request) {
    var parameterBuilder = new RequestParameterBuilder();
    if (request.postLogoutRedirectUri) {
      parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);
    }
    if (request.correlationId) {
      parameterBuilder.addCorrelationId(request.correlationId);
    }
    if (request.idTokenHint) {
      parameterBuilder.addIdTokenHint(request.idTokenHint);
    }
    if (request.state) {
      parameterBuilder.addState(request.state);
    }
    if (request.logoutHint) {
      parameterBuilder.addLogoutHint(request.logoutHint);
    }
    if (request.extraQueryParameters) {
      parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);
    }
    return parameterBuilder.createQueryString();
  };
  AuthorizationCodeClient2.prototype.extractAccountSid = function(account) {
    var _a;
    return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.sid) || null;
  };
  AuthorizationCodeClient2.prototype.extractLoginHint = function(account) {
    var _a;
    return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.login_hint) || null;
  };
  return AuthorizationCodeClient2;
}(BaseClient);

// node_modules/@azure/msal-common/dist/client/DeviceCodeClient.js
var DeviceCodeClient = function(_super) {
  __extends(DeviceCodeClient2, _super);
  function DeviceCodeClient2(configuration) {
    return _super.call(this, configuration) || this;
  }
  DeviceCodeClient2.prototype.acquireToken = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      var deviceCodeResponse, reqTimestamp, response, responseHandler;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.getDeviceCode(request)];
          case 1:
            deviceCodeResponse = _a.sent();
            request.deviceCodeCallback(deviceCodeResponse);
            reqTimestamp = TimeUtils.nowSeconds();
            return [4, this.acquireTokenWithDeviceCode(request, deviceCodeResponse)];
          case 2:
            response = _a.sent();
            responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
            responseHandler.validateTokenResponse(response);
            return [4, responseHandler.handleServerTokenResponse(response, this.authority, reqTimestamp, request)];
          case 3:
            return [2, _a.sent()];
        }
      });
    });
  };
  DeviceCodeClient2.prototype.getDeviceCode = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      var queryString, headers, thumbprint;
      return __generator(this, function(_a) {
        queryString = this.createQueryString(request);
        headers = this.createTokenRequestHeaders();
        thumbprint = {
          clientId: this.config.authOptions.clientId,
          authority: request.authority,
          scopes: request.scopes,
          claims: request.claims,
          authenticationScheme: request.authenticationScheme,
          resourceRequestMethod: request.resourceRequestMethod,
          resourceRequestUri: request.resourceRequestUri,
          shrClaims: request.shrClaims,
          sshKid: request.sshKid
        };
        return [2, this.executePostRequestToDeviceCodeEndpoint(this.authority.deviceCodeEndpoint, queryString, headers, thumbprint)];
      });
    });
  };
  DeviceCodeClient2.prototype.executePostRequestToDeviceCodeEndpoint = function(deviceCodeEndpoint, queryString, headers, thumbprint) {
    return __awaiter(this, void 0, void 0, function() {
      var _a, userCode, deviceCode, verificationUri, expiresIn, interval, message;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            return [4, this.networkManager.sendPostRequest(thumbprint, deviceCodeEndpoint, {
              body: queryString,
              headers,
              proxyUrl: this.config.systemOptions.proxyUrl
            })];
          case 1:
            _a = _b.sent().body, userCode = _a.user_code, deviceCode = _a.device_code, verificationUri = _a.verification_uri, expiresIn = _a.expires_in, interval = _a.interval, message = _a.message;
            return [2, {
              userCode,
              deviceCode,
              verificationUri,
              expiresIn,
              interval,
              message
            }];
        }
      });
    });
  };
  DeviceCodeClient2.prototype.createQueryString = function(request) {
    var parameterBuilder = new RequestParameterBuilder();
    parameterBuilder.addScopes(request.scopes);
    parameterBuilder.addClientId(this.config.authOptions.clientId);
    if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
    }
    return parameterBuilder.createQueryString();
  };
  DeviceCodeClient2.prototype.continuePolling = function(deviceCodeExpirationTime, userSpecifiedTimeout, userSpecifiedCancelFlag) {
    if (userSpecifiedCancelFlag) {
      this.logger.error("Token request cancelled by setting DeviceCodeRequest.cancel = true");
      throw ClientAuthError.createDeviceCodeCancelledError();
    } else if (userSpecifiedTimeout && userSpecifiedTimeout < deviceCodeExpirationTime && TimeUtils.nowSeconds() > userSpecifiedTimeout) {
      this.logger.error("User defined timeout for device code polling reached. The timeout was set for " + userSpecifiedTimeout);
      throw ClientAuthError.createUserTimeoutReachedError();
    } else if (TimeUtils.nowSeconds() > deviceCodeExpirationTime) {
      if (userSpecifiedTimeout) {
        this.logger.verbose("User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for " + userSpecifiedTimeout);
      }
      this.logger.error("Device code expired. Expiration time of device code was " + deviceCodeExpirationTime);
      throw ClientAuthError.createDeviceCodeExpiredError();
    }
    return true;
  };
  DeviceCodeClient2.prototype.acquireTokenWithDeviceCode = function(request, deviceCodeResponse) {
    return __awaiter(this, void 0, void 0, function() {
      var requestBody, headers, userSpecifiedTimeout, deviceCodeExpirationTime, pollingIntervalMilli, thumbprint, response;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            requestBody = this.createTokenRequestBody(request, deviceCodeResponse);
            headers = this.createTokenRequestHeaders();
            userSpecifiedTimeout = request.timeout ? TimeUtils.nowSeconds() + request.timeout : void 0;
            deviceCodeExpirationTime = TimeUtils.nowSeconds() + deviceCodeResponse.expiresIn;
            pollingIntervalMilli = deviceCodeResponse.interval * 1e3;
            _a.label = 1;
          case 1:
            if (!this.continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, request.cancel))
              return [3, 8];
            thumbprint = {
              clientId: this.config.authOptions.clientId,
              authority: request.authority,
              scopes: request.scopes,
              claims: request.claims,
              authenticationScheme: request.authenticationScheme,
              resourceRequestMethod: request.resourceRequestMethod,
              resourceRequestUri: request.resourceRequestUri,
              shrClaims: request.shrClaims,
              sshKid: request.sshKid
            };
            return [4, this.executePostToTokenEndpoint(this.authority.tokenEndpoint, requestBody, headers, thumbprint)];
          case 2:
            response = _a.sent();
            if (!(response.body && response.body.error))
              return [3, 6];
            if (!(response.body.error === Constants.AUTHORIZATION_PENDING))
              return [3, 4];
            this.logger.info("Authorization pending. Continue polling.");
            return [4, TimeUtils.delay(pollingIntervalMilli)];
          case 3:
            _a.sent();
            return [3, 5];
          case 4:
            this.logger.info("Unexpected error in polling from the server");
            throw ServerError.createPostRequestFailed(response.body.error);
          case 5:
            return [3, 7];
          case 6:
            this.logger.verbose("Authorization completed successfully. Polling stopped.");
            return [2, response.body];
          case 7:
            return [3, 1];
          case 8:
            this.logger.error("Polling stopped for unknown reasons.");
            throw ClientAuthError.createDeviceCodeUnknownError();
        }
      });
    });
  };
  DeviceCodeClient2.prototype.createTokenRequestBody = function(request, deviceCodeResponse) {
    var requestParameters = new RequestParameterBuilder();
    requestParameters.addScopes(request.scopes);
    requestParameters.addClientId(this.config.authOptions.clientId);
    requestParameters.addGrantType(GrantType.DEVICE_CODE_GRANT);
    requestParameters.addDeviceCode(deviceCodeResponse.deviceCode);
    var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
    requestParameters.addCorrelationId(correlationId);
    requestParameters.addClientInfo();
    requestParameters.addLibraryInfo(this.config.libraryInfo);
    requestParameters.addApplicationTelemetry(this.config.telemetry.application);
    requestParameters.addThrottling();
    if (this.serverTelemetryManager) {
      requestParameters.addServerTelemetry(this.serverTelemetryManager);
    }
    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
      requestParameters.addClaims(request.claims, this.config.authOptions.clientCapabilities);
    }
    return requestParameters.createQueryString();
  };
  return DeviceCodeClient2;
}(BaseClient);

// node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceEvent.js
var PerformanceEvents;
(function(PerformanceEvents2) {
  PerformanceEvents2["AcquireTokenByCode"] = "acquireTokenByCode";
  PerformanceEvents2["AcquireTokenByRefreshToken"] = "acquireTokenByRefreshToken";
  PerformanceEvents2["AcquireTokenSilent"] = "acquireTokenSilent";
  PerformanceEvents2["AcquireTokenSilentAsync"] = "acquireTokenSilentAsync";
  PerformanceEvents2["AcquireTokenPopup"] = "acquireTokenPopup";
  PerformanceEvents2["CryptoOptsGetPublicKeyThumbprint"] = "cryptoOptsGetPublicKeyThumbprint";
  PerformanceEvents2["CryptoOptsSignJwt"] = "cryptoOptsSignJwt";
  PerformanceEvents2["SilentCacheClientAcquireToken"] = "silentCacheClientAcquireToken";
  PerformanceEvents2["SilentIframeClientAcquireToken"] = "silentIframeClientAcquireToken";
  PerformanceEvents2["SilentRefreshClientAcquireToken"] = "silentRefreshClientAcquireToken";
  PerformanceEvents2["SsoSilent"] = "ssoSilent";
  PerformanceEvents2["StandardInteractionClientGetDiscoveredAuthority"] = "standardInteractionClientGetDiscoveredAuthority";
  PerformanceEvents2["FetchAccountIdWithNativeBroker"] = "fetchAccountIdWithNativeBroker";
  PerformanceEvents2["NativeInteractionClientAcquireToken"] = "nativeInteractionClientAcquireToken";
  PerformanceEvents2["BaseClientCreateTokenRequestHeaders"] = "baseClientCreateTokenRequestHeaders";
  PerformanceEvents2["BrokerHandhshake"] = "brokerHandshake";
  PerformanceEvents2["AcquireTokenByRefreshTokenInBroker"] = "acquireTokenByRefreshTokenInBroker";
  PerformanceEvents2["AcquireTokenByBroker"] = "acquireTokenByBroker";
  PerformanceEvents2["RefreshTokenClientExecuteTokenRequest"] = "refreshTokenClientExecuteTokenRequest";
  PerformanceEvents2["RefreshTokenClientAcquireToken"] = "refreshTokenClientAcquireToken";
  PerformanceEvents2["RefreshTokenClientAcquireTokenWithCachedRefreshToken"] = "refreshTokenClientAcquireTokenWithCachedRefreshToken";
})(PerformanceEvents || (PerformanceEvents = {}));
var PerformanceEventStatus;
(function(PerformanceEventStatus2) {
  PerformanceEventStatus2[PerformanceEventStatus2["NotStarted"] = 0] = "NotStarted";
  PerformanceEventStatus2[PerformanceEventStatus2["InProgress"] = 1] = "InProgress";
  PerformanceEventStatus2[PerformanceEventStatus2["Completed"] = 2] = "Completed";
})(PerformanceEventStatus || (PerformanceEventStatus = {}));

// node_modules/@azure/msal-common/dist/client/RefreshTokenClient.js
var RefreshTokenClient = function(_super) {
  __extends(RefreshTokenClient2, _super);
  function RefreshTokenClient2(configuration, performanceClient) {
    return _super.call(this, configuration, performanceClient) || this;
  }
  RefreshTokenClient2.prototype.acquireToken = function(request) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function() {
      var atsMeasurement, reqTimestamp, response, requestId, responseHandler;
      var _this = this;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            atsMeasurement = (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.startMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);
            this.logger.verbose("RefreshTokenClientAcquireToken called", request.correlationId);
            reqTimestamp = TimeUtils.nowSeconds();
            return [4, this.executeTokenRequest(request, this.authority)];
          case 1:
            response = _c.sent();
            requestId = (_b = response.headers) === null || _b === void 0 ? void 0 : _b[HeaderNames.X_MS_REQUEST_ID];
            responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
            responseHandler.validateTokenResponse(response.body);
            return [2, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, void 0, void 0, true, request.forceCache, requestId).then(function(result) {
              var _a2;
              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
                success: true,
                refreshTokenSize: ((_a2 = response.body.refresh_token) === null || _a2 === void 0 ? void 0 : _a2.length) || 0
              });
              return result;
            }).catch(function(error) {
              _this.logger.verbose("Error in fetching refresh token", request.correlationId);
              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
                errorCode: error.errorCode,
                subErrorCode: error.subError,
                success: false,
                refreshTokenSize: void 0
              });
              throw error;
            })];
        }
      });
    });
  };
  RefreshTokenClient2.prototype.acquireTokenByRefreshToken = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      var isFOCI, noFamilyRTInCache, clientMismatchErrorWithFamilyRT;
      return __generator(this, function(_a) {
        if (!request) {
          throw ClientConfigurationError.createEmptyTokenRequestError();
        }
        if (!request.account) {
          throw ClientAuthError.createNoAccountInSilentRequestError();
        }
        isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment, this.config.authOptions.clientId);
        if (isFOCI) {
          try {
            return [2, this.acquireTokenWithCachedRefreshToken(request, true)];
          } catch (e) {
            noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === InteractionRequiredAuthErrorMessage.noTokensFoundError.code;
            clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
            if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
              return [2, this.acquireTokenWithCachedRefreshToken(request, false)];
            } else {
              throw e;
            }
          }
        }
        return [2, this.acquireTokenWithCachedRefreshToken(request, false)];
      });
    });
  };
  RefreshTokenClient2.prototype.acquireTokenWithCachedRefreshToken = function(request, foci) {
    var _a;
    return __awaiter(this, void 0, void 0, function() {
      var atsMeasurement, refreshToken, refreshTokenRequest;
      return __generator(this, function(_b) {
        atsMeasurement = (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.startMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
        this.logger.verbose("RefreshTokenClientAcquireTokenWithCachedRefreshToken called", request.correlationId);
        refreshToken = this.cacheManager.readRefreshTokenFromCache(this.config.authOptions.clientId, request.account, foci);
        if (!refreshToken) {
          atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.discardMeasurement();
          throw InteractionRequiredAuthError.createNoTokensFoundError();
        }
        atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
          success: true
        });
        refreshTokenRequest = __assign(__assign({}, request), { refreshToken: refreshToken.secret, authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER, ccsCredential: {
          credential: request.account.homeAccountId,
          type: CcsCredentialType.HOME_ACCOUNT_ID
        } });
        return [2, this.acquireToken(refreshTokenRequest)];
      });
    });
  };
  RefreshTokenClient2.prototype.executeTokenRequest = function(request, authority) {
    var _a;
    return __awaiter(this, void 0, void 0, function() {
      var acquireTokenMeasurement, requestBody, queryParameters, headers, thumbprint, endpoint;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            acquireTokenMeasurement = (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.startMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
            return [4, this.createTokenRequestBody(request)];
          case 1:
            requestBody = _b.sent();
            queryParameters = this.createTokenQueryParameters(request);
            headers = this.createTokenRequestHeaders(request.ccsCredential);
            thumbprint = {
              clientId: this.config.authOptions.clientId,
              authority: authority.canonicalAuthority,
              scopes: request.scopes,
              claims: request.claims,
              authenticationScheme: request.authenticationScheme,
              resourceRequestMethod: request.resourceRequestMethod,
              resourceRequestUri: request.resourceRequestUri,
              shrClaims: request.shrClaims,
              sshKid: request.sshKid
            };
            endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParameters);
            return [2, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint).then(function(result) {
              acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                success: true
              });
              return result;
            }).catch(function(error) {
              acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                success: false
              });
              throw error;
            })];
        }
      });
    });
  };
  RefreshTokenClient2.prototype.createTokenQueryParameters = function(request) {
    var parameterBuilder = new RequestParameterBuilder();
    if (request.tokenQueryParameters) {
      parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);
    }
    return parameterBuilder.createQueryString();
  };
  RefreshTokenClient2.prototype.createTokenRequestBody = function(request) {
    var _a;
    return __awaiter(this, void 0, void 0, function() {
      var correlationId, acquireTokenMeasurement, parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, clientInfo;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            correlationId = request.correlationId;
            acquireTokenMeasurement = (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.startMeasurement(PerformanceEvents.BaseClientCreateTokenRequestHeaders, correlationId);
            parameterBuilder = new RequestParameterBuilder();
            parameterBuilder.addClientId(this.config.authOptions.clientId);
            parameterBuilder.addScopes(request.scopes);
            parameterBuilder.addGrantType(GrantType.REFRESH_TOKEN_GRANT);
            parameterBuilder.addClientInfo();
            parameterBuilder.addLibraryInfo(this.config.libraryInfo);
            parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
            parameterBuilder.addThrottling();
            if (this.serverTelemetryManager) {
              parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
            }
            parameterBuilder.addCorrelationId(correlationId);
            parameterBuilder.addRefreshToken(request.refreshToken);
            if (this.config.clientCredentials.clientSecret) {
              parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
            }
            if (this.config.clientCredentials.clientAssertion) {
              clientAssertion = this.config.clientCredentials.clientAssertion;
              parameterBuilder.addClientAssertion(clientAssertion.assertion);
              parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
            }
            if (!(request.authenticationScheme === AuthenticationScheme.POP))
              return [3, 2];
            popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
            return [4, popTokenGenerator.generateCnf(request)];
          case 1:
            reqCnfData = _b.sent();
            parameterBuilder.addPopToken(reqCnfData.reqCnfString);
            return [3, 3];
          case 2:
            if (request.authenticationScheme === AuthenticationScheme.SSH) {
              if (request.sshJwk) {
                parameterBuilder.addSshJwk(request.sshJwk);
              } else {
                acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                  success: false
                });
                throw ClientConfigurationError.createMissingSshJwkError();
              }
            }
            _b.label = 3;
          case 3:
            if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
            }
            if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {
              switch (request.ccsCredential.type) {
                case CcsCredentialType.HOME_ACCOUNT_ID:
                  try {
                    clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);
                    parameterBuilder.addCcsOid(clientInfo);
                  } catch (e) {
                    this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
                  }
                  break;
                case CcsCredentialType.UPN:
                  parameterBuilder.addCcsUpn(request.ccsCredential.credential);
                  break;
              }
            }
            acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
              success: true
            });
            return [2, parameterBuilder.createQueryString()];
        }
      });
    });
  };
  return RefreshTokenClient2;
}(BaseClient);

// node_modules/@azure/msal-common/dist/client/SilentFlowClient.js
var SilentFlowClient = function(_super) {
  __extends(SilentFlowClient2, _super);
  function SilentFlowClient2(configuration, performanceClient) {
    return _super.call(this, configuration, performanceClient) || this;
  }
  SilentFlowClient2.prototype.acquireToken = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      var e_1, refreshTokenClient;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            _a.trys.push([0, 2, , 3]);
            return [4, this.acquireCachedToken(request)];
          case 1:
            return [2, _a.sent()];
          case 2:
            e_1 = _a.sent();
            if (e_1 instanceof ClientAuthError && e_1.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {
              refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);
              return [2, refreshTokenClient.acquireTokenByRefreshToken(request)];
            } else {
              throw e_1;
            }
          case 3:
            return [2];
        }
      });
    });
  };
  SilentFlowClient2.prototype.acquireCachedToken = function(request) {
    var _a, _b, _c, _d;
    return __awaiter(this, void 0, void 0, function() {
      var environment, cacheRecord;
      return __generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            if (!request) {
              throw ClientConfigurationError.createEmptyTokenRequestError();
            }
            if (request.forceRefresh) {
              (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.FORCE_REFRESH);
              this.logger.info("SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.");
              throw ClientAuthError.createRefreshRequiredError();
            }
            if (!request.account) {
              throw ClientAuthError.createNoAccountInSilentRequestError();
            }
            environment = request.authority || this.authority.getPreferredCache();
            cacheRecord = this.cacheManager.readCacheRecord(request.account, this.config.authOptions.clientId, request, environment);
            if (!cacheRecord.accessToken) {
              (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
              this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
              throw ClientAuthError.createRefreshRequiredError();
            } else if (TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) || TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
              (_c = this.serverTelemetryManager) === null || _c === void 0 ? void 0 : _c.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
              this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within " + this.config.systemOptions.tokenRenewalOffsetSeconds + " seconds.");
              throw ClientAuthError.createRefreshRequiredError();
            } else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {
              (_d = this.serverTelemetryManager) === null || _d === void 0 ? void 0 : _d.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);
              this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.");
              throw ClientAuthError.createRefreshRequiredError();
            }
            if (this.config.serverTelemetryManager) {
              this.config.serverTelemetryManager.incrementCacheHits();
            }
            return [4, this.generateResultFromCacheRecord(cacheRecord, request)];
          case 1:
            return [2, _e.sent()];
        }
      });
    });
  };
  SilentFlowClient2.prototype.generateResultFromCacheRecord = function(cacheRecord, request) {
    return __awaiter(this, void 0, void 0, function() {
      var idTokenObj, authTime;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (cacheRecord.idToken) {
              idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);
            }
            if (request.maxAge || request.maxAge === 0) {
              authTime = idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.auth_time;
              if (!authTime) {
                throw ClientAuthError.createAuthTimeNotFoundError();
              }
              AuthToken.checkMaxAge(authTime, request.maxAge);
            }
            return [4, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenObj)];
          case 1:
            return [2, _a.sent()];
        }
      });
    });
  };
  return SilentFlowClient2;
}(BaseClient);

// node_modules/@azure/msal-common/dist/client/UsernamePasswordClient.js
var UsernamePasswordClient = function(_super) {
  __extends(UsernamePasswordClient2, _super);
  function UsernamePasswordClient2(configuration) {
    return _super.call(this, configuration) || this;
  }
  UsernamePasswordClient2.prototype.acquireToken = function(request) {
    return __awaiter(this, void 0, void 0, function() {
      var reqTimestamp, response, responseHandler, tokenResponse;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            this.logger.info("in acquireToken call");
            reqTimestamp = TimeUtils.nowSeconds();
            return [4, this.executeTokenRequest(this.authority, request)];
          case 1:
            response = _a.sent();
            responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
            responseHandler.validateTokenResponse(response.body);
            tokenResponse = responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request);
            return [2, tokenResponse];
        }
      });
    });
  };
  UsernamePasswordClient2.prototype.executeTokenRequest = function(authority, request) {
    return __awaiter(this, void 0, void 0, function() {
      var thumbprint, requestBody, headers;
      return __generator(this, function(_a) {
        thumbprint = {
          clientId: this.config.authOptions.clientId,
          authority: authority.canonicalAuthority,
          scopes: request.scopes,
          claims: request.claims,
          authenticationScheme: request.authenticationScheme,
          resourceRequestMethod: request.resourceRequestMethod,
          resourceRequestUri: request.resourceRequestUri,
          shrClaims: request.shrClaims,
          sshKid: request.sshKid
        };
        requestBody = this.createTokenRequestBody(request);
        headers = this.createTokenRequestHeaders({
          credential: request.username,
          type: CcsCredentialType.UPN
        });
        return [2, this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers, thumbprint)];
      });
    });
  };
  UsernamePasswordClient2.prototype.createTokenRequestBody = function(request) {
    var parameterBuilder = new RequestParameterBuilder();
    parameterBuilder.addClientId(this.config.authOptions.clientId);
    parameterBuilder.addUsername(request.username);
    parameterBuilder.addPassword(request.password);
    parameterBuilder.addScopes(request.scopes);
    parameterBuilder.addResponseTypeForTokenAndIdToken();
    parameterBuilder.addGrantType(GrantType.RESOURCE_OWNER_PASSWORD_GRANT);
    parameterBuilder.addClientInfo();
    parameterBuilder.addLibraryInfo(this.config.libraryInfo);
    parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
    parameterBuilder.addThrottling();
    if (this.serverTelemetryManager) {
      parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
    }
    var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
    parameterBuilder.addCorrelationId(correlationId);
    if (this.config.clientCredentials.clientSecret) {
      parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
    }
    if (this.config.clientCredentials.clientAssertion) {
      var clientAssertion = this.config.clientCredentials.clientAssertion;
      parameterBuilder.addClientAssertion(clientAssertion.assertion);
      parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
    }
    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
    }
    if (this.config.systemOptions.preventCorsPreflight && request.username) {
      parameterBuilder.addCcsUpn(request.username);
    }
    return parameterBuilder.createQueryString();
  };
  return UsernamePasswordClient2;
}(BaseClient);

// node_modules/@azure/msal-common/dist/authority/OpenIdConfigResponse.js
function isOpenIdConfigResponse(response) {
  return response.hasOwnProperty("authorization_endpoint") && response.hasOwnProperty("token_endpoint") && response.hasOwnProperty("issuer") && response.hasOwnProperty("jwks_uri");
}

// node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.js
var rawMetdataJSON = { "endpointMetadata": { "https://login.microsoftonline.com/common/": { "token_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/common/": { "token_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/common/": { "token_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" }, "https://login.microsoftonline.com/consumers/": { "token_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/consumers/": { "token_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/consumers/": { "token_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" }, "https://login.microsoftonline.com/organizations/": { "token_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/organizations/": { "token_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/organizations/": { "token_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" } }, "instanceDiscoveryMetadata": { "https://login.microsoftonline.com/common/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/common/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/common/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.com/consumers/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/consumers/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/consumers/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.com/organizations/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/organizations/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/organizations/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] } } };
var EndpointMetadata = rawMetdataJSON.endpointMetadata;
var InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;

// node_modules/@azure/msal-common/dist/authority/ProtocolMode.js
var ProtocolMode;
(function(ProtocolMode2) {
  ProtocolMode2["AAD"] = "AAD";
  ProtocolMode2["OIDC"] = "OIDC";
})(ProtocolMode || (ProtocolMode = {}));

// node_modules/@azure/msal-common/dist/cache/entities/AuthorityMetadataEntity.js
var AuthorityMetadataEntity = function() {
  function AuthorityMetadataEntity2() {
    this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
  }
  AuthorityMetadataEntity2.prototype.updateCloudDiscoveryMetadata = function(metadata, fromNetwork) {
    this.aliases = metadata.aliases;
    this.preferred_cache = metadata.preferred_cache;
    this.preferred_network = metadata.preferred_network;
    this.aliasesFromNetwork = fromNetwork;
  };
  AuthorityMetadataEntity2.prototype.updateEndpointMetadata = function(metadata, fromNetwork) {
    this.authorization_endpoint = metadata.authorization_endpoint;
    this.token_endpoint = metadata.token_endpoint;
    this.end_session_endpoint = metadata.end_session_endpoint;
    this.issuer = metadata.issuer;
    this.endpointsFromNetwork = fromNetwork;
    this.jwks_uri = metadata.jwks_uri;
  };
  AuthorityMetadataEntity2.prototype.updateCanonicalAuthority = function(authority) {
    this.canonical_authority = authority;
  };
  AuthorityMetadataEntity2.prototype.resetExpiresAt = function() {
    this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
  };
  AuthorityMetadataEntity2.prototype.isExpired = function() {
    return this.expiresAt <= TimeUtils.nowSeconds();
  };
  AuthorityMetadataEntity2.isAuthorityMetadataEntity = function(key, entity) {
    if (!entity) {
      return false;
    }
    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 && entity.hasOwnProperty("aliases") && entity.hasOwnProperty("preferred_cache") && entity.hasOwnProperty("preferred_network") && entity.hasOwnProperty("canonical_authority") && entity.hasOwnProperty("authorization_endpoint") && entity.hasOwnProperty("token_endpoint") && entity.hasOwnProperty("issuer") && entity.hasOwnProperty("aliasesFromNetwork") && entity.hasOwnProperty("endpointsFromNetwork") && entity.hasOwnProperty("expiresAt") && entity.hasOwnProperty("jwks_uri");
  };
  return AuthorityMetadataEntity2;
}();

// node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.js
function isCloudInstanceDiscoveryResponse(response) {
  return response.hasOwnProperty("tenant_discovery_endpoint") && response.hasOwnProperty("metadata");
}

// node_modules/@azure/msal-common/dist/authority/RegionDiscovery.js
var RegionDiscovery = function() {
  function RegionDiscovery2(networkInterface) {
    this.networkInterface = networkInterface;
  }
  RegionDiscovery2.prototype.detectRegion = function(environmentRegion, regionDiscoveryMetadata, proxyUrl) {
    return __awaiter(this, void 0, void 0, function() {
      var autodetectedRegionName, options, localIMDSVersionResponse, currentIMDSVersion, currentIMDSVersionResponse;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            autodetectedRegionName = environmentRegion;
            if (!!autodetectedRegionName)
              return [3, 8];
            options = RegionDiscovery2.IMDS_OPTIONS;
            if (proxyUrl) {
              options.proxyUrl = proxyUrl;
            }
            _a.label = 1;
          case 1:
            _a.trys.push([1, 6, , 7]);
            return [4, this.getRegionFromIMDS(Constants.IMDS_VERSION, options)];
          case 2:
            localIMDSVersionResponse = _a.sent();
            if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
              autodetectedRegionName = localIMDSVersionResponse.body;
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
            }
            if (!(localIMDSVersionResponse.status === ResponseCodes.httpBadRequest))
              return [3, 5];
            return [4, this.getCurrentVersion(options)];
          case 3:
            currentIMDSVersion = _a.sent();
            if (!currentIMDSVersion) {
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
              return [2, null];
            }
            return [4, this.getRegionFromIMDS(currentIMDSVersion, options)];
          case 4:
            currentIMDSVersionResponse = _a.sent();
            if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
              autodetectedRegionName = currentIMDSVersionResponse.body;
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
            }
            _a.label = 5;
          case 5:
            return [3, 7];
          case 6:
            _a.sent();
            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
            return [2, null];
          case 7:
            return [3, 9];
          case 8:
            regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
            _a.label = 9;
          case 9:
            if (!autodetectedRegionName) {
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
            }
            return [2, autodetectedRegionName || null];
        }
      });
    });
  };
  RegionDiscovery2.prototype.getRegionFromIMDS = function(version3, options) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        return [2, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?api-version=" + version3 + "&format=text", options, Constants.IMDS_TIMEOUT)];
      });
    });
  };
  RegionDiscovery2.prototype.getCurrentVersion = function(options) {
    return __awaiter(this, void 0, void 0, function() {
      var response;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            _a.trys.push([0, 2, , 3]);
            return [4, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?format=json", options)];
          case 1:
            response = _a.sent();
            if (response.status === ResponseCodes.httpBadRequest && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
              return [2, response.body["newest-versions"][0]];
            }
            return [2, null];
          case 2:
            _a.sent();
            return [2, null];
          case 3:
            return [2];
        }
      });
    });
  };
  RegionDiscovery2.IMDS_OPTIONS = {
    headers: {
      Metadata: "true"
    }
  };
  return RegionDiscovery2;
}();

// node_modules/@azure/msal-common/dist/authority/Authority.js
var Authority = function() {
  function Authority2(authority, networkInterface, cacheManager, authorityOptions, proxyUrl) {
    this.canonicalAuthority = authority;
    this._canonicalAuthority.validateAsUri();
    this.networkInterface = networkInterface;
    this.cacheManager = cacheManager;
    this.authorityOptions = authorityOptions;
    this.regionDiscovery = new RegionDiscovery(networkInterface);
    this.regionDiscoveryMetadata = { region_used: void 0, region_source: void 0, region_outcome: void 0 };
    this.proxyUrl = proxyUrl || Constants.EMPTY_STRING;
  }
  Object.defineProperty(Authority2.prototype, "authorityType", {
    get: function() {
      var pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;
      if (pathSegments.length) {
        switch (pathSegments[0].toLowerCase()) {
          case Constants.ADFS:
            return AuthorityType.Adfs;
          case Constants.DSTS:
            return AuthorityType.Dsts;
        }
      }
      return AuthorityType.Default;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Authority2.prototype, "protocolMode", {
    get: function() {
      return this.authorityOptions.protocolMode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Authority2.prototype, "options", {
    get: function() {
      return this.authorityOptions;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Authority2.prototype, "canonicalAuthority", {
    get: function() {
      return this._canonicalAuthority.urlString;
    },
    set: function(url) {
      this._canonicalAuthority = new UrlString(url);
      this._canonicalAuthority.validateAsUri();
      this._canonicalAuthorityUrlComponents = null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Authority2.prototype, "canonicalAuthorityUrlComponents", {
    get: function() {
      if (!this._canonicalAuthorityUrlComponents) {
        this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
      }
      return this._canonicalAuthorityUrlComponents;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Authority2.prototype, "hostnameAndPort", {
    get: function() {
      return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Authority2.prototype, "tenant", {
    get: function() {
      return this.canonicalAuthorityUrlComponents.PathSegments[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Authority2.prototype, "authorizationEndpoint", {
    get: function() {
      if (this.discoveryComplete()) {
        var endpoint = this.replacePath(this.metadata.authorization_endpoint);
        return this.replaceTenant(endpoint);
      } else {
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Authority2.prototype, "tokenEndpoint", {
    get: function() {
      if (this.discoveryComplete()) {
        var endpoint = this.replacePath(this.metadata.token_endpoint);
        return this.replaceTenant(endpoint);
      } else {
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Authority2.prototype, "deviceCodeEndpoint", {
    get: function() {
      if (this.discoveryComplete()) {
        var endpoint = this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
        return this.replaceTenant(endpoint);
      } else {
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Authority2.prototype, "endSessionEndpoint", {
    get: function() {
      if (this.discoveryComplete()) {
        if (!this.metadata.end_session_endpoint) {
          throw ClientAuthError.createLogoutNotSupportedError();
        }
        var endpoint = this.replacePath(this.metadata.end_session_endpoint);
        return this.replaceTenant(endpoint);
      } else {
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Authority2.prototype, "selfSignedJwtAudience", {
    get: function() {
      if (this.discoveryComplete()) {
        var endpoint = this.replacePath(this.metadata.issuer);
        return this.replaceTenant(endpoint);
      } else {
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Authority2.prototype, "jwksUri", {
    get: function() {
      if (this.discoveryComplete()) {
        var endpoint = this.replacePath(this.metadata.jwks_uri);
        return this.replaceTenant(endpoint);
      } else {
        throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
      }
    },
    enumerable: false,
    configurable: true
  });
  Authority2.prototype.replaceTenant = function(urlString) {
    return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
  };
  Authority2.prototype.replacePath = function(urlString) {
    var endpoint = urlString;
    var cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
    var cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
    var currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
    currentAuthorityParts.forEach(function(currentPart, index) {
      var cachedPart = cachedAuthorityParts[index];
      if (currentPart !== cachedPart) {
        endpoint = endpoint.replace("/" + cachedPart + "/", "/" + currentPart + "/");
      }
    });
    return endpoint;
  };
  Object.defineProperty(Authority2.prototype, "defaultOpenIdConfigurationEndpoint", {
    get: function() {
      if (this.authorityType === AuthorityType.Adfs || this.authorityType === AuthorityType.Dsts || this.protocolMode === ProtocolMode.OIDC) {
        return this.canonicalAuthority + ".well-known/openid-configuration";
      }
      return this.canonicalAuthority + "v2.0/.well-known/openid-configuration";
    },
    enumerable: false,
    configurable: true
  });
  Authority2.prototype.discoveryComplete = function() {
    return !!this.metadata;
  };
  Authority2.prototype.resolveEndpointsAsync = function() {
    return __awaiter(this, void 0, void 0, function() {
      var metadataEntity, cloudDiscoverySource, endpointSource, cacheKey;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
            if (!metadataEntity) {
              metadataEntity = new AuthorityMetadataEntity();
              metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);
            }
            return [4, this.updateCloudDiscoveryMetadata(metadataEntity)];
          case 1:
            cloudDiscoverySource = _a.sent();
            this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
            return [4, this.updateEndpointMetadata(metadataEntity)];
          case 2:
            endpointSource = _a.sent();
            if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {
              metadataEntity.resetExpiresAt();
              metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);
            }
            cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
            this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
            this.metadata = metadataEntity;
            return [2];
        }
      });
    });
  };
  Authority2.prototype.updateEndpointMetadata = function(metadataEntity) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function() {
      var metadata, harcodedMetadata;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            metadata = this.getEndpointMetadataFromConfig();
            if (metadata) {
              metadataEntity.updateEndpointMetadata(metadata, false);
              return [2, AuthorityMetadataSource.CONFIG];
            }
            if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {
              return [2, AuthorityMetadataSource.CACHE];
            }
            harcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
            return [4, this.getEndpointMetadataFromNetwork()];
          case 1:
            metadata = _c.sent();
            if (!metadata)
              return [3, 4];
            if (!((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.azureRegion))
              return [3, 3];
            return [4, this.updateMetadataWithRegionalInformation(metadata)];
          case 2:
            metadata = _c.sent();
            _c.label = 3;
          case 3:
            metadataEntity.updateEndpointMetadata(metadata, true);
            return [2, AuthorityMetadataSource.NETWORK];
          case 4:
            if (!(harcodedMetadata && !this.authorityOptions.skipAuthorityMetadataCache))
              return [3, 7];
            if (!((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion))
              return [3, 6];
            return [4, this.updateMetadataWithRegionalInformation(harcodedMetadata)];
          case 5:
            harcodedMetadata = _c.sent();
            _c.label = 6;
          case 6:
            metadataEntity.updateEndpointMetadata(harcodedMetadata, false);
            return [2, AuthorityMetadataSource.HARDCODED_VALUES];
          case 7:
            throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);
        }
      });
    });
  };
  Authority2.prototype.isAuthoritySameType = function(metadataEntity) {
    var cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
    var cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
    return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
  };
  Authority2.prototype.getEndpointMetadataFromConfig = function() {
    if (this.authorityOptions.authorityMetadata) {
      try {
        return JSON.parse(this.authorityOptions.authorityMetadata);
      } catch (e) {
        throw ClientConfigurationError.createInvalidAuthorityMetadataError();
      }
    }
    return null;
  };
  Authority2.prototype.getEndpointMetadataFromNetwork = function() {
    return __awaiter(this, void 0, void 0, function() {
      var options, response;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            options = {};
            if (this.proxyUrl) {
              options.proxyUrl = this.proxyUrl;
            }
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, , 4]);
            return [4, this.networkInterface.sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint, options)];
          case 2:
            response = _a.sent();
            return [2, isOpenIdConfigResponse(response.body) ? response.body : null];
          case 3:
            _a.sent();
            return [2, null];
          case 4:
            return [2];
        }
      });
    });
  };
  Authority2.prototype.getEndpointMetadataFromHardcodedValues = function() {
    if (this.canonicalAuthority in EndpointMetadata) {
      return EndpointMetadata[this.canonicalAuthority];
    }
    return null;
  };
  Authority2.prototype.updateMetadataWithRegionalInformation = function(metadata) {
    var _a, _b, _c, _d, _e;
    return __awaiter(this, void 0, void 0, function() {
      var autodetectedRegionName, azureRegion;
      return __generator(this, function(_f) {
        switch (_f.label) {
          case 0:
            return [4, this.regionDiscovery.detectRegion((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.environmentRegion, this.regionDiscoveryMetadata, this.proxyUrl)];
          case 1:
            autodetectedRegionName = _f.sent();
            azureRegion = ((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG ? autodetectedRegionName : (_c = this.authorityOptions.azureRegionConfiguration) === null || _c === void 0 ? void 0 : _c.azureRegion;
            if (((_d = this.authorityOptions.azureRegionConfiguration) === null || _d === void 0 ? void 0 : _d.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
              this.regionDiscoveryMetadata.region_outcome = autodetectedRegionName ? RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL : RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
            } else {
              if (autodetectedRegionName) {
                this.regionDiscoveryMetadata.region_outcome = ((_e = this.authorityOptions.azureRegionConfiguration) === null || _e === void 0 ? void 0 : _e.azureRegion) === autodetectedRegionName ? RegionDiscoveryOutcomes.CONFIGURED_MATCHES_DETECTED : RegionDiscoveryOutcomes.CONFIGURED_NOT_DETECTED;
              } else {
                this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
              }
            }
            if (azureRegion) {
              this.regionDiscoveryMetadata.region_used = azureRegion;
              return [2, Authority2.replaceWithRegionalInformation(metadata, azureRegion)];
            }
            return [2, metadata];
        }
      });
    });
  };
  Authority2.prototype.updateCloudDiscoveryMetadata = function(metadataEntity) {
    return __awaiter(this, void 0, void 0, function() {
      var metadata, harcodedMetadata;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            metadata = this.getCloudDiscoveryMetadataFromConfig();
            if (metadata) {
              metadataEntity.updateCloudDiscoveryMetadata(metadata, false);
              return [2, AuthorityMetadataSource.CONFIG];
            }
            if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntity.isExpired()) {
              return [2, AuthorityMetadataSource.CACHE];
            }
            harcodedMetadata = this.getCloudDiscoveryMetadataFromHarcodedValues();
            return [4, this.getCloudDiscoveryMetadataFromNetwork()];
          case 1:
            metadata = _a.sent();
            if (metadata) {
              metadataEntity.updateCloudDiscoveryMetadata(metadata, true);
              return [2, AuthorityMetadataSource.NETWORK];
            }
            if (harcodedMetadata && !this.options.skipAuthorityMetadataCache) {
              metadataEntity.updateCloudDiscoveryMetadata(harcodedMetadata, false);
              return [2, AuthorityMetadataSource.HARDCODED_VALUES];
            } else {
              throw ClientConfigurationError.createUntrustedAuthorityError();
            }
        }
      });
    });
  };
  Authority2.prototype.getCloudDiscoveryMetadataFromConfig = function() {
    if (this.authorityOptions.cloudDiscoveryMetadata) {
      try {
        var parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
        var metadata = Authority2.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
        if (metadata) {
          return metadata;
        }
      } catch (e) {
        throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();
      }
    }
    if (this.isInKnownAuthorities()) {
      return Authority2.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
    }
    return null;
  };
  Authority2.prototype.getCloudDiscoveryMetadataFromNetwork = function() {
    return __awaiter(this, void 0, void 0, function() {
      var instanceDiscoveryEndpoint, options, match, response, metadata;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            instanceDiscoveryEndpoint = "" + Constants.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + "oauth2/v2.0/authorize";
            options = {};
            if (this.proxyUrl) {
              options.proxyUrl = this.proxyUrl;
            }
            match = null;
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, , 4]);
            return [4, this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options)];
          case 2:
            response = _a.sent();
            metadata = isCloudInstanceDiscoveryResponse(response.body) ? response.body.metadata : [];
            if (metadata.length === 0) {
              return [2, null];
            }
            match = Authority2.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
            return [3, 4];
          case 3:
            _a.sent();
            return [2, null];
          case 4:
            if (!match) {
              match = Authority2.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
            }
            return [2, match];
        }
      });
    });
  };
  Authority2.prototype.getCloudDiscoveryMetadataFromHarcodedValues = function() {
    if (this.canonicalAuthority in InstanceDiscoveryMetadata) {
      return InstanceDiscoveryMetadata[this.canonicalAuthority];
    }
    return null;
  };
  Authority2.prototype.isInKnownAuthorities = function() {
    var _this = this;
    var matches = this.authorityOptions.knownAuthorities.filter(function(authority) {
      return UrlString.getDomainFromUrl(authority).toLowerCase() === _this.hostnameAndPort;
    });
    return matches.length > 0;
  };
  Authority2.generateAuthority = function(authorityString, azureCloudOptions) {
    var authorityAzureCloudInstance;
    if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
      var tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;
      authorityAzureCloudInstance = azureCloudOptions.azureCloudInstance + "/" + tenant + "/";
    }
    return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
  };
  Authority2.createCloudDiscoveryMetadataFromHost = function(host) {
    return {
      preferred_network: host,
      preferred_cache: host,
      aliases: [host]
    };
  };
  Authority2.getCloudDiscoveryMetadataFromNetworkResponse = function(response, authority) {
    for (var i = 0; i < response.length; i++) {
      var metadata = response[i];
      if (metadata.aliases.indexOf(authority) > -1) {
        return metadata;
      }
    }
    return null;
  };
  Authority2.prototype.getPreferredCache = function() {
    if (this.discoveryComplete()) {
      return this.metadata.preferred_cache;
    } else {
      throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
    }
  };
  Authority2.prototype.isAlias = function(host) {
    return this.metadata.aliases.indexOf(host) > -1;
  };
  Authority2.isPublicCloudAuthority = function(host) {
    return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
  };
  Authority2.buildRegionalAuthorityString = function(host, region, queryString) {
    var authorityUrlInstance = new UrlString(host);
    authorityUrlInstance.validateAsUri();
    var authorityUrlParts = authorityUrlInstance.getUrlComponents();
    var hostNameAndPort = region + "." + authorityUrlParts.HostNameAndPort;
    if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
      hostNameAndPort = region + "." + Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX;
    }
    var url = UrlString.constructAuthorityUriFromObject(__assign(__assign({}, authorityUrlInstance.getUrlComponents()), { HostNameAndPort: hostNameAndPort })).urlString;
    if (queryString)
      return url + "?" + queryString;
    return url;
  };
  Authority2.replaceWithRegionalInformation = function(metadata, azureRegion) {
    metadata.authorization_endpoint = Authority2.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);
    metadata.token_endpoint = Authority2.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, Constants.REGIONAL_AUTH_NON_MSI_QUERY_STRING);
    if (metadata.end_session_endpoint) {
      metadata.end_session_endpoint = Authority2.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);
    }
    return metadata;
  };
  return Authority2;
}();

// node_modules/@azure/msal-common/dist/authority/AuthorityFactory.js
var AuthorityFactory = function() {
  function AuthorityFactory2() {
  }
  AuthorityFactory2.createDiscoveredInstance = function(authorityUri, networkClient, cacheManager, authorityOptions, proxyUrl) {
    return __awaiter(this, void 0, void 0, function() {
      var acquireTokenAuthority, e_1;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            acquireTokenAuthority = AuthorityFactory2.createInstance(authorityUri, networkClient, cacheManager, authorityOptions, proxyUrl);
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, , 4]);
            return [4, acquireTokenAuthority.resolveEndpointsAsync()];
          case 2:
            _a.sent();
            return [2, acquireTokenAuthority];
          case 3:
            e_1 = _a.sent();
            throw ClientAuthError.createEndpointDiscoveryIncompleteError(e_1);
          case 4:
            return [2];
        }
      });
    });
  };
  AuthorityFactory2.createInstance = function(authorityUrl, networkInterface, cacheManager, authorityOptions, proxyUrl) {
    if (StringUtils.isEmpty(authorityUrl)) {
      throw ClientConfigurationError.createUrlEmptyError();
    }
    return new Authority(authorityUrl, networkInterface, cacheManager, authorityOptions, proxyUrl);
  };
  return AuthorityFactory2;
}();

// node_modules/@azure/msal-common/dist/cache/entities/ServerTelemetryEntity.js
var ServerTelemetryEntity = function() {
  function ServerTelemetryEntity2() {
    this.failedRequests = [];
    this.errors = [];
    this.cacheHits = 0;
  }
  ServerTelemetryEntity2.isServerTelemetryEntity = function(key, entity) {
    var validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
    var validateEntity = true;
    if (entity) {
      validateEntity = entity.hasOwnProperty("failedRequests") && entity.hasOwnProperty("errors") && entity.hasOwnProperty("cacheHits");
    }
    return validateKey && validateEntity;
  };
  return ServerTelemetryEntity2;
}();

// node_modules/@azure/msal-common/dist/cache/entities/ThrottlingEntity.js
var ThrottlingEntity = function() {
  function ThrottlingEntity2() {
  }
  ThrottlingEntity2.isThrottlingEntity = function(key, entity) {
    var validateKey = false;
    if (key) {
      validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
    }
    var validateEntity = true;
    if (entity) {
      validateEntity = entity.hasOwnProperty("throttleTime");
    }
    return validateKey && validateEntity;
  };
  return ThrottlingEntity2;
}();

// node_modules/@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.js
var ServerTelemetryManager = function() {
  function ServerTelemetryManager2(telemetryRequest, cacheManager) {
    this.cacheOutcome = CacheOutcome.NO_CACHE_HIT;
    this.cacheManager = cacheManager;
    this.apiId = telemetryRequest.apiId;
    this.correlationId = telemetryRequest.correlationId;
    this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
    this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
    this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;
  }
  ServerTelemetryManager2.prototype.generateCurrentRequestHeaderValue = function() {
    var request = "" + this.apiId + SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR + this.cacheOutcome;
    var platformFields = [this.wrapperSKU, this.wrapperVer].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
    var regionDiscoveryFields = this.getRegionDiscoveryFields();
    var requestWithRegionDiscoveryFields = [request, regionDiscoveryFields].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
    return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, requestWithRegionDiscoveryFields, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
  };
  ServerTelemetryManager2.prototype.generateLastRequestHeaderValue = function() {
    var lastRequests = this.getLastRequests();
    var maxErrors = ServerTelemetryManager2.maxErrorsToSend(lastRequests);
    var failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
    var errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
    var errorCount = lastRequests.errors.length;
    var overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
    var platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
    return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, lastRequests.cacheHits, failedRequests, errors, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
  };
  ServerTelemetryManager2.prototype.cacheFailedRequest = function(error) {
    var lastRequests = this.getLastRequests();
    if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
      lastRequests.failedRequests.shift();
      lastRequests.failedRequests.shift();
      lastRequests.errors.shift();
    }
    lastRequests.failedRequests.push(this.apiId, this.correlationId);
    if (!StringUtils.isEmpty(error.subError)) {
      lastRequests.errors.push(error.subError);
    } else if (!StringUtils.isEmpty(error.errorCode)) {
      lastRequests.errors.push(error.errorCode);
    } else if (!!error && error.toString()) {
      lastRequests.errors.push(error.toString());
    } else {
      lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
    }
    this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
    return;
  };
  ServerTelemetryManager2.prototype.incrementCacheHits = function() {
    var lastRequests = this.getLastRequests();
    lastRequests.cacheHits += 1;
    this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
    return lastRequests.cacheHits;
  };
  ServerTelemetryManager2.prototype.getLastRequests = function() {
    var initialValue = new ServerTelemetryEntity();
    var lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
    return lastRequests || initialValue;
  };
  ServerTelemetryManager2.prototype.clearTelemetryCache = function() {
    var lastRequests = this.getLastRequests();
    var numErrorsFlushed = ServerTelemetryManager2.maxErrorsToSend(lastRequests);
    var errorCount = lastRequests.errors.length;
    if (numErrorsFlushed === errorCount) {
      this.cacheManager.removeItem(this.telemetryCacheKey);
    } else {
      var serverTelemEntity = new ServerTelemetryEntity();
      serverTelemEntity.failedRequests = lastRequests.failedRequests.slice(numErrorsFlushed * 2);
      serverTelemEntity.errors = lastRequests.errors.slice(numErrorsFlushed);
      this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity);
    }
  };
  ServerTelemetryManager2.maxErrorsToSend = function(serverTelemetryEntity) {
    var i;
    var maxErrors = 0;
    var dataSize = 0;
    var errorCount = serverTelemetryEntity.errors.length;
    for (i = 0; i < errorCount; i++) {
      var apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;
      var correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;
      var errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
      dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
      if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
        maxErrors += 1;
      } else {
        break;
      }
    }
    return maxErrors;
  };
  ServerTelemetryManager2.prototype.getRegionDiscoveryFields = function() {
    var regionDiscoveryFields = [];
    regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);
    regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);
    regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);
    return regionDiscoveryFields.join(",");
  };
  ServerTelemetryManager2.prototype.updateRegionDiscoveryMetadata = function(regionDiscoveryMetadata) {
    this.regionUsed = regionDiscoveryMetadata.region_used;
    this.regionSource = regionDiscoveryMetadata.region_source;
    this.regionOutcome = regionDiscoveryMetadata.region_outcome;
  };
  ServerTelemetryManager2.prototype.setCacheOutcome = function(cacheOutcome) {
    this.cacheOutcome = cacheOutcome;
  };
  return ServerTelemetryManager2;
}();

// node_modules/@azure/msal-node/dist/msal-node.esm.js
var import_http = __toESM(require("http"));
var import_https = __toESM(require("https"));

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
var i;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// node_modules/@azure/msal-node/dist/msal-node.esm.js
var import_crypto = __toESM(require("crypto"));
var import_jsonwebtoken = __toESM(require_jsonwebtoken());
var HttpMethod;
(function(HttpMethod2) {
  HttpMethod2["GET"] = "get";
  HttpMethod2["POST"] = "post";
})(HttpMethod || (HttpMethod = {}));
var HttpStatus;
(function(HttpStatus2) {
  HttpStatus2[HttpStatus2["OK"] = 200] = "OK";
  HttpStatus2[HttpStatus2["REDIRECT"] = 302] = "REDIRECT";
})(HttpStatus || (HttpStatus = {}));
var RANDOM_OCTET_SIZE = 32;
var Hash = {
  SHA256: "sha256"
};
var CharSet = {
  CV_CHARSET: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
};
var Constants2 = {
  MSAL_SKU: "msal.js.node",
  JWT_BEARER_ASSERTION_TYPE: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
  AUTHORIZATION_PENDING: "authorization_pending",
  HTTP_PROTOCOL: "http://",
  LOCALHOST: "localhost"
};
var ApiId;
(function(ApiId2) {
  ApiId2[ApiId2["acquireTokenSilent"] = 62] = "acquireTokenSilent";
  ApiId2[ApiId2["acquireTokenByUsernamePassword"] = 371] = "acquireTokenByUsernamePassword";
  ApiId2[ApiId2["acquireTokenByDeviceCode"] = 671] = "acquireTokenByDeviceCode";
  ApiId2[ApiId2["acquireTokenByClientCredential"] = 771] = "acquireTokenByClientCredential";
  ApiId2[ApiId2["acquireTokenByCode"] = 871] = "acquireTokenByCode";
  ApiId2[ApiId2["acquireTokenByRefreshToken"] = 872] = "acquireTokenByRefreshToken";
})(ApiId || (ApiId = {}));
var LOOPBACK_SERVER_CONSTANTS = {
  INTERVAL_MS: 100,
  TIMEOUT_MS: 5e3
};
var HttpClient = class {
  async sendGetRequestAsync(url, options) {
    if (options != null && options.proxyUrl) {
      return networkRequestViaProxy(url, HttpMethod.GET, options);
    } else {
      return networkRequestViaHttps(url, HttpMethod.GET, options);
    }
  }
  async sendPostRequestAsync(url, options, cancellationToken) {
    if (options != null && options.proxyUrl) {
      return networkRequestViaProxy(url, HttpMethod.POST, options, cancellationToken);
    } else {
      return networkRequestViaHttps(url, HttpMethod.POST, options, cancellationToken);
    }
  }
};
var networkRequestViaProxy = (url, httpMethod, options, timeout) => {
  const headers = (options == null ? void 0 : options.headers) || {};
  const proxyUrl = new URL((options == null ? void 0 : options.proxyUrl) || "");
  const destinationUrl = new URL(url);
  const tunnelRequestOptions = {
    host: proxyUrl.hostname,
    port: proxyUrl.port,
    method: "CONNECT",
    path: destinationUrl.hostname,
    headers
  };
  if (timeout) {
    tunnelRequestOptions.timeout = timeout;
  }
  let postRequestStringContent = "";
  if (httpMethod === HttpMethod.POST) {
    const body = (options == null ? void 0 : options.body) || "";
    postRequestStringContent = `Content-Type: application/x-www-form-urlencoded\r
Content-Length: ${body.length}\r
\r
${body}`;
  }
  const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\r
Host: ${destinationUrl.host}\r
Connection: close\r
` + postRequestStringContent + "\r\n";
  return new Promise((resolve, reject) => {
    const request = import_http.default.request(tunnelRequestOptions);
    if (tunnelRequestOptions.timeout) {
      request.on("timeout", () => {
        request.destroy();
        reject(new Error("Request time out"));
      });
    }
    request.end();
    request.on("connect", (response, socket) => {
      const statusCode = (response == null ? void 0 : response.statusCode) || 500;
      if (statusCode < 200 || statusCode > 299) {
        request.destroy();
        socket.destroy();
        reject(new Error(` Error connecting to proxy: ${response.statusCode}, ${response == null ? void 0 : response.statusMessage}`));
      }
      if (tunnelRequestOptions.timeout) {
        socket.setTimeout(tunnelRequestOptions.timeout);
        socket.on("timeout", () => {
          request.destroy();
          socket.destroy();
          reject(new Error("Request time out"));
        });
      }
      socket.write(outgoingRequestString);
      const data = [];
      socket.on("data", (chunk) => {
        data.push(chunk);
      });
      socket.on("end", () => {
        const dataString = Buffer.concat([...data]).toString();
        const dataStringArray = dataString.split("\r\n");
        const statusCode2 = parseInt(dataStringArray[0].split(" ")[1]);
        const body = dataStringArray[dataStringArray.length - 1];
        const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);
        const entries = /* @__PURE__ */ new Map();
        headersArray.forEach((header) => {
          const headerKeyValue = header.split(new RegExp(/:\s(.*)/s));
          const headerKey = headerKeyValue[0];
          let headerValue = headerKeyValue[1];
          try {
            const object = JSON.parse(headerValue);
            if (object && typeof object === "object") {
              headerValue = object;
            }
          } catch (e) {
          }
          entries.set(headerKey, headerValue);
        });
        const headers2 = Object.fromEntries(entries);
        const networkResponse = {
          headers: headers2,
          body: JSON.parse(body),
          status: statusCode2
        };
        if ((statusCode2 < 200 || statusCode2 > 299) && networkResponse.body["error"] !== Constants2.AUTHORIZATION_PENDING) {
          request.destroy();
        }
        resolve(networkResponse);
      });
      socket.on("error", (chunk) => {
        request.destroy();
        socket.destroy();
        reject(new Error(chunk.toString()));
      });
    });
    request.on("error", (chunk) => {
      request.destroy();
      reject(new Error(chunk.toString()));
    });
  });
};
var networkRequestViaHttps = (url, httpMethod, options, timeout) => {
  const isPostRequest = httpMethod === HttpMethod.POST;
  const body = (options == null ? void 0 : options.body) || "";
  const emptyHeaders = {};
  const customOptions = {
    method: httpMethod,
    headers: (options == null ? void 0 : options.headers) || emptyHeaders
  };
  if (timeout) {
    customOptions.timeout = timeout;
  }
  if (isPostRequest) {
    customOptions.headers = {
      ...customOptions.headers,
      "Content-Length": body.length
    };
  }
  return new Promise((resolve, reject) => {
    const request = import_https.default.request(url, customOptions);
    if (timeout) {
      request.on("timeout", () => {
        request.destroy();
        reject(new Error("Request time out"));
      });
    }
    if (isPostRequest) {
      request.write(body);
    }
    request.end();
    request.on("response", (response) => {
      const headers = response.headers;
      const statusCode = response.statusCode;
      const data = [];
      response.on("data", (chunk) => {
        data.push(chunk);
      });
      response.on("end", () => {
        const body2 = Buffer.concat([...data]).toString();
        const networkResponse = {
          headers,
          body: JSON.parse(body2),
          status: statusCode
        };
        if ((statusCode < 200 || statusCode > 299) && networkResponse.body["error"] !== Constants2.AUTHORIZATION_PENDING) {
          request.destroy();
        }
        resolve(networkResponse);
      });
    });
    request.on("error", (chunk) => {
      request.destroy();
      reject(new Error(chunk.toString()));
    });
  });
};
var NetworkUtils = class {
  static getNetworkClient() {
    return new HttpClient();
  }
};
var DEFAULT_AUTH_OPTIONS = {
  clientId: Constants.EMPTY_STRING,
  authority: Constants.DEFAULT_AUTHORITY,
  clientSecret: Constants.EMPTY_STRING,
  clientAssertion: Constants.EMPTY_STRING,
  clientCertificate: {
    thumbprint: Constants.EMPTY_STRING,
    privateKey: Constants.EMPTY_STRING,
    x5c: Constants.EMPTY_STRING
  },
  knownAuthorities: [],
  cloudDiscoveryMetadata: Constants.EMPTY_STRING,
  authorityMetadata: Constants.EMPTY_STRING,
  clientCapabilities: [],
  protocolMode: ProtocolMode.AAD,
  azureCloudOptions: {
    azureCloudInstance: AzureCloudInstance.None,
    tenant: Constants.EMPTY_STRING
  },
  skipAuthorityMetadataCache: false
};
var DEFAULT_CACHE_OPTIONS = {};
var DEFAULT_LOGGER_OPTIONS = {
  loggerCallback: () => {
  },
  piiLoggingEnabled: false,
  logLevel: LogLevel.Info
};
var DEFAULT_SYSTEM_OPTIONS2 = {
  loggerOptions: DEFAULT_LOGGER_OPTIONS,
  networkClient: /* @__PURE__ */ NetworkUtils.getNetworkClient(),
  proxyUrl: Constants.EMPTY_STRING
};
var DEFAULT_TELEMETRY_OPTIONS2 = {
  application: {
    appName: Constants.EMPTY_STRING,
    appVersion: Constants.EMPTY_STRING
  }
};
function buildAppConfiguration({
  auth,
  cache,
  system,
  telemetry
}) {
  return {
    auth: {
      ...DEFAULT_AUTH_OPTIONS,
      ...auth
    },
    cache: {
      ...DEFAULT_CACHE_OPTIONS,
      ...cache
    },
    system: {
      ...DEFAULT_SYSTEM_OPTIONS2,
      ...system
    },
    telemetry: {
      ...DEFAULT_TELEMETRY_OPTIONS2,
      ...telemetry
    }
  };
}
var GuidGenerator = class {
  generateGuid() {
    return v4_default();
  }
  isGuid(guid) {
    const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return regexGuid.test(guid);
  }
};
var EncodingUtils = class {
  static base64Encode(str, encoding) {
    return Buffer.from(str, encoding).toString("base64");
  }
  static base64EncodeUrl(str, encoding) {
    return EncodingUtils.base64Encode(str, encoding).replace(/=/g, Constants.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_");
  }
  static base64Decode(base64Str) {
    return Buffer.from(base64Str, "base64").toString("utf8");
  }
  static base64DecodeUrl(base64Str) {
    let str = base64Str.replace(/-/g, "+").replace(/_/g, "/");
    while (str.length % 4) {
      str += "=";
    }
    return EncodingUtils.base64Decode(str);
  }
};
var HashUtils = class {
  sha256(buffer) {
    return import_crypto.default.createHash(Hash.SHA256).update(buffer).digest();
  }
};
var PkceGenerator = class {
  constructor() {
    this.hashUtils = new HashUtils();
  }
  async generatePkceCodes() {
    const verifier = this.generateCodeVerifier();
    const challenge = this.generateCodeChallengeFromVerifier(verifier);
    return {
      verifier,
      challenge
    };
  }
  generateCodeVerifier() {
    const charArr = [];
    const maxNumber = 256 - 256 % CharSet.CV_CHARSET.length;
    while (charArr.length <= RANDOM_OCTET_SIZE) {
      const byte = import_crypto.default.randomBytes(1)[0];
      if (byte >= maxNumber) {
        continue;
      }
      const index = byte % CharSet.CV_CHARSET.length;
      charArr.push(CharSet.CV_CHARSET[index]);
    }
    const verifier = charArr.join(Constants.EMPTY_STRING);
    return EncodingUtils.base64EncodeUrl(verifier);
  }
  generateCodeChallengeFromVerifier(codeVerifier) {
    return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(codeVerifier).toString("base64"), "base64");
  }
};
var CryptoProvider = class {
  constructor() {
    this.pkceGenerator = new PkceGenerator();
    this.guidGenerator = new GuidGenerator();
    this.hashUtils = new HashUtils();
  }
  createNewGuid() {
    return this.guidGenerator.generateGuid();
  }
  base64Encode(input) {
    return EncodingUtils.base64Encode(input);
  }
  base64Decode(input) {
    return EncodingUtils.base64Decode(input);
  }
  generatePkceCodes() {
    return this.pkceGenerator.generatePkceCodes();
  }
  getPublicKeyThumbprint() {
    throw new Error("Method not implemented.");
  }
  removeTokenBindingKey() {
    throw new Error("Method not implemented.");
  }
  clearKeystore() {
    throw new Error("Method not implemented.");
  }
  signJwt() {
    throw new Error("Method not implemented.");
  }
  async hashString(plainText) {
    return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(plainText).toString("base64"), "base64");
  }
};
var Deserializer = class {
  static deserializeJSONBlob(jsonFile) {
    const deserializedCache = StringUtils.isEmpty(jsonFile) ? {} : JSON.parse(jsonFile);
    return deserializedCache;
  }
  static deserializeAccounts(accounts) {
    const accountObjects = {};
    if (accounts) {
      Object.keys(accounts).map(function(key) {
        const serializedAcc = accounts[key];
        const mappedAcc = {
          homeAccountId: serializedAcc.home_account_id,
          environment: serializedAcc.environment,
          realm: serializedAcc.realm,
          localAccountId: serializedAcc.local_account_id,
          username: serializedAcc.username,
          authorityType: serializedAcc.authority_type,
          name: serializedAcc.name,
          clientInfo: serializedAcc.client_info,
          lastModificationTime: serializedAcc.last_modification_time,
          lastModificationApp: serializedAcc.last_modification_app
        };
        const account = new AccountEntity();
        CacheManager.toObject(account, mappedAcc);
        accountObjects[key] = account;
      });
    }
    return accountObjects;
  }
  static deserializeIdTokens(idTokens) {
    const idObjects = {};
    if (idTokens) {
      Object.keys(idTokens).map(function(key) {
        const serializedIdT = idTokens[key];
        const mappedIdT = {
          homeAccountId: serializedIdT.home_account_id,
          environment: serializedIdT.environment,
          credentialType: serializedIdT.credential_type,
          clientId: serializedIdT.client_id,
          secret: serializedIdT.secret,
          realm: serializedIdT.realm
        };
        const idToken = new IdTokenEntity();
        CacheManager.toObject(idToken, mappedIdT);
        idObjects[key] = idToken;
      });
    }
    return idObjects;
  }
  static deserializeAccessTokens(accessTokens) {
    const atObjects = {};
    if (accessTokens) {
      Object.keys(accessTokens).map(function(key) {
        const serializedAT = accessTokens[key];
        const mappedAT = {
          homeAccountId: serializedAT.home_account_id,
          environment: serializedAT.environment,
          credentialType: serializedAT.credential_type,
          clientId: serializedAT.client_id,
          secret: serializedAT.secret,
          realm: serializedAT.realm,
          target: serializedAT.target,
          cachedAt: serializedAT.cached_at,
          expiresOn: serializedAT.expires_on,
          extendedExpiresOn: serializedAT.extended_expires_on,
          refreshOn: serializedAT.refresh_on,
          keyId: serializedAT.key_id,
          tokenType: serializedAT.token_type,
          requestedClaims: serializedAT.requestedClaims,
          requestedClaimsHash: serializedAT.requestedClaimsHash
        };
        const accessToken = new AccessTokenEntity();
        CacheManager.toObject(accessToken, mappedAT);
        atObjects[key] = accessToken;
      });
    }
    return atObjects;
  }
  static deserializeRefreshTokens(refreshTokens) {
    const rtObjects = {};
    if (refreshTokens) {
      Object.keys(refreshTokens).map(function(key) {
        const serializedRT = refreshTokens[key];
        const mappedRT = {
          homeAccountId: serializedRT.home_account_id,
          environment: serializedRT.environment,
          credentialType: serializedRT.credential_type,
          clientId: serializedRT.client_id,
          secret: serializedRT.secret,
          familyId: serializedRT.family_id,
          target: serializedRT.target,
          realm: serializedRT.realm
        };
        const refreshToken = new RefreshTokenEntity();
        CacheManager.toObject(refreshToken, mappedRT);
        rtObjects[key] = refreshToken;
      });
    }
    return rtObjects;
  }
  static deserializeAppMetadata(appMetadata) {
    const appMetadataObjects = {};
    if (appMetadata) {
      Object.keys(appMetadata).map(function(key) {
        const serializedAmdt = appMetadata[key];
        const mappedAmd = {
          clientId: serializedAmdt.client_id,
          environment: serializedAmdt.environment,
          familyId: serializedAmdt.family_id
        };
        const amd = new AppMetadataEntity();
        CacheManager.toObject(amd, mappedAmd);
        appMetadataObjects[key] = amd;
      });
    }
    return appMetadataObjects;
  }
  static deserializeAllCache(jsonCache) {
    return {
      accounts: jsonCache.Account ? this.deserializeAccounts(jsonCache.Account) : {},
      idTokens: jsonCache.IdToken ? this.deserializeIdTokens(jsonCache.IdToken) : {},
      accessTokens: jsonCache.AccessToken ? this.deserializeAccessTokens(jsonCache.AccessToken) : {},
      refreshTokens: jsonCache.RefreshToken ? this.deserializeRefreshTokens(jsonCache.RefreshToken) : {},
      appMetadata: jsonCache.AppMetadata ? this.deserializeAppMetadata(jsonCache.AppMetadata) : {}
    };
  }
};
var Serializer = class {
  static serializeJSONBlob(data) {
    return JSON.stringify(data);
  }
  static serializeAccounts(accCache) {
    const accounts = {};
    Object.keys(accCache).map(function(key) {
      const accountEntity = accCache[key];
      accounts[key] = {
        home_account_id: accountEntity.homeAccountId,
        environment: accountEntity.environment,
        realm: accountEntity.realm,
        local_account_id: accountEntity.localAccountId,
        username: accountEntity.username,
        authority_type: accountEntity.authorityType,
        name: accountEntity.name,
        client_info: accountEntity.clientInfo,
        last_modification_time: accountEntity.lastModificationTime,
        last_modification_app: accountEntity.lastModificationApp
      };
    });
    return accounts;
  }
  static serializeIdTokens(idTCache) {
    const idTokens = {};
    Object.keys(idTCache).map(function(key) {
      const idTEntity = idTCache[key];
      idTokens[key] = {
        home_account_id: idTEntity.homeAccountId,
        environment: idTEntity.environment,
        credential_type: idTEntity.credentialType,
        client_id: idTEntity.clientId,
        secret: idTEntity.secret,
        realm: idTEntity.realm
      };
    });
    return idTokens;
  }
  static serializeAccessTokens(atCache) {
    const accessTokens = {};
    Object.keys(atCache).map(function(key) {
      const atEntity = atCache[key];
      accessTokens[key] = {
        home_account_id: atEntity.homeAccountId,
        environment: atEntity.environment,
        credential_type: atEntity.credentialType,
        client_id: atEntity.clientId,
        secret: atEntity.secret,
        realm: atEntity.realm,
        target: atEntity.target,
        cached_at: atEntity.cachedAt,
        expires_on: atEntity.expiresOn,
        extended_expires_on: atEntity.extendedExpiresOn,
        refresh_on: atEntity.refreshOn,
        key_id: atEntity.keyId,
        token_type: atEntity.tokenType,
        requestedClaims: atEntity.requestedClaims,
        requestedClaimsHash: atEntity.requestedClaimsHash
      };
    });
    return accessTokens;
  }
  static serializeRefreshTokens(rtCache) {
    const refreshTokens = {};
    Object.keys(rtCache).map(function(key) {
      const rtEntity = rtCache[key];
      refreshTokens[key] = {
        home_account_id: rtEntity.homeAccountId,
        environment: rtEntity.environment,
        credential_type: rtEntity.credentialType,
        client_id: rtEntity.clientId,
        secret: rtEntity.secret,
        family_id: rtEntity.familyId,
        target: rtEntity.target,
        realm: rtEntity.realm
      };
    });
    return refreshTokens;
  }
  static serializeAppMetadata(amdtCache) {
    const appMetadata = {};
    Object.keys(amdtCache).map(function(key) {
      const amdtEntity = amdtCache[key];
      appMetadata[key] = {
        client_id: amdtEntity.clientId,
        environment: amdtEntity.environment,
        family_id: amdtEntity.familyId
      };
    });
    return appMetadata;
  }
  static serializeAllCache(inMemCache) {
    return {
      Account: this.serializeAccounts(inMemCache.accounts),
      IdToken: this.serializeIdTokens(inMemCache.idTokens),
      AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),
      RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),
      AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata)
    };
  }
};
var NodeStorage = class extends CacheManager {
  constructor(logger, clientId, cryptoImpl) {
    super(clientId, cryptoImpl);
    this.cache = {};
    this.changeEmitters = [];
    this.logger = logger;
  }
  registerChangeEmitter(func) {
    this.changeEmitters.push(func);
  }
  emitChange() {
    this.changeEmitters.forEach((func) => func.call(null));
  }
  cacheToInMemoryCache(cache) {
    const inMemoryCache = {
      accounts: {},
      idTokens: {},
      accessTokens: {},
      refreshTokens: {},
      appMetadata: {}
    };
    for (const key in cache) {
      if (cache[key] instanceof AccountEntity) {
        inMemoryCache.accounts[key] = cache[key];
      } else if (cache[key] instanceof IdTokenEntity) {
        inMemoryCache.idTokens[key] = cache[key];
      } else if (cache[key] instanceof AccessTokenEntity) {
        inMemoryCache.accessTokens[key] = cache[key];
      } else if (cache[key] instanceof RefreshTokenEntity) {
        inMemoryCache.refreshTokens[key] = cache[key];
      } else if (cache[key] instanceof AppMetadataEntity) {
        inMemoryCache.appMetadata[key] = cache[key];
      } else {
        continue;
      }
    }
    return inMemoryCache;
  }
  inMemoryCacheToCache(inMemoryCache) {
    let cache = this.getCache();
    cache = {
      ...cache,
      ...inMemoryCache.accounts,
      ...inMemoryCache.idTokens,
      ...inMemoryCache.accessTokens,
      ...inMemoryCache.refreshTokens,
      ...inMemoryCache.appMetadata
    };
    return cache;
  }
  getInMemoryCache() {
    this.logger.trace("Getting in-memory cache");
    const inMemoryCache = this.cacheToInMemoryCache(this.getCache());
    return inMemoryCache;
  }
  setInMemoryCache(inMemoryCache) {
    this.logger.trace("Setting in-memory cache");
    const cache = this.inMemoryCacheToCache(inMemoryCache);
    this.setCache(cache);
    this.emitChange();
  }
  getCache() {
    this.logger.trace("Getting cache key-value store");
    return this.cache;
  }
  setCache(cache) {
    this.logger.trace("Setting cache key value store");
    this.cache = cache;
    this.emitChange();
  }
  getItem(key) {
    this.logger.tracePii(`Item key: ${key}`);
    const cache = this.getCache();
    return cache[key];
  }
  setItem(key, value) {
    this.logger.tracePii(`Item key: ${key}`);
    const cache = this.getCache();
    cache[key] = value;
    this.setCache(cache);
  }
  getAccount(accountKey) {
    const account = this.getItem(accountKey);
    if (AccountEntity.isAccountEntity(account)) {
      return account;
    }
    return null;
  }
  setAccount(account) {
    const accountKey = account.generateAccountKey();
    this.setItem(accountKey, account);
  }
  getIdTokenCredential(idTokenKey) {
    const idToken = this.getItem(idTokenKey);
    if (IdTokenEntity.isIdTokenEntity(idToken)) {
      return idToken;
    }
    return null;
  }
  setIdTokenCredential(idToken) {
    const idTokenKey = idToken.generateCredentialKey();
    this.setItem(idTokenKey, idToken);
  }
  getAccessTokenCredential(accessTokenKey) {
    const accessToken = this.getItem(accessTokenKey);
    if (AccessTokenEntity.isAccessTokenEntity(accessToken)) {
      return accessToken;
    }
    return null;
  }
  setAccessTokenCredential(accessToken) {
    const accessTokenKey = accessToken.generateCredentialKey();
    this.setItem(accessTokenKey, accessToken);
  }
  getRefreshTokenCredential(refreshTokenKey) {
    const refreshToken = this.getItem(refreshTokenKey);
    if (RefreshTokenEntity.isRefreshTokenEntity(refreshToken)) {
      return refreshToken;
    }
    return null;
  }
  setRefreshTokenCredential(refreshToken) {
    const refreshTokenKey = refreshToken.generateCredentialKey();
    this.setItem(refreshTokenKey, refreshToken);
  }
  getAppMetadata(appMetadataKey) {
    const appMetadata = this.getItem(appMetadataKey);
    if (AppMetadataEntity.isAppMetadataEntity(appMetadataKey, appMetadata)) {
      return appMetadata;
    }
    return null;
  }
  setAppMetadata(appMetadata) {
    const appMetadataKey = appMetadata.generateAppMetadataKey();
    this.setItem(appMetadataKey, appMetadata);
  }
  getServerTelemetry(serverTelemetrykey) {
    const serverTelemetryEntity = this.getItem(serverTelemetrykey);
    if (serverTelemetryEntity && ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {
      return serverTelemetryEntity;
    }
    return null;
  }
  setServerTelemetry(serverTelemetryKey, serverTelemetry) {
    this.setItem(serverTelemetryKey, serverTelemetry);
  }
  getAuthorityMetadata(key) {
    const authorityMetadataEntity = this.getItem(key);
    if (authorityMetadataEntity && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, authorityMetadataEntity)) {
      return authorityMetadataEntity;
    }
    return null;
  }
  getAuthorityMetadataKeys() {
    return this.getKeys().filter((key) => {
      return this.isAuthorityMetadata(key);
    });
  }
  setAuthorityMetadata(key, metadata) {
    this.setItem(key, metadata);
  }
  getThrottlingCache(throttlingCacheKey) {
    const throttlingCache = this.getItem(throttlingCacheKey);
    if (throttlingCache && ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {
      return throttlingCache;
    }
    return null;
  }
  setThrottlingCache(throttlingCacheKey, throttlingCache) {
    this.setItem(throttlingCacheKey, throttlingCache);
  }
  removeItem(key) {
    this.logger.tracePii(`Item key: ${key}`);
    let result = false;
    const cache = this.getCache();
    if (!!cache[key]) {
      delete cache[key];
      result = true;
    }
    if (result) {
      this.setCache(cache);
      this.emitChange();
    }
    return result;
  }
  containsKey(key) {
    return this.getKeys().includes(key);
  }
  getKeys() {
    this.logger.trace("Retrieving all cache keys");
    const cache = this.getCache();
    return [...Object.keys(cache)];
  }
  async clear() {
    this.logger.trace("Clearing cache entries created by MSAL");
    const cacheKeys = this.getKeys();
    cacheKeys.forEach((key) => {
      this.removeItem(key);
    });
    this.emitChange();
  }
  static generateInMemoryCache(cache) {
    return Deserializer.deserializeAllCache(Deserializer.deserializeJSONBlob(cache));
  }
  static generateJsonCache(inMemoryCache) {
    return Serializer.serializeAllCache(inMemoryCache);
  }
  updateCredentialCacheKey(currentCacheKey, credential) {
    const updatedCacheKey = credential.generateCredentialKey();
    if (currentCacheKey !== updatedCacheKey) {
      const cacheItem = this.getItem(currentCacheKey);
      if (cacheItem) {
        this.removeItem(currentCacheKey);
        this.setItem(updatedCacheKey, cacheItem);
        this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);
        return updatedCacheKey;
      } else {
        this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);
      }
    }
    return currentCacheKey;
  }
};
var defaultSerializedCache = {
  Account: {},
  IdToken: {},
  AccessToken: {},
  RefreshToken: {},
  AppMetadata: {}
};
var TokenCache = class {
  constructor(storage, logger, cachePlugin) {
    this.cacheHasChanged = false;
    this.storage = storage;
    this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));
    if (cachePlugin) {
      this.persistence = cachePlugin;
    }
    this.logger = logger;
  }
  hasChanged() {
    return this.cacheHasChanged;
  }
  serialize() {
    this.logger.trace("Serializing in-memory cache");
    let finalState = Serializer.serializeAllCache(this.storage.getInMemoryCache());
    if (!StringUtils.isEmpty(this.cacheSnapshot)) {
      this.logger.trace("Reading cache snapshot from disk");
      finalState = this.mergeState(JSON.parse(this.cacheSnapshot), finalState);
    } else {
      this.logger.trace("No cache snapshot to merge");
    }
    this.cacheHasChanged = false;
    return JSON.stringify(finalState);
  }
  deserialize(cache) {
    this.logger.trace("Deserializing JSON to in-memory cache");
    this.cacheSnapshot = cache;
    if (!StringUtils.isEmpty(this.cacheSnapshot)) {
      this.logger.trace("Reading cache snapshot from disk");
      const deserializedCache = Deserializer.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));
      this.storage.setInMemoryCache(deserializedCache);
    } else {
      this.logger.trace("No cache snapshot to deserialize");
    }
  }
  getKVStore() {
    return this.storage.getCache();
  }
  async getAllAccounts() {
    this.logger.trace("getAllAccounts called");
    let cacheContext;
    try {
      if (this.persistence) {
        cacheContext = new TokenCacheContext(this, false);
        await this.persistence.beforeCacheAccess(cacheContext);
      }
      return this.storage.getAllAccounts();
    } finally {
      if (this.persistence && cacheContext) {
        await this.persistence.afterCacheAccess(cacheContext);
      }
    }
  }
  async getAccountByHomeId(homeAccountId) {
    const allAccounts = await this.getAllAccounts();
    if (!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {
      return allAccounts.filter((accountObj) => accountObj.homeAccountId === homeAccountId)[0] || null;
    } else {
      return null;
    }
  }
  async getAccountByLocalId(localAccountId) {
    const allAccounts = await this.getAllAccounts();
    if (!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {
      return allAccounts.filter((accountObj) => accountObj.localAccountId === localAccountId)[0] || null;
    } else {
      return null;
    }
  }
  async removeAccount(account) {
    this.logger.trace("removeAccount called");
    let cacheContext;
    try {
      if (this.persistence) {
        cacheContext = new TokenCacheContext(this, true);
        await this.persistence.beforeCacheAccess(cacheContext);
      }
      await this.storage.removeAccount(AccountEntity.generateAccountCacheKey(account));
    } finally {
      if (this.persistence && cacheContext) {
        await this.persistence.afterCacheAccess(cacheContext);
      }
    }
  }
  handleChangeEvent() {
    this.cacheHasChanged = true;
  }
  mergeState(oldState, currentState) {
    this.logger.trace("Merging in-memory cache with cache snapshot");
    const stateAfterRemoval = this.mergeRemovals(oldState, currentState);
    return this.mergeUpdates(stateAfterRemoval, currentState);
  }
  mergeUpdates(oldState, newState) {
    Object.keys(newState).forEach((newKey) => {
      const newValue = newState[newKey];
      if (!oldState.hasOwnProperty(newKey)) {
        if (newValue !== null) {
          oldState[newKey] = newValue;
        }
      } else {
        const newValueNotNull = newValue !== null;
        const newValueIsObject = typeof newValue === "object";
        const newValueIsNotArray = !Array.isArray(newValue);
        const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== "undefined" && oldState[newKey] !== null;
        if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {
          this.mergeUpdates(oldState[newKey], newValue);
        } else {
          oldState[newKey] = newValue;
        }
      }
    });
    return oldState;
  }
  mergeRemovals(oldState, newState) {
    this.logger.trace("Remove updated entries in cache");
    const accounts = oldState.Account ? this.mergeRemovalsDict(oldState.Account, newState.Account) : oldState.Account;
    const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;
    const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;
    const idTokens = oldState.IdToken ? this.mergeRemovalsDict(oldState.IdToken, newState.IdToken) : oldState.IdToken;
    const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;
    return {
      ...oldState,
      Account: accounts,
      AccessToken: accessTokens,
      RefreshToken: refreshTokens,
      IdToken: idTokens,
      AppMetadata: appMetadata
    };
  }
  mergeRemovalsDict(oldState, newState) {
    const finalState = {
      ...oldState
    };
    Object.keys(oldState).forEach((oldKey) => {
      if (!newState || !newState.hasOwnProperty(oldKey)) {
        delete finalState[oldKey];
      }
    });
    return finalState;
  }
  overlayDefaults(passedInCache) {
    this.logger.trace("Overlaying input cache with the default cache");
    return {
      Account: {
        ...defaultSerializedCache.Account,
        ...passedInCache.Account
      },
      IdToken: {
        ...defaultSerializedCache.IdToken,
        ...passedInCache.IdToken
      },
      AccessToken: {
        ...defaultSerializedCache.AccessToken,
        ...passedInCache.AccessToken
      },
      RefreshToken: {
        ...defaultSerializedCache.RefreshToken,
        ...passedInCache.RefreshToken
      },
      AppMetadata: {
        ...defaultSerializedCache.AppMetadata,
        ...passedInCache.AppMetadata
      }
    };
  }
};
var name2 = "@azure/msal-node";
var version2 = "1.14.2";
var NodeAuthErrorMessage = {
  invalidLoopbackAddressType: {
    code: "invalid_loopback_server_address_type",
    desc: "Loopback server address is not type string. This is unexpected."
  },
  unableToLoadRedirectUri: {
    code: "unable_to_load_redirectUrl",
    desc: "Loopback server callback was invoked without a url. This is unexpected."
  },
  noAuthCodeInResponse: {
    code: "no_auth_code_in_response",
    desc: "No auth code found in the server response. Please check your network trace to determine what happened."
  },
  noLoopbackServerExists: {
    code: "no_loopback_server_exists",
    desc: "No loopback server exists yet."
  },
  loopbackServerAlreadyExists: {
    code: "loopback_server_already_exists",
    desc: "Loopback server already exists. Cannot create another."
  },
  loopbackServerTimeout: {
    code: "loopback_server_timeout",
    desc: "Timed out waiting for auth code listener to be registered."
  },
  stateNotFoundError: {
    code: "state_not_found",
    desc: "State not found. Please verify that the request originated from msal."
  }
};
var NodeAuthError = class extends AuthError {
  constructor(errorCode, errorMessage) {
    super(errorCode, errorMessage);
    this.name = "NodeAuthError";
  }
  static createInvalidLoopbackAddressTypeError() {
    return new NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code, `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`);
  }
  static createUnableToLoadRedirectUrlError() {
    return new NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code, `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`);
  }
  static createNoAuthCodeInResponseError() {
    return new NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code, `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`);
  }
  static createNoLoopbackServerExistsError() {
    return new NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code, `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`);
  }
  static createLoopbackServerAlreadyExistsError() {
    return new NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code, `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`);
  }
  static createLoopbackServerTimeoutError() {
    return new NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code, `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`);
  }
  static createStateNotFoundError() {
    return new NodeAuthError(NodeAuthErrorMessage.stateNotFoundError.code, NodeAuthErrorMessage.stateNotFoundError.desc);
  }
};
var ClientApplication = class {
  constructor(configuration) {
    this.config = buildAppConfiguration(configuration);
    this.cryptoProvider = new CryptoProvider();
    this.logger = new Logger(this.config.system.loggerOptions, name2, version2);
    this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider);
    this.tokenCache = new TokenCache(this.storage, this.logger, this.config.cache.cachePlugin);
  }
  async getAuthCodeUrl(request) {
    this.logger.info("getAuthCodeUrl called", request.correlationId);
    const validRequest = {
      ...request,
      ...await this.initializeBaseRequest(request),
      responseMode: request.responseMode || ResponseMode.QUERY,
      authenticationScheme: AuthenticationScheme.BEARER
    };
    const authClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, void 0, void 0, request.azureCloudOptions);
    const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);
    this.logger.verbose("Auth code client created", validRequest.correlationId);
    return authorizationCodeClient.getAuthCodeUrl(validRequest);
  }
  async acquireTokenByCode(request, authCodePayLoad) {
    this.logger.info("acquireTokenByCode called");
    if (request.state && authCodePayLoad) {
      this.logger.info("acquireTokenByCode - validating state");
      this.validateState(request.state, authCodePayLoad.state || "");
      authCodePayLoad = {
        ...authCodePayLoad,
        state: ""
      };
    }
    const validRequest = {
      ...request,
      ...await this.initializeBaseRequest(request),
      authenticationScheme: AuthenticationScheme.BEARER
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);
    try {
      const authClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request.azureCloudOptions);
      const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);
      this.logger.verbose("Auth code client created", validRequest.correlationId);
      return authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  async acquireTokenByRefreshToken(request) {
    this.logger.info("acquireTokenByRefreshToken called", request.correlationId);
    const validRequest = {
      ...request,
      ...await this.initializeBaseRequest(request),
      authenticationScheme: AuthenticationScheme.BEARER
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);
    try {
      const refreshTokenClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request.azureCloudOptions);
      const refreshTokenClient = new RefreshTokenClient(refreshTokenClientConfig);
      this.logger.verbose("Refresh token client created", validRequest.correlationId);
      return refreshTokenClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  async acquireTokenSilent(request) {
    const validRequest = {
      ...request,
      ...await this.initializeBaseRequest(request),
      forceRefresh: request.forceRefresh || false
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);
    try {
      const silentFlowClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request.azureCloudOptions);
      const silentFlowClient = new SilentFlowClient(silentFlowClientConfig);
      this.logger.verbose("Silent flow client created", validRequest.correlationId);
      return silentFlowClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  async acquireTokenByUsernamePassword(request) {
    this.logger.info("acquireTokenByUsernamePassword called", request.correlationId);
    const validRequest = {
      ...request,
      ...await this.initializeBaseRequest(request)
    };
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);
    try {
      const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request.azureCloudOptions);
      const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);
      this.logger.verbose("Username password client created", validRequest.correlationId);
      return usernamePasswordClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  getTokenCache() {
    this.logger.info("getTokenCache called");
    return this.tokenCache;
  }
  validateState(state, cachedState) {
    if (!state) {
      throw NodeAuthError.createStateNotFoundError();
    }
    if (state !== cachedState) {
      throw ClientAuthError.createStateMismatchError();
    }
  }
  getLogger() {
    return this.logger;
  }
  setLogger(logger) {
    this.logger = logger;
  }
  async buildOauthClientConfiguration(authority, requestCorrelationId, serverTelemetryManager, azureRegionConfiguration, azureCloudOptions) {
    this.logger.verbose("buildOauthClientConfiguration called", requestCorrelationId);
    const userAzureCloudOptions = azureCloudOptions ? azureCloudOptions : this.config.auth.azureCloudOptions;
    this.logger.verbose(`building oauth client configuration with the authority: ${authority}`, requestCorrelationId);
    const discoveredAuthority = await this.createAuthority(authority, azureRegionConfiguration, requestCorrelationId, userAzureCloudOptions);
    serverTelemetryManager == null ? void 0 : serverTelemetryManager.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);
    const clientConfiguration = {
      authOptions: {
        clientId: this.config.auth.clientId,
        authority: discoveredAuthority,
        clientCapabilities: this.config.auth.clientCapabilities
      },
      systemOptions: {
        proxyUrl: this.config.system.proxyUrl
      },
      loggerOptions: {
        logLevel: this.config.system.loggerOptions.logLevel,
        loggerCallback: this.config.system.loggerOptions.loggerCallback,
        piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,
        correlationId: requestCorrelationId
      },
      cryptoInterface: this.cryptoProvider,
      networkInterface: this.config.system.networkClient,
      storageInterface: this.storage,
      serverTelemetryManager,
      clientCredentials: {
        clientSecret: this.clientSecret,
        clientAssertion: this.clientAssertion ? this.getClientAssertion(discoveredAuthority) : void 0
      },
      libraryInfo: {
        sku: Constants2.MSAL_SKU,
        version: version2,
        cpu: process.arch || Constants.EMPTY_STRING,
        os: process.platform || Constants.EMPTY_STRING
      },
      telemetry: this.config.telemetry,
      persistencePlugin: this.config.cache.cachePlugin,
      serializableCache: this.tokenCache
    };
    return clientConfiguration;
  }
  getClientAssertion(authority) {
    return {
      assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),
      assertionType: Constants2.JWT_BEARER_ASSERTION_TYPE
    };
  }
  async initializeBaseRequest(authRequest) {
    this.logger.verbose("initializeRequestScopes called", authRequest.correlationId);
    if (authRequest.authenticationScheme && authRequest.authenticationScheme === AuthenticationScheme.POP) {
      this.logger.verbose("Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request", authRequest.correlationId);
    }
    authRequest.authenticationScheme = AuthenticationScheme.BEARER;
    if (authRequest.claims && !StringUtils.isEmpty(authRequest.claims)) {
      authRequest.requestedClaimsHash = await this.cryptoProvider.hashString(authRequest.claims);
    }
    return {
      ...authRequest,
      scopes: [...authRequest && authRequest.scopes || [], ...OIDC_DEFAULT_SCOPES],
      correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),
      authority: authRequest.authority || this.config.auth.authority
    };
  }
  initializeServerTelemetryManager(apiId, correlationId, forceRefresh) {
    const telemetryPayload = {
      clientId: this.config.auth.clientId,
      correlationId,
      apiId,
      forceRefresh: forceRefresh || false
    };
    return new ServerTelemetryManager(telemetryPayload, this.storage);
  }
  async createAuthority(authorityString, azureRegionConfiguration, requestCorrelationId, azureCloudOptions) {
    this.logger.verbose("createAuthority called", requestCorrelationId);
    const authorityUrl = Authority.generateAuthority(authorityString, azureCloudOptions);
    const authorityOptions = {
      protocolMode: this.config.auth.protocolMode,
      knownAuthorities: this.config.auth.knownAuthorities,
      cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
      authorityMetadata: this.config.auth.authorityMetadata,
      azureRegionConfiguration,
      skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
    };
    return await AuthorityFactory.createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.config.system.proxyUrl);
  }
  clearCache() {
    this.storage.clear();
  }
};
var LoopbackClient = class {
  async listenForAuthCode(successTemplate, errorTemplate) {
    if (!!this.server) {
      throw NodeAuthError.createLoopbackServerAlreadyExistsError();
    }
    const authCodeListener = new Promise((resolve, reject) => {
      this.server = (0, import_http.createServer)(async (req, res) => {
        const url = req.url;
        if (!url) {
          res.end(errorTemplate || "Error occurred loading redirectUrl");
          reject(NodeAuthError.createUnableToLoadRedirectUrlError());
          return;
        } else if (url === Constants.FORWARD_SLASH) {
          res.end(successTemplate || "Auth code was successfully acquired. You can close this window now.");
          return;
        }
        const authCodeResponse = UrlString.getDeserializedQueryString(url);
        if (authCodeResponse.code) {
          const redirectUri = await this.getRedirectUri();
          res.writeHead(HttpStatus.REDIRECT, {
            location: redirectUri
          });
          res.end();
        }
        resolve(authCodeResponse);
      });
      this.server.listen(0);
    });
    await new Promise((resolve) => {
      let ticks = 0;
      const id = setInterval(() => {
        if (LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS / LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS < ticks) {
          throw NodeAuthError.createLoopbackServerTimeoutError();
        }
        if (this.server.listening) {
          clearInterval(id);
          resolve();
        }
        ticks++;
      }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);
    });
    return authCodeListener;
  }
  getRedirectUri() {
    if (!this.server) {
      throw NodeAuthError.createNoLoopbackServerExistsError();
    }
    const address = this.server.address();
    if (!address || typeof address === "string" || !address.port) {
      this.closeServer();
      throw NodeAuthError.createInvalidLoopbackAddressTypeError();
    }
    const port = address && address.port;
    return `${Constants2.HTTP_PROTOCOL}${Constants2.LOCALHOST}:${port}`;
  }
  closeServer() {
    if (!!this.server) {
      this.server.close();
    }
  }
};
var PublicClientApplication = class extends ClientApplication {
  constructor(configuration) {
    super(configuration);
  }
  async acquireTokenByDeviceCode(request) {
    this.logger.info("acquireTokenByDeviceCode called", request.correlationId);
    const validRequest = Object.assign(request, await this.initializeBaseRequest(request));
    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);
    try {
      const deviceCodeConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request.azureCloudOptions);
      const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);
      this.logger.verbose("Device code client created", validRequest.correlationId);
      return deviceCodeClient.acquireToken(validRequest);
    } catch (e) {
      if (e instanceof AuthError) {
        e.setCorrelationId(validRequest.correlationId);
      }
      serverTelemetryManager.cacheFailedRequest(e);
      throw e;
    }
  }
  async acquireTokenInteractive(request) {
    const {
      verifier,
      challenge
    } = await this.cryptoProvider.generatePkceCodes();
    const {
      openBrowser,
      successTemplate,
      errorTemplate,
      ...remainingProperties
    } = request;
    const loopbackClient = new LoopbackClient();
    const authCodeListener = loopbackClient.listenForAuthCode(successTemplate, errorTemplate);
    const redirectUri = loopbackClient.getRedirectUri();
    const validRequest = {
      ...remainingProperties,
      scopes: request.scopes || [],
      redirectUri,
      responseMode: ResponseMode.QUERY,
      codeChallenge: challenge,
      codeChallengeMethod: CodeChallengeMethodValues.S256
    };
    const authCodeUrl = await this.getAuthCodeUrl(validRequest);
    await openBrowser(authCodeUrl);
    const authCodeResponse = await authCodeListener.finally(() => {
      loopbackClient.closeServer();
    });
    if (authCodeResponse.error) {
      throw new ServerError(authCodeResponse.error, authCodeResponse.error_description, authCodeResponse.suberror);
    } else if (!authCodeResponse.code) {
      throw NodeAuthError.createNoAuthCodeInResponseError();
    }
    const clientInfo = authCodeResponse.client_info;
    const tokenRequest = {
      code: authCodeResponse.code,
      scopes: OIDC_DEFAULT_SCOPES,
      redirectUri: validRequest.redirectUri,
      codeVerifier: verifier,
      clientInfo: clientInfo || Constants.EMPTY_STRING
    };
    return this.acquireTokenByCode(tokenRequest);
  }
};

// node_modules/tslib/modules/index.js
var import_tslib27 = __toESM(require_tslib(), 1);
var {
  __extends: __extends2,
  __assign: __assign2,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter: __awaiter2,
  __generator: __generator2,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays: __spreadArrays2,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn
} = import_tslib27.default;

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/RequestMethod.js
var RequestMethod;
(function(RequestMethod2) {
  RequestMethod2["GET"] = "GET";
  RequestMethod2["PATCH"] = "PATCH";
  RequestMethod2["POST"] = "POST";
  RequestMethod2["PUT"] = "PUT";
  RequestMethod2["DELETE"] = "DELETE";
})(RequestMethod || (RequestMethod = {}));

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/content/BatchRequestContent.js
var BatchRequestContent = class {
  constructor(requests) {
    this.requests = /* @__PURE__ */ new Map();
    if (typeof requests !== "undefined") {
      const limit = BatchRequestContent.requestLimit;
      if (requests.length > limit) {
        const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);
        error.name = "Limit Exceeded Error";
        throw error;
      }
      for (const req of requests) {
        this.addRequest(req);
      }
    }
  }
  static validateDependencies(requests) {
    const isParallel = (reqs) => {
      const iterator = reqs.entries();
      let cur = iterator.next();
      while (!cur.done) {
        const curReq = cur.value[1];
        if (curReq.dependsOn !== void 0 && curReq.dependsOn.length > 0) {
          return false;
        }
        cur = iterator.next();
      }
      return true;
    };
    const isSerial = (reqs) => {
      const iterator = reqs.entries();
      let cur = iterator.next();
      const firstRequest = cur.value[1];
      if (firstRequest.dependsOn !== void 0 && firstRequest.dependsOn.length > 0) {
        return false;
      }
      let prev = cur;
      cur = iterator.next();
      while (!cur.done) {
        const curReq = cur.value[1];
        if (curReq.dependsOn === void 0 || curReq.dependsOn.length !== 1 || curReq.dependsOn[0] !== prev.value[1].id) {
          return false;
        }
        prev = cur;
        cur = iterator.next();
      }
      return true;
    };
    const isSame = (reqs) => {
      const iterator = reqs.entries();
      let cur = iterator.next();
      const firstRequest = cur.value[1];
      let dependencyId;
      if (firstRequest.dependsOn === void 0 || firstRequest.dependsOn.length === 0) {
        dependencyId = firstRequest.id;
      } else {
        if (firstRequest.dependsOn.length === 1) {
          const fDependencyId = firstRequest.dependsOn[0];
          if (fDependencyId !== firstRequest.id && reqs.has(fDependencyId)) {
            dependencyId = fDependencyId;
          } else {
            return false;
          }
        } else {
          return false;
        }
      }
      cur = iterator.next();
      while (!cur.done) {
        const curReq = cur.value[1];
        if ((curReq.dependsOn === void 0 || curReq.dependsOn.length === 0) && dependencyId !== curReq.id) {
          return false;
        }
        if (curReq.dependsOn !== void 0 && curReq.dependsOn.length !== 0) {
          if (curReq.dependsOn.length === 1 && (curReq.id === dependencyId || curReq.dependsOn[0] !== dependencyId)) {
            return false;
          }
          if (curReq.dependsOn.length > 1) {
            return false;
          }
        }
        cur = iterator.next();
      }
      return true;
    };
    if (requests.size === 0) {
      const error = new Error("Empty requests map, Please provide at least one request.");
      error.name = "Empty Requests Error";
      throw error;
    }
    return isParallel(requests) || isSerial(requests) || isSame(requests);
  }
  static getRequestData(request) {
    return __awaiter2(this, void 0, void 0, function* () {
      const requestData = {
        url: ""
      };
      const hasHttpRegex = new RegExp("^https?://");
      requestData.url = hasHttpRegex.test(request.url) ? "/" + request.url.split(/.*?\/\/.*?\//)[1] : request.url;
      requestData.method = request.method;
      const headers = {};
      request.headers.forEach((value, key) => {
        headers[key] = value;
      });
      if (Object.keys(headers).length) {
        requestData.headers = headers;
      }
      if (request.method === RequestMethod.PATCH || request.method === RequestMethod.POST || request.method === RequestMethod.PUT) {
        requestData.body = yield BatchRequestContent.getRequestBody(request);
      }
      return requestData;
    });
  }
  static getRequestBody(request) {
    return __awaiter2(this, void 0, void 0, function* () {
      let bodyParsed = false;
      let body;
      try {
        const cloneReq = request.clone();
        body = yield cloneReq.json();
        bodyParsed = true;
      } catch (e) {
      }
      if (!bodyParsed) {
        try {
          if (typeof Blob !== "undefined") {
            const blob = yield request.blob();
            const reader = new FileReader();
            body = yield new Promise((resolve) => {
              reader.addEventListener("load", () => {
                const dataURL = reader.result;
                const regex = new RegExp("^s*data:(.+?/.+?(;.+?=.+?)*)?(;base64)?,(.*)s*$");
                const segments = regex.exec(dataURL);
                resolve(segments[4]);
              }, false);
              reader.readAsDataURL(blob);
            });
          } else if (typeof Buffer !== "undefined") {
            const buffer = yield request.buffer();
            body = buffer.toString("base64");
          }
          bodyParsed = true;
        } catch (e) {
        }
      }
      return body;
    });
  }
  addRequest(request) {
    const limit = BatchRequestContent.requestLimit;
    if (request.id === "") {
      const error = new Error(`Id for a request is empty, Please provide an unique id`);
      error.name = "Empty Id For Request";
      throw error;
    }
    if (this.requests.size === limit) {
      const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);
      error.name = "Limit Exceeded Error";
      throw error;
    }
    if (this.requests.has(request.id)) {
      const error = new Error(`Adding request with duplicate id ${request.id}, Make the id of the requests unique`);
      error.name = "Duplicate RequestId Error";
      throw error;
    }
    this.requests.set(request.id, request);
    return request.id;
  }
  removeRequest(requestId) {
    const deleteStatus = this.requests.delete(requestId);
    const iterator = this.requests.entries();
    let cur = iterator.next();
    while (!cur.done) {
      const dependencies = cur.value[1].dependsOn;
      if (typeof dependencies !== "undefined") {
        const index = dependencies.indexOf(requestId);
        if (index !== -1) {
          dependencies.splice(index, 1);
        }
        if (dependencies.length === 0) {
          delete cur.value[1].dependsOn;
        }
      }
      cur = iterator.next();
    }
    return deleteStatus;
  }
  getContent() {
    return __awaiter2(this, void 0, void 0, function* () {
      const requests = [];
      const requestBody = {
        requests
      };
      const iterator = this.requests.entries();
      let cur = iterator.next();
      if (cur.done) {
        const error = new Error("No requests added yet, Please add at least one request.");
        error.name = "Empty Payload";
        throw error;
      }
      if (!BatchRequestContent.validateDependencies(this.requests)) {
        const error = new Error(`Invalid dependency found, Dependency should be:
1. Parallel - no individual request states a dependency in the dependsOn property.
2. Serial - all individual requests depend on the previous individual request.
3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.`);
        error.name = "Invalid Dependency";
        throw error;
      }
      while (!cur.done) {
        const requestStep = cur.value[1];
        const batchRequestData = yield BatchRequestContent.getRequestData(requestStep.request);
        if (batchRequestData.body !== void 0 && (batchRequestData.headers === void 0 || batchRequestData.headers["content-type"] === void 0)) {
          const error = new Error(`Content-type header is not mentioned for request #${requestStep.id}, For request having body, Content-type header should be mentioned`);
          error.name = "Invalid Content-type header";
          throw error;
        }
        batchRequestData.id = requestStep.id;
        if (requestStep.dependsOn !== void 0 && requestStep.dependsOn.length > 0) {
          batchRequestData.dependsOn = requestStep.dependsOn;
        }
        requests.push(batchRequestData);
        cur = iterator.next();
      }
      requestBody.requests = requests;
      return requestBody;
    });
  }
  addDependency(dependentId, dependencyId) {
    if (!this.requests.has(dependentId)) {
      const error = new Error(`Dependent ${dependentId} does not exists, Please check the id`);
      error.name = "Invalid Dependent";
      throw error;
    }
    if (typeof dependencyId !== "undefined" && !this.requests.has(dependencyId)) {
      const error = new Error(`Dependency ${dependencyId} does not exists, Please check the id`);
      error.name = "Invalid Dependency";
      throw error;
    }
    if (typeof dependencyId !== "undefined") {
      const dependent = this.requests.get(dependentId);
      if (dependent.dependsOn === void 0) {
        dependent.dependsOn = [];
      }
      if (dependent.dependsOn.indexOf(dependencyId) !== -1) {
        const error = new Error(`Dependency ${dependencyId} is already added for the request ${dependentId}`);
        error.name = "Duplicate Dependency";
        throw error;
      }
      dependent.dependsOn.push(dependencyId);
    } else {
      const iterator = this.requests.entries();
      let prev;
      let cur = iterator.next();
      while (!cur.done && cur.value[1].id !== dependentId) {
        prev = cur;
        cur = iterator.next();
      }
      if (typeof prev !== "undefined") {
        const dId = prev.value[0];
        if (cur.value[1].dependsOn === void 0) {
          cur.value[1].dependsOn = [];
        }
        if (cur.value[1].dependsOn.indexOf(dId) !== -1) {
          const error = new Error(`Dependency ${dId} is already added for the request ${dependentId}`);
          error.name = "Duplicate Dependency";
          throw error;
        }
        cur.value[1].dependsOn.push(dId);
      } else {
        const error = new Error(`Can't add dependency ${dependencyId}, There is only a dependent request in the batch`);
        error.name = "Invalid Dependency Addition";
        throw error;
      }
    }
  }
  removeDependency(dependentId, dependencyId) {
    const request = this.requests.get(dependentId);
    if (typeof request === "undefined" || request.dependsOn === void 0 || request.dependsOn.length === 0) {
      return false;
    }
    if (typeof dependencyId !== "undefined") {
      const index = request.dependsOn.indexOf(dependencyId);
      if (index === -1) {
        return false;
      }
      request.dependsOn.splice(index, 1);
      return true;
    } else {
      delete request.dependsOn;
      return true;
    }
  }
};
BatchRequestContent.requestLimit = 20;

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/Constants.js
var GRAPH_API_VERSION = "v1.0";
var GRAPH_BASE_URL = "https://graph.microsoft.com/";
var GRAPH_URLS = /* @__PURE__ */ new Set(["graph.microsoft.com", "graph.microsoft.us", "dod-graph.microsoft.us", "graph.microsoft.de", "microsoftgraph.chinacloudapi.cn", "canary.graph.microsoft.com"]);

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphClientError.js
var GraphClientError = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, GraphClientError.prototype);
  }
  static setGraphClientError(error) {
    let graphClientError;
    if (error instanceof Error) {
      graphClientError = error;
    } else {
      graphClientError = new GraphClientError();
      graphClientError.customError = error;
    }
    return graphClientError;
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphRequestUtil.js
var oDataQueryNames = ["$select", "$expand", "$orderby", "$filter", "$top", "$skip", "$skipToken", "$count"];
var urlJoin = (urlSegments) => {
  const removePostSlash = (s) => s.replace(/\/+$/, "");
  const removePreSlash = (s) => s.replace(/^\/+/, "");
  const joiner = (pre, cur) => [removePostSlash(pre), removePreSlash(cur)].join("/");
  const parts = Array.prototype.slice.call(urlSegments);
  return parts.reduce(joiner);
};
var serializeContent = (content) => {
  const className = content && content.constructor && content.constructor.name;
  if (className === "Buffer" || className === "Blob" || className === "File" || className === "FormData" || typeof content === "string") {
    return content;
  }
  if (className === "ArrayBuffer") {
    content = Buffer.from(content);
  } else if (className === "Int8Array" || className === "Int16Array" || className === "Int32Array" || className === "Uint8Array" || className === "Uint16Array" || className === "Uint32Array" || className === "Uint8ClampedArray" || className === "Float32Array" || className === "Float64Array" || className === "DataView") {
    content = Buffer.from(content.buffer);
  } else {
    try {
      content = JSON.stringify(content);
    } catch (error) {
      throw new Error("Unable to stringify the content");
    }
  }
  return content;
};
var isGraphURL = (url) => {
  return isValidEndpoint(url);
};
var isCustomHost = (url, customHosts) => {
  customHosts.forEach((host) => isCustomHostValid(host));
  return isValidEndpoint(url, customHosts);
};
var isValidEndpoint = (url, allowedHosts = GRAPH_URLS) => {
  url = url.toLowerCase();
  if (url.indexOf("https://") !== -1) {
    url = url.replace("https://", "");
    const startofPortNoPos = url.indexOf(":");
    const endOfHostStrPos = url.indexOf("/");
    let hostName = "";
    if (endOfHostStrPos !== -1) {
      if (startofPortNoPos !== -1 && startofPortNoPos < endOfHostStrPos) {
        hostName = url.substring(0, startofPortNoPos);
        return allowedHosts.has(hostName);
      }
      hostName = url.substring(0, endOfHostStrPos);
      return allowedHosts.has(hostName);
    }
  }
  return false;
};
var isCustomHostValid = (host) => {
  if (host.indexOf("/") !== -1) {
    throw new GraphClientError("Please add only hosts or hostnames to the CustomHosts config. If the url is `http://example.com:3000/`, host is `example:3000`");
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/MiddlewareControl.js
var MiddlewareControl = class {
  constructor(middlewareOptions = []) {
    this.middlewareOptions = /* @__PURE__ */ new Map();
    for (const option of middlewareOptions) {
      const fn = option.constructor;
      this.middlewareOptions.set(fn, option);
    }
  }
  getMiddlewareOptions(fn) {
    return this.middlewareOptions.get(fn);
  }
  setMiddlewareOptions(fn, option) {
    this.middlewareOptions.set(fn, option);
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/MiddlewareUtil.js
var generateUUID = () => {
  let uuid = "";
  for (let j = 0; j < 32; j++) {
    if (j === 8 || j === 12 || j === 16 || j === 20) {
      uuid += "-";
    }
    uuid += Math.floor(Math.random() * 16).toString(16);
  }
  return uuid;
};
var getRequestHeader = (request, options, key) => {
  let value = null;
  if (typeof Request !== "undefined" && request instanceof Request) {
    value = request.headers.get(key);
  } else if (typeof options !== "undefined" && options.headers !== void 0) {
    if (typeof Headers !== "undefined" && options.headers instanceof Headers) {
      value = options.headers.get(key);
    } else if (options.headers instanceof Array) {
      const headers = options.headers;
      for (let i = 0, l = headers.length; i < l; i++) {
        if (headers[i][0] === key) {
          value = headers[i][1];
          break;
        }
      }
    } else if (options.headers[key] !== void 0) {
      value = options.headers[key];
    }
  }
  return value;
};
var setRequestHeader = (request, options, key, value) => {
  if (typeof Request !== "undefined" && request instanceof Request) {
    request.headers.set(key, value);
  } else if (typeof options !== "undefined") {
    if (options.headers === void 0) {
      options.headers = new Headers({
        [key]: value
      });
    } else {
      if (typeof Headers !== "undefined" && options.headers instanceof Headers) {
        options.headers.set(key, value);
      } else if (options.headers instanceof Array) {
        let i = 0;
        const l = options.headers.length;
        for (; i < l; i++) {
          const header = options.headers[i];
          if (header[0] === key) {
            header[1] = value;
            break;
          }
        }
        if (i === l) {
          options.headers.push([key, value]);
        }
      } else {
        Object.assign(options.headers, { [key]: value });
      }
    }
  }
};
var appendRequestHeader = (request, options, key, value) => {
  if (typeof Request !== "undefined" && request instanceof Request) {
    request.headers.append(key, value);
  } else if (typeof options !== "undefined") {
    if (options.headers === void 0) {
      options.headers = new Headers({
        [key]: value
      });
    } else {
      if (typeof Headers !== "undefined" && options.headers instanceof Headers) {
        options.headers.append(key, value);
      } else if (options.headers instanceof Array) {
        options.headers.push([key, value]);
      } else if (options.headers === void 0) {
        options.headers = { [key]: value };
      } else if (options.headers[key] === void 0) {
        options.headers[key] = value;
      } else {
        options.headers[key] += `, ${value}`;
      }
    }
  }
};
var cloneRequestWithNewUrl = (newUrl, request) => __awaiter2(void 0, void 0, void 0, function* () {
  const body = request.headers.get("Content-Type") ? yield request.blob() : yield Promise.resolve(void 0);
  const { method, headers, referrer, referrerPolicy, mode, credentials, cache, redirect, integrity, keepalive, signal } = request;
  return new Request(newUrl, { method, headers, body, referrer, referrerPolicy, mode, credentials, cache, redirect, integrity, keepalive, signal });
});

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/AuthenticationHandlerOptions.js
var AuthenticationHandlerOptions = class {
  constructor(authenticationProvider, authenticationProviderOptions) {
    this.authenticationProvider = authenticationProvider;
    this.authenticationProviderOptions = authenticationProviderOptions;
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/TelemetryHandlerOptions.js
var FeatureUsageFlag;
(function(FeatureUsageFlag2) {
  FeatureUsageFlag2[FeatureUsageFlag2["NONE"] = 0] = "NONE";
  FeatureUsageFlag2[FeatureUsageFlag2["REDIRECT_HANDLER_ENABLED"] = 1] = "REDIRECT_HANDLER_ENABLED";
  FeatureUsageFlag2[FeatureUsageFlag2["RETRY_HANDLER_ENABLED"] = 2] = "RETRY_HANDLER_ENABLED";
  FeatureUsageFlag2[FeatureUsageFlag2["AUTHENTICATION_HANDLER_ENABLED"] = 4] = "AUTHENTICATION_HANDLER_ENABLED";
})(FeatureUsageFlag || (FeatureUsageFlag = {}));
var TelemetryHandlerOptions = class {
  constructor() {
    this.featureUsage = FeatureUsageFlag.NONE;
  }
  static updateFeatureUsageFlag(context, flag) {
    let options;
    if (context.middlewareControl instanceof MiddlewareControl) {
      options = context.middlewareControl.getMiddlewareOptions(TelemetryHandlerOptions);
    } else {
      context.middlewareControl = new MiddlewareControl();
    }
    if (typeof options === "undefined") {
      options = new TelemetryHandlerOptions();
      context.middlewareControl.setMiddlewareOptions(TelemetryHandlerOptions, options);
    }
    options.setFeatureUsage(flag);
  }
  setFeatureUsage(flag) {
    this.featureUsage = this.featureUsage | flag;
  }
  getFeatureUsage() {
    return this.featureUsage.toString(16);
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/AuthenticationHandler.js
var AuthenticationHandler = class {
  constructor(authenticationProvider) {
    this.authenticationProvider = authenticationProvider;
  }
  execute(context) {
    return __awaiter2(this, void 0, void 0, function* () {
      const url = typeof context.request === "string" ? context.request : context.request.url;
      if (isGraphURL(url) || context.customHosts && isCustomHost(url, context.customHosts)) {
        let options;
        if (context.middlewareControl instanceof MiddlewareControl) {
          options = context.middlewareControl.getMiddlewareOptions(AuthenticationHandlerOptions);
        }
        let authenticationProvider;
        let authenticationProviderOptions;
        if (options) {
          authenticationProvider = options.authenticationProvider;
          authenticationProviderOptions = options.authenticationProviderOptions;
        }
        if (!authenticationProvider) {
          authenticationProvider = this.authenticationProvider;
        }
        const token = yield authenticationProvider.getAccessToken(authenticationProviderOptions);
        const bearerKey = `Bearer ${token}`;
        appendRequestHeader(context.request, context.options, AuthenticationHandler.AUTHORIZATION_HEADER, bearerKey);
        TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.AUTHENTICATION_HANDLER_ENABLED);
      } else {
        if (context.options.headers) {
          delete context.options.headers[AuthenticationHandler.AUTHORIZATION_HEADER];
        }
      }
      return yield this.nextMiddleware.execute(context);
    });
  }
  setNext(next) {
    this.nextMiddleware = next;
  }
};
AuthenticationHandler.AUTHORIZATION_HEADER = "Authorization";

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/HTTPMessageHandler.js
var HTTPMessageHandler = class {
  execute(context) {
    return __awaiter2(this, void 0, void 0, function* () {
      context.response = yield fetch(context.request, context.options);
    });
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/RetryHandlerOptions.js
var RetryHandlerOptions = class {
  constructor(delay = RetryHandlerOptions.DEFAULT_DELAY, maxRetries = RetryHandlerOptions.DEFAULT_MAX_RETRIES, shouldRetry = RetryHandlerOptions.defaultShouldRetry) {
    if (delay > RetryHandlerOptions.MAX_DELAY && maxRetries > RetryHandlerOptions.MAX_MAX_RETRIES) {
      const error = new Error(`Delay and MaxRetries should not be more than ${RetryHandlerOptions.MAX_DELAY} and ${RetryHandlerOptions.MAX_MAX_RETRIES}`);
      error.name = "MaxLimitExceeded";
      throw error;
    } else if (delay > RetryHandlerOptions.MAX_DELAY) {
      const error = new Error(`Delay should not be more than ${RetryHandlerOptions.MAX_DELAY}`);
      error.name = "MaxLimitExceeded";
      throw error;
    } else if (maxRetries > RetryHandlerOptions.MAX_MAX_RETRIES) {
      const error = new Error(`MaxRetries should not be more than ${RetryHandlerOptions.MAX_MAX_RETRIES}`);
      error.name = "MaxLimitExceeded";
      throw error;
    } else if (delay < 0 && maxRetries < 0) {
      const error = new Error(`Delay and MaxRetries should not be negative`);
      error.name = "MinExpectationNotMet";
      throw error;
    } else if (delay < 0) {
      const error = new Error(`Delay should not be negative`);
      error.name = "MinExpectationNotMet";
      throw error;
    } else if (maxRetries < 0) {
      const error = new Error(`MaxRetries should not be negative`);
      error.name = "MinExpectationNotMet";
      throw error;
    }
    this.delay = Math.min(delay, RetryHandlerOptions.MAX_DELAY);
    this.maxRetries = Math.min(maxRetries, RetryHandlerOptions.MAX_MAX_RETRIES);
    this.shouldRetry = shouldRetry;
  }
  getMaxDelay() {
    return RetryHandlerOptions.MAX_DELAY;
  }
};
RetryHandlerOptions.DEFAULT_DELAY = 3;
RetryHandlerOptions.DEFAULT_MAX_RETRIES = 3;
RetryHandlerOptions.MAX_DELAY = 180;
RetryHandlerOptions.MAX_MAX_RETRIES = 10;
RetryHandlerOptions.defaultShouldRetry = () => true;

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/RetryHandler.js
var RetryHandler = class {
  constructor(options = new RetryHandlerOptions()) {
    this.options = options;
  }
  isRetry(response) {
    return RetryHandler.RETRY_STATUS_CODES.indexOf(response.status) !== -1;
  }
  isBuffered(request, options) {
    const method = typeof request === "string" ? options.method : request.method;
    const isPutPatchOrPost = method === RequestMethod.PUT || method === RequestMethod.PATCH || method === RequestMethod.POST;
    if (isPutPatchOrPost) {
      const isStream = getRequestHeader(request, options, "Content-Type") === "application/octet-stream";
      if (isStream) {
        return false;
      }
    }
    return true;
  }
  getDelay(response, retryAttempts, delay) {
    const getRandomness = () => Number(Math.random().toFixed(3));
    const retryAfter = response.headers !== void 0 ? response.headers.get(RetryHandler.RETRY_AFTER_HEADER) : null;
    let newDelay;
    if (retryAfter !== null) {
      if (Number.isNaN(Number(retryAfter))) {
        newDelay = Math.round((new Date(retryAfter).getTime() - Date.now()) / 1e3);
      } else {
        newDelay = Number(retryAfter);
      }
    } else {
      newDelay = retryAttempts >= 2 ? this.getExponentialBackOffTime(retryAttempts) + delay + getRandomness() : delay + getRandomness();
    }
    return Math.min(newDelay, this.options.getMaxDelay() + getRandomness());
  }
  getExponentialBackOffTime(attempts) {
    return Math.round(1 / 2 * (Math.pow(2, attempts) - 1));
  }
  sleep(delaySeconds) {
    return __awaiter2(this, void 0, void 0, function* () {
      const delayMilliseconds = delaySeconds * 1e3;
      return new Promise((resolve) => setTimeout(resolve, delayMilliseconds));
    });
  }
  getOptions(context) {
    let options;
    if (context.middlewareControl instanceof MiddlewareControl) {
      options = context.middlewareControl.getMiddlewareOptions(this.options.constructor);
    }
    if (typeof options === "undefined") {
      options = Object.assign(new RetryHandlerOptions(), this.options);
    }
    return options;
  }
  executeWithRetry(context, retryAttempts, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.nextMiddleware.execute(context);
      if (retryAttempts < options.maxRetries && this.isRetry(context.response) && this.isBuffered(context.request, context.options) && options.shouldRetry(options.delay, retryAttempts, context.request, context.options, context.response)) {
        ++retryAttempts;
        setRequestHeader(context.request, context.options, RetryHandler.RETRY_ATTEMPT_HEADER, retryAttempts.toString());
        const delay = this.getDelay(context.response, retryAttempts, options.delay);
        yield this.sleep(delay);
        return yield this.executeWithRetry(context, retryAttempts, options);
      } else {
        return;
      }
    });
  }
  execute(context) {
    return __awaiter2(this, void 0, void 0, function* () {
      const retryAttempts = 0;
      const options = this.getOptions(context);
      TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.RETRY_HANDLER_ENABLED);
      return yield this.executeWithRetry(context, retryAttempts, options);
    });
  }
  setNext(next) {
    this.nextMiddleware = next;
  }
};
RetryHandler.RETRY_STATUS_CODES = [
  429,
  503,
  504
];
RetryHandler.RETRY_ATTEMPT_HEADER = "Retry-Attempt";
RetryHandler.RETRY_AFTER_HEADER = "Retry-After";

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/RedirectHandlerOptions.js
var RedirectHandlerOptions = class {
  constructor(maxRedirects = RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS, shouldRedirect = RedirectHandlerOptions.defaultShouldRedirect) {
    if (maxRedirects > RedirectHandlerOptions.MAX_MAX_REDIRECTS) {
      const error = new Error(`MaxRedirects should not be more than ${RedirectHandlerOptions.MAX_MAX_REDIRECTS}`);
      error.name = "MaxLimitExceeded";
      throw error;
    }
    if (maxRedirects < 0) {
      const error = new Error(`MaxRedirects should not be negative`);
      error.name = "MinExpectationNotMet";
      throw error;
    }
    this.maxRedirects = maxRedirects;
    this.shouldRedirect = shouldRedirect;
  }
};
RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS = 5;
RedirectHandlerOptions.MAX_MAX_REDIRECTS = 20;
RedirectHandlerOptions.defaultShouldRedirect = () => true;

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/RedirectHandler.js
var RedirectHandler = class {
  constructor(options = new RedirectHandlerOptions()) {
    this.options = options;
  }
  isRedirect(response) {
    return RedirectHandler.REDIRECT_STATUS_CODES.indexOf(response.status) !== -1;
  }
  hasLocationHeader(response) {
    return response.headers.has(RedirectHandler.LOCATION_HEADER);
  }
  getLocationHeader(response) {
    return response.headers.get(RedirectHandler.LOCATION_HEADER);
  }
  isRelativeURL(url) {
    return url.indexOf("://") === -1;
  }
  shouldDropAuthorizationHeader(requestUrl, redirectUrl) {
    const schemeHostRegex = /^[A-Za-z].+?:\/\/.+?(?=\/|$)/;
    const requestMatches = schemeHostRegex.exec(requestUrl);
    let requestAuthority;
    let redirectAuthority;
    if (requestMatches !== null) {
      requestAuthority = requestMatches[0];
    }
    const redirectMatches = schemeHostRegex.exec(redirectUrl);
    if (redirectMatches !== null) {
      redirectAuthority = redirectMatches[0];
    }
    return typeof requestAuthority !== "undefined" && typeof redirectAuthority !== "undefined" && requestAuthority !== redirectAuthority;
  }
  updateRequestUrl(redirectUrl, context) {
    return __awaiter2(this, void 0, void 0, function* () {
      context.request = typeof context.request === "string" ? redirectUrl : yield cloneRequestWithNewUrl(redirectUrl, context.request);
    });
  }
  getOptions(context) {
    let options;
    if (context.middlewareControl instanceof MiddlewareControl) {
      options = context.middlewareControl.getMiddlewareOptions(RedirectHandlerOptions);
    }
    if (typeof options === "undefined") {
      options = Object.assign(new RedirectHandlerOptions(), this.options);
    }
    return options;
  }
  executeWithRedirect(context, redirectCount, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.nextMiddleware.execute(context);
      const response = context.response;
      if (redirectCount < options.maxRedirects && this.isRedirect(response) && this.hasLocationHeader(response) && options.shouldRedirect(response)) {
        ++redirectCount;
        if (response.status === RedirectHandler.STATUS_CODE_SEE_OTHER) {
          context.options.method = RequestMethod.GET;
          delete context.options.body;
        } else {
          const redirectUrl = this.getLocationHeader(response);
          if (!this.isRelativeURL(redirectUrl) && this.shouldDropAuthorizationHeader(response.url, redirectUrl)) {
            delete context.options.headers[RedirectHandler.AUTHORIZATION_HEADER];
          }
          yield this.updateRequestUrl(redirectUrl, context);
        }
        yield this.executeWithRedirect(context, redirectCount, options);
      } else {
        return;
      }
    });
  }
  execute(context) {
    return __awaiter2(this, void 0, void 0, function* () {
      const redirectCount = 0;
      const options = this.getOptions(context);
      context.options.redirect = RedirectHandler.MANUAL_REDIRECT;
      TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.REDIRECT_HANDLER_ENABLED);
      return yield this.executeWithRedirect(context, redirectCount, options);
    });
  }
  setNext(next) {
    this.nextMiddleware = next;
  }
};
RedirectHandler.REDIRECT_STATUS_CODES = [
  301,
  302,
  303,
  307,
  308
];
RedirectHandler.STATUS_CODE_SEE_OTHER = 303;
RedirectHandler.LOCATION_HEADER = "Location";
RedirectHandler.AUTHORIZATION_HEADER = "Authorization";
RedirectHandler.MANUAL_REDIRECT = "manual";

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/Version.js
var PACKAGE_VERSION = "3.0.3";

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/TelemetryHandler.js
var TelemetryHandler = class {
  execute(context) {
    return __awaiter2(this, void 0, void 0, function* () {
      const url = typeof context.request === "string" ? context.request : context.request.url;
      if (isGraphURL(url) || context.customHosts && isCustomHost(url, context.customHosts)) {
        let clientRequestId = getRequestHeader(context.request, context.options, TelemetryHandler.CLIENT_REQUEST_ID_HEADER);
        if (!clientRequestId) {
          clientRequestId = generateUUID();
          setRequestHeader(context.request, context.options, TelemetryHandler.CLIENT_REQUEST_ID_HEADER, clientRequestId);
        }
        let sdkVersionValue = `${TelemetryHandler.PRODUCT_NAME}/${PACKAGE_VERSION}`;
        let options;
        if (context.middlewareControl instanceof MiddlewareControl) {
          options = context.middlewareControl.getMiddlewareOptions(TelemetryHandlerOptions);
        }
        if (options) {
          const featureUsage = options.getFeatureUsage();
          sdkVersionValue += ` (${TelemetryHandler.FEATURE_USAGE_STRING}=${featureUsage})`;
        }
        appendRequestHeader(context.request, context.options, TelemetryHandler.SDK_VERSION_HEADER, sdkVersionValue);
      } else {
        delete context.options.headers[TelemetryHandler.CLIENT_REQUEST_ID_HEADER];
        delete context.options.headers[TelemetryHandler.SDK_VERSION_HEADER];
      }
      return yield this.nextMiddleware.execute(context);
    });
  }
  setNext(next) {
    this.nextMiddleware = next;
  }
};
TelemetryHandler.CLIENT_REQUEST_ID_HEADER = "client-request-id";
TelemetryHandler.SDK_VERSION_HEADER = "SdkVersion";
TelemetryHandler.PRODUCT_NAME = "graph-js";
TelemetryHandler.FEATURE_USAGE_STRING = "featureUsage";

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/ChaosStrategy.js
var ChaosStrategy;
(function(ChaosStrategy2) {
  ChaosStrategy2[ChaosStrategy2["MANUAL"] = 0] = "MANUAL";
  ChaosStrategy2[ChaosStrategy2["RANDOM"] = 1] = "RANDOM";
})(ChaosStrategy || (ChaosStrategy = {}));

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/ResponseType.js
var ResponseType;
(function(ResponseType2) {
  ResponseType2["ARRAYBUFFER"] = "arraybuffer";
  ResponseType2["BLOB"] = "blob";
  ResponseType2["DOCUMENT"] = "document";
  ResponseType2["JSON"] = "json";
  ResponseType2["RAW"] = "raw";
  ResponseType2["STREAM"] = "stream";
  ResponseType2["TEXT"] = "text";
})(ResponseType || (ResponseType = {}));

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphResponseHandler.js
var DocumentType;
(function(DocumentType2) {
  DocumentType2["TEXT_HTML"] = "text/html";
  DocumentType2["TEXT_XML"] = "text/xml";
  DocumentType2["APPLICATION_XML"] = "application/xml";
  DocumentType2["APPLICATION_XHTML"] = "application/xhtml+xml";
})(DocumentType || (DocumentType = {}));
var ContentType;
(function(ContentType2) {
  ContentType2["TEXT_PLAIN"] = "text/plain";
  ContentType2["APPLICATION_JSON"] = "application/json";
})(ContentType || (ContentType = {}));
var ContentTypeRegexStr;
(function(ContentTypeRegexStr2) {
  ContentTypeRegexStr2["DOCUMENT"] = "^(text\\/(html|xml))|(application\\/(xml|xhtml\\+xml))$";
  ContentTypeRegexStr2["IMAGE"] = "^image\\/.+";
})(ContentTypeRegexStr || (ContentTypeRegexStr = {}));
var GraphResponseHandler = class {
  static parseDocumentResponse(rawResponse, type) {
    if (typeof DOMParser !== "undefined") {
      return new Promise((resolve, reject) => {
        rawResponse.text().then((xmlString) => {
          try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, type);
            resolve(xmlDoc);
          } catch (error) {
            reject(error);
          }
        });
      });
    } else {
      return Promise.resolve(rawResponse.body);
    }
  }
  static convertResponse(rawResponse, responseType) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (rawResponse.status === 204) {
        return Promise.resolve();
      }
      let responseValue;
      const contentType = rawResponse.headers.get("Content-type");
      switch (responseType) {
        case ResponseType.ARRAYBUFFER:
          responseValue = yield rawResponse.arrayBuffer();
          break;
        case ResponseType.BLOB:
          responseValue = yield rawResponse.blob();
          break;
        case ResponseType.DOCUMENT:
          responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, DocumentType.TEXT_XML);
          break;
        case ResponseType.JSON:
          responseValue = yield rawResponse.json();
          break;
        case ResponseType.STREAM:
          responseValue = yield Promise.resolve(rawResponse.body);
          break;
        case ResponseType.TEXT:
          responseValue = yield rawResponse.text();
          break;
        default:
          if (contentType !== null) {
            const mimeType = contentType.split(";")[0];
            if (new RegExp(ContentTypeRegexStr.DOCUMENT).test(mimeType)) {
              responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, mimeType);
            } else if (new RegExp(ContentTypeRegexStr.IMAGE).test(mimeType)) {
              responseValue = rawResponse.blob();
            } else if (mimeType === ContentType.TEXT_PLAIN) {
              responseValue = yield rawResponse.text();
            } else if (mimeType === ContentType.APPLICATION_JSON) {
              responseValue = yield rawResponse.json();
            } else {
              responseValue = Promise.resolve(rawResponse.body);
            }
          } else {
            responseValue = Promise.resolve(rawResponse.body);
          }
          break;
      }
      return responseValue;
    });
  }
  static getResponse(rawResponse, responseType, callback) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (responseType === ResponseType.RAW) {
        return Promise.resolve(rawResponse);
      } else {
        const response = yield GraphResponseHandler.convertResponse(rawResponse, responseType);
        if (rawResponse.ok) {
          if (typeof callback === "function") {
            callback(null, response);
          } else {
            return response;
          }
        } else {
          throw response;
        }
      }
    });
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/Range.js
var Range = class {
  constructor(minVal = -1, maxVal = -1) {
    this.minValue = minVal;
    this.maxValue = maxVal;
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/UploadResult.js
var UploadResult = class {
  constructor(responseBody, location) {
    this._location = location;
    this._responseBody = responseBody;
  }
  get location() {
    return this._location;
  }
  set location(location) {
    this._location = location;
  }
  get responseBody() {
    return this._responseBody;
  }
  set responseBody(responseBody) {
    this._responseBody = responseBody;
  }
  static CreateUploadResult(responseBody, responseHeaders) {
    return new UploadResult(responseBody, responseHeaders.get("location"));
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/LargeFileUploadTask.js
var LargeFileUploadTask = class {
  constructor(client, file, uploadSession, options = {}) {
    this.DEFAULT_FILE_SIZE = 5 * 1024 * 1024;
    this.client = client;
    if (!file.sliceFile) {
      throw new GraphClientError("Please pass the FileUpload object, StreamUpload object or any custom implementation of the FileObject interface");
    } else {
      this.file = file;
    }
    this.file = file;
    if (!options.rangeSize) {
      options.rangeSize = this.DEFAULT_FILE_SIZE;
    }
    this.options = options;
    this.uploadSession = uploadSession;
    this.nextRange = new Range(0, this.options.rangeSize - 1);
  }
  static createUploadSession(client, requestUrl, payload, headers = {}) {
    return __awaiter2(this, void 0, void 0, function* () {
      const session = yield client.api(requestUrl).headers(headers).post(payload);
      const largeFileUploadSession = {
        url: session.uploadUrl,
        expiry: new Date(session.expirationDateTime),
        isCancelled: false
      };
      return largeFileUploadSession;
    });
  }
  parseRange(ranges) {
    const rangeStr = ranges[0];
    if (typeof rangeStr === "undefined" || rangeStr === "") {
      return new Range();
    }
    const firstRange = rangeStr.split("-");
    const minVal = parseInt(firstRange[0], 10);
    let maxVal = parseInt(firstRange[1], 10);
    if (Number.isNaN(maxVal)) {
      maxVal = this.file.size - 1;
    }
    return new Range(minVal, maxVal);
  }
  updateTaskStatus(response) {
    this.uploadSession.expiry = new Date(response.expirationDateTime);
    this.nextRange = this.parseRange(response.nextExpectedRanges);
  }
  getNextRange() {
    if (this.nextRange.minValue === -1) {
      return this.nextRange;
    }
    const minVal = this.nextRange.minValue;
    let maxValue = minVal + this.options.rangeSize - 1;
    if (maxValue >= this.file.size) {
      maxValue = this.file.size - 1;
    }
    return new Range(minVal, maxValue);
  }
  sliceFile(range) {
    console.warn("The LargeFileUploadTask.sliceFile() function has been deprecated and moved into the FileObject interface.");
    if (this.file.content instanceof ArrayBuffer || this.file.content instanceof Blob || this.file.content instanceof Uint8Array) {
      return this.file.content.slice(range.minValue, range.maxValue + 1);
    }
    throw new GraphClientError("The LargeFileUploadTask.sliceFile() function expects only Blob, ArrayBuffer or Uint8Array file content. Please note that the sliceFile() function is deprecated.");
  }
  upload() {
    return __awaiter2(this, void 0, void 0, function* () {
      const uploadEventHandlers = this.options && this.options.uploadEventHandlers;
      while (!this.uploadSession.isCancelled) {
        const nextRange = this.getNextRange();
        if (nextRange.maxValue === -1) {
          const err = new Error("Task with which you are trying to upload is already completed, Please check for your uploaded file");
          err.name = "Invalid Session";
          throw err;
        }
        const fileSlice = yield this.file.sliceFile(nextRange);
        const rawResponse = yield this.uploadSliceGetRawResponse(fileSlice, nextRange, this.file.size);
        if (!rawResponse) {
          throw new GraphClientError("Something went wrong! Large file upload slice response is null.");
        }
        const responseBody = yield GraphResponseHandler.getResponse(rawResponse);
        if (rawResponse.status === 201 || rawResponse.status === 200 && responseBody.id) {
          this.reportProgress(uploadEventHandlers, nextRange);
          return UploadResult.CreateUploadResult(responseBody, rawResponse.headers);
        }
        const res = {
          expirationDateTime: responseBody.expirationDateTime || responseBody.ExpirationDateTime,
          nextExpectedRanges: responseBody.NextExpectedRanges || responseBody.nextExpectedRanges
        };
        this.updateTaskStatus(res);
        this.reportProgress(uploadEventHandlers, nextRange);
      }
    });
  }
  reportProgress(uploadEventHandlers, nextRange) {
    if (uploadEventHandlers && uploadEventHandlers.progress) {
      uploadEventHandlers.progress(nextRange, uploadEventHandlers.extraCallbackParam);
    }
  }
  uploadSlice(fileSlice, range, totalSize) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield this.client.api(this.uploadSession.url).headers({
        "Content-Length": `${range.maxValue - range.minValue + 1}`,
        "Content-Range": `bytes ${range.minValue}-${range.maxValue}/${totalSize}`,
        "Content-Type": "application/octet-stream"
      }).put(fileSlice);
    });
  }
  uploadSliceGetRawResponse(fileSlice, range, totalSize) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield this.client.api(this.uploadSession.url).headers({
        "Content-Length": `${range.maxValue - range.minValue + 1}`,
        "Content-Range": `bytes ${range.minValue}-${range.maxValue}/${totalSize}`,
        "Content-Type": "application/octet-stream"
      }).responseType(ResponseType.RAW).put(fileSlice);
    });
  }
  cancel() {
    return __awaiter2(this, void 0, void 0, function* () {
      const cancelResponse = yield this.client.api(this.uploadSession.url).responseType(ResponseType.RAW).delete();
      if (cancelResponse.status === 204) {
        this.uploadSession.isCancelled = true;
      }
      return cancelResponse;
    });
  }
  getStatus() {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.client.api(this.uploadSession.url).get();
      this.updateTaskStatus(response);
      return response;
    });
  }
  resume() {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getStatus();
      return yield this.upload();
    });
  }
  getUploadSession() {
    return this.uploadSession;
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/FileObjectClasses/FileUpload.js
var FileUpload = class {
  constructor(content, name3, size) {
    this.content = content;
    this.name = name3;
    this.size = size;
    if (!content || !name3 || !size) {
      throw new GraphClientError("Please provide the upload content, name of the file and size of the file");
    }
  }
  sliceFile(range) {
    return this.content.slice(range.minValue, range.maxValue + 1);
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/OneDriveLargeFileUploadTaskUtil.js
var DEFAULT_FILE_SIZE = 5 * 1024 * 1024;
var roundTo320KB = (value) => {
  if (value > 320 * 1024) {
    value = Math.floor(value / (320 * 1024)) * 320 * 1024;
  }
  return value;
};
var getValidRangeSize = (rangeSize = DEFAULT_FILE_SIZE) => {
  const sixtyMB = 60 * 1024 * 1024;
  if (rangeSize > sixtyMB) {
    rangeSize = sixtyMB;
  }
  return roundTo320KB(rangeSize);
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/OneDriveLargeFileUploadTask.js
var OneDriveLargeFileUploadTask = class extends LargeFileUploadTask {
  constructor(client, file, uploadSession, options) {
    super(client, file, uploadSession, options);
  }
  static constructCreateSessionUrl(fileName, path = OneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH) {
    fileName = fileName.trim();
    path = path.trim();
    if (path === "") {
      path = "/";
    }
    if (path[0] !== "/") {
      path = `/${path}`;
    }
    if (path[path.length - 1] !== "/") {
      path = `${path}/`;
    }
    return `/me/drive/root:${path.split("/").map((p) => encodeURIComponent(p)).join("/")}${encodeURIComponent(fileName)}:/createUploadSession`;
  }
  static getFileInfo(file, fileName) {
    let content;
    let size;
    if (typeof Blob !== "undefined" && file instanceof Blob) {
      content = new File([file], fileName);
      size = content.size;
    } else if (typeof File !== "undefined" && file instanceof File) {
      content = file;
      size = content.size;
    } else if (typeof Uint8Array !== "undefined" && file instanceof Uint8Array) {
      const b = file;
      size = b.byteLength;
      content = b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);
    }
    return {
      content,
      size
    };
  }
  static create(client, file, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (!client || !file || !options) {
        throw new GraphClientError("Please provide the Graph client instance, file object and OneDriveLargeFileUploadOptions value");
      }
      const fileName = options.fileName;
      const fileInfo = OneDriveLargeFileUploadTask.getFileInfo(file, fileName);
      const fileObj = new FileUpload(fileInfo.content, fileName, fileInfo.size);
      return this.createTaskWithFileObject(client, fileObj, options);
    });
  }
  static createTaskWithFileObject(client, fileObject, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (!client || !fileObject || !options) {
        throw new GraphClientError("Please provide the Graph client instance, FileObject interface implementation and OneDriveLargeFileUploadOptions value");
      }
      const requestUrl = options.uploadSessionURL ? options.uploadSessionURL : OneDriveLargeFileUploadTask.constructCreateSessionUrl(options.fileName, options.path);
      const uploadSessionPayload = {
        fileName: options.fileName,
        fileDescription: options.fileDescription,
        conflictBehavior: options.conflictBehavior
      };
      const session = yield OneDriveLargeFileUploadTask.createUploadSession(client, requestUrl, uploadSessionPayload);
      const rangeSize = getValidRangeSize(options.rangeSize);
      return new OneDriveLargeFileUploadTask(client, fileObject, session, {
        rangeSize,
        uploadEventHandlers: options.uploadEventHandlers
      });
    });
  }
  static createUploadSession(client, requestUrl, payloadOptions) {
    const _super = Object.create(null, {
      createUploadSession: { get: () => super.createUploadSession }
    });
    return __awaiter2(this, void 0, void 0, function* () {
      const payload = {
        item: {
          "@microsoft.graph.conflictBehavior": (payloadOptions === null || payloadOptions === void 0 ? void 0 : payloadOptions.conflictBehavior) || "rename",
          name: payloadOptions === null || payloadOptions === void 0 ? void 0 : payloadOptions.fileName,
          description: payloadOptions === null || payloadOptions === void 0 ? void 0 : payloadOptions.fileDescription
        }
      };
      return _super.createUploadSession.call(this, client, requestUrl, payload);
    });
  }
  commit(requestUrl, conflictBehavior = "rename") {
    return __awaiter2(this, void 0, void 0, function* () {
      const payload = {
        name: this.file.name,
        "@microsoft.graph.conflictBehavior": conflictBehavior,
        "@microsoft.graph.sourceUrl": this.uploadSession.url
      };
      return yield this.client.api(requestUrl).put(payload);
    });
  }
};
OneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH = "/";

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/CustomAuthenticationProvider.js
var CustomAuthenticationProvider = class {
  constructor(provider) {
    this.provider = provider;
  }
  getAccessToken() {
    return __awaiter2(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => {
        this.provider((error, accessToken) => __awaiter2(this, void 0, void 0, function* () {
          if (accessToken) {
            resolve(accessToken);
          } else {
            if (!error) {
              const invalidTokenMessage = "Access token is undefined or empty.						Please provide a valid token.						For more help - https://github.com/microsoftgraph/msgraph-sdk-javascript/blob/dev/docs/CustomAuthenticationProvider.md";
              error = new GraphClientError(invalidTokenMessage);
            }
            const err = yield GraphClientError.setGraphClientError(error);
            reject(err);
          }
        }));
      });
    });
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphError.js
var GraphError = class extends Error {
  constructor(statusCode = -1, message, baseError) {
    super(message || baseError && baseError.message);
    Object.setPrototypeOf(this, GraphError.prototype);
    this.statusCode = statusCode;
    this.code = null;
    this.requestId = null;
    this.date = new Date();
    this.body = null;
    this.stack = baseError ? baseError.stack : this.stack;
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphErrorHandler.js
var GraphErrorHandler = class {
  static constructError(error, statusCode) {
    const gError = new GraphError(statusCode, "", error);
    if (error.name !== void 0) {
      gError.code = error.name;
    }
    gError.body = error.toString();
    gError.date = new Date();
    return gError;
  }
  static constructErrorFromResponse(graphError, statusCode) {
    const error = graphError.error;
    const gError = new GraphError(statusCode, error.message);
    gError.code = error.code;
    if (error.innerError !== void 0) {
      gError.requestId = error.innerError["request-id"];
      gError.date = new Date(error.innerError.date);
    }
    gError.body = JSON.stringify(error);
    return gError;
  }
  static getError(error = null, statusCode = -1, callback) {
    return __awaiter2(this, void 0, void 0, function* () {
      let gError;
      if (error && error.error) {
        gError = GraphErrorHandler.constructErrorFromResponse(error, statusCode);
      } else if (error instanceof Error) {
        gError = GraphErrorHandler.constructError(error, statusCode);
      } else {
        gError = new GraphError(statusCode);
        gError.body = error;
      }
      if (typeof callback === "function") {
        callback(gError, null);
      } else {
        return gError;
      }
    });
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphRequest.js
var GraphRequest = class {
  constructor(httpClient, config, path) {
    this.parsePath = (path2) => {
      if (path2.indexOf("https://") !== -1) {
        path2 = path2.replace("https://", "");
        const endOfHostStrPos = path2.indexOf("/");
        if (endOfHostStrPos !== -1) {
          this.urlComponents.host = "https://" + path2.substring(0, endOfHostStrPos);
          path2 = path2.substring(endOfHostStrPos + 1, path2.length);
        }
        const endOfVersionStrPos = path2.indexOf("/");
        if (endOfVersionStrPos !== -1) {
          this.urlComponents.version = path2.substring(0, endOfVersionStrPos);
          path2 = path2.substring(endOfVersionStrPos + 1, path2.length);
        }
      }
      if (path2.charAt(0) === "/") {
        path2 = path2.substr(1);
      }
      const queryStrPos = path2.indexOf("?");
      if (queryStrPos === -1) {
        this.urlComponents.path = path2;
      } else {
        this.urlComponents.path = path2.substr(0, queryStrPos);
        const queryParams = path2.substring(queryStrPos + 1, path2.length).split("&");
        for (const queryParam of queryParams) {
          this.parseQueryParameter(queryParam);
        }
      }
    };
    this.httpClient = httpClient;
    this.config = config;
    this.urlComponents = {
      host: this.config.baseUrl,
      version: this.config.defaultVersion,
      oDataQueryParams: {},
      otherURLQueryParams: {},
      otherURLQueryOptions: []
    };
    this._headers = {};
    this._options = {};
    this._middlewareOptions = [];
    this.parsePath(path);
  }
  addCsvQueryParameter(propertyName, propertyValue, additionalProperties) {
    this.urlComponents.oDataQueryParams[propertyName] = this.urlComponents.oDataQueryParams[propertyName] ? this.urlComponents.oDataQueryParams[propertyName] + "," : "";
    let allValues = [];
    if (additionalProperties.length > 1 && typeof propertyValue === "string") {
      allValues = Array.prototype.slice.call(additionalProperties);
    } else if (typeof propertyValue === "string") {
      allValues.push(propertyValue);
    } else {
      allValues = allValues.concat(propertyValue);
    }
    this.urlComponents.oDataQueryParams[propertyName] += allValues.join(",");
  }
  buildFullUrl() {
    const url = urlJoin([this.urlComponents.host, this.urlComponents.version, this.urlComponents.path]) + this.createQueryString();
    if (this.config.debugLogging) {
      console.log(url);
    }
    return url;
  }
  createQueryString() {
    const urlComponents = this.urlComponents;
    const query = [];
    if (Object.keys(urlComponents.oDataQueryParams).length !== 0) {
      for (const property in urlComponents.oDataQueryParams) {
        if (Object.prototype.hasOwnProperty.call(urlComponents.oDataQueryParams, property)) {
          query.push(property + "=" + urlComponents.oDataQueryParams[property]);
        }
      }
    }
    if (Object.keys(urlComponents.otherURLQueryParams).length !== 0) {
      for (const property in urlComponents.otherURLQueryParams) {
        if (Object.prototype.hasOwnProperty.call(urlComponents.otherURLQueryParams, property)) {
          query.push(property + "=" + urlComponents.otherURLQueryParams[property]);
        }
      }
    }
    if (urlComponents.otherURLQueryOptions.length !== 0) {
      for (const str of urlComponents.otherURLQueryOptions) {
        query.push(str);
      }
    }
    return query.length > 0 ? "?" + query.join("&") : "";
  }
  parseQueryParameter(queryDictionaryOrString) {
    if (typeof queryDictionaryOrString === "string") {
      if (queryDictionaryOrString.charAt(0) === "?") {
        queryDictionaryOrString = queryDictionaryOrString.substring(1);
      }
      if (queryDictionaryOrString.indexOf("&") !== -1) {
        const queryParams = queryDictionaryOrString.split("&");
        for (const str of queryParams) {
          this.parseQueryParamenterString(str);
        }
      } else {
        this.parseQueryParamenterString(queryDictionaryOrString);
      }
    } else if (queryDictionaryOrString.constructor === Object) {
      for (const key in queryDictionaryOrString) {
        if (Object.prototype.hasOwnProperty.call(queryDictionaryOrString, key)) {
          this.setURLComponentsQueryParamater(key, queryDictionaryOrString[key]);
        }
      }
    }
    return this;
  }
  parseQueryParamenterString(queryParameter) {
    if (this.isValidQueryKeyValuePair(queryParameter)) {
      const indexOfFirstEquals = queryParameter.indexOf("=");
      const paramKey = queryParameter.substring(0, indexOfFirstEquals);
      const paramValue = queryParameter.substring(indexOfFirstEquals + 1);
      this.setURLComponentsQueryParamater(paramKey, paramValue);
    } else {
      this.urlComponents.otherURLQueryOptions.push(queryParameter);
    }
  }
  setURLComponentsQueryParamater(paramKey, paramValue) {
    if (oDataQueryNames.indexOf(paramKey) !== -1) {
      const currentValue = this.urlComponents.oDataQueryParams[paramKey];
      const isValueAppendable = currentValue && (paramKey === "$expand" || paramKey === "$select" || paramKey === "$orderby");
      this.urlComponents.oDataQueryParams[paramKey] = isValueAppendable ? currentValue + "," + paramValue : paramValue;
    } else {
      this.urlComponents.otherURLQueryParams[paramKey] = paramValue;
    }
  }
  isValidQueryKeyValuePair(queryString) {
    const indexofFirstEquals = queryString.indexOf("=");
    if (indexofFirstEquals === -1) {
      return false;
    }
    const indexofOpeningParanthesis = queryString.indexOf("(");
    if (indexofOpeningParanthesis !== -1 && queryString.indexOf("(") < indexofFirstEquals) {
      return false;
    }
    return true;
  }
  updateRequestOptions(options) {
    const optionsHeaders = Object.assign({}, options.headers);
    if (this.config.fetchOptions !== void 0) {
      const fetchOptions = Object.assign({}, this.config.fetchOptions);
      Object.assign(options, fetchOptions);
      if (typeof this.config.fetchOptions.headers !== void 0) {
        options.headers = Object.assign({}, this.config.fetchOptions.headers);
      }
    }
    Object.assign(options, this._options);
    if (options.headers !== void 0) {
      Object.assign(optionsHeaders, options.headers);
    }
    Object.assign(optionsHeaders, this._headers);
    options.headers = optionsHeaders;
  }
  send(request, options, callback) {
    var _a;
    return __awaiter2(this, void 0, void 0, function* () {
      let rawResponse;
      const middlewareControl = new MiddlewareControl(this._middlewareOptions);
      this.updateRequestOptions(options);
      const customHosts = (_a = this.config) === null || _a === void 0 ? void 0 : _a.customHosts;
      try {
        const context = yield this.httpClient.sendRequest({
          request,
          options,
          middlewareControl,
          customHosts
        });
        rawResponse = context.response;
        const response = yield GraphResponseHandler.getResponse(rawResponse, this._responseType, callback);
        return response;
      } catch (error) {
        if (error instanceof GraphClientError) {
          throw error;
        }
        let statusCode;
        if (rawResponse) {
          statusCode = rawResponse.status;
        }
        const gError = yield GraphErrorHandler.getError(error, statusCode, callback);
        throw gError;
      }
    });
  }
  setHeaderContentType() {
    if (!this._headers) {
      this.header("Content-Type", "application/json");
      return;
    }
    const headerKeys = Object.keys(this._headers);
    for (const headerKey of headerKeys) {
      if (headerKey.toLowerCase() === "content-type") {
        return;
      }
    }
    this.header("Content-Type", "application/json");
  }
  header(headerKey, headerValue) {
    this._headers[headerKey] = headerValue;
    return this;
  }
  headers(headers) {
    for (const key in headers) {
      if (Object.prototype.hasOwnProperty.call(headers, key)) {
        this._headers[key] = headers[key];
      }
    }
    return this;
  }
  option(key, value) {
    this._options[key] = value;
    return this;
  }
  options(options) {
    for (const key in options) {
      if (Object.prototype.hasOwnProperty.call(options, key)) {
        this._options[key] = options[key];
      }
    }
    return this;
  }
  middlewareOptions(options) {
    this._middlewareOptions = options;
    return this;
  }
  version(version3) {
    this.urlComponents.version = version3;
    return this;
  }
  responseType(responseType) {
    this._responseType = responseType;
    return this;
  }
  select(properties) {
    this.addCsvQueryParameter("$select", properties, arguments);
    return this;
  }
  expand(properties) {
    this.addCsvQueryParameter("$expand", properties, arguments);
    return this;
  }
  orderby(properties) {
    this.addCsvQueryParameter("$orderby", properties, arguments);
    return this;
  }
  filter(filterStr) {
    this.urlComponents.oDataQueryParams.$filter = filterStr;
    return this;
  }
  search(searchStr) {
    this.urlComponents.oDataQueryParams.$search = searchStr;
    return this;
  }
  top(n) {
    this.urlComponents.oDataQueryParams.$top = n;
    return this;
  }
  skip(n) {
    this.urlComponents.oDataQueryParams.$skip = n;
    return this;
  }
  skipToken(token) {
    this.urlComponents.oDataQueryParams.$skipToken = token;
    return this;
  }
  count(isCount = true) {
    this.urlComponents.oDataQueryParams.$count = isCount.toString();
    return this;
  }
  query(queryDictionaryOrString) {
    return this.parseQueryParameter(queryDictionaryOrString);
  }
  get(callback) {
    return __awaiter2(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      const options = {
        method: RequestMethod.GET
      };
      const response = yield this.send(url, options, callback);
      return response;
    });
  }
  post(content, callback) {
    return __awaiter2(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      const options = {
        method: RequestMethod.POST,
        body: serializeContent(content)
      };
      const className = content && content.constructor && content.constructor.name;
      if (className === "FormData") {
        options.headers = {};
      } else {
        this.setHeaderContentType();
        options.headers = this._headers;
      }
      return yield this.send(url, options, callback);
    });
  }
  create(content, callback) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield this.post(content, callback);
    });
  }
  put(content, callback) {
    return __awaiter2(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      this.setHeaderContentType();
      const options = {
        method: RequestMethod.PUT,
        body: serializeContent(content)
      };
      return yield this.send(url, options, callback);
    });
  }
  patch(content, callback) {
    return __awaiter2(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      this.setHeaderContentType();
      const options = {
        method: RequestMethod.PATCH,
        body: serializeContent(content)
      };
      return yield this.send(url, options, callback);
    });
  }
  update(content, callback) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield this.patch(content, callback);
    });
  }
  delete(callback) {
    return __awaiter2(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      const options = {
        method: RequestMethod.DELETE
      };
      return yield this.send(url, options, callback);
    });
  }
  del(callback) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield this.delete(callback);
    });
  }
  getStream(callback) {
    return __awaiter2(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      const options = {
        method: RequestMethod.GET
      };
      this.responseType(ResponseType.STREAM);
      return yield this.send(url, options, callback);
    });
  }
  putStream(stream, callback) {
    return __awaiter2(this, void 0, void 0, function* () {
      const url = this.buildFullUrl();
      const options = {
        method: RequestMethod.PUT,
        headers: {
          "Content-Type": "application/octet-stream"
        },
        body: stream
      };
      return yield this.send(url, options, callback);
    });
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/HTTPClient.js
var HTTPClient = class {
  constructor(...middleware) {
    if (!middleware || !middleware.length) {
      const error = new Error();
      error.name = "InvalidMiddlewareChain";
      error.message = "Please provide a default middleware chain or custom middleware chain";
      throw error;
    }
    this.setMiddleware(...middleware);
  }
  setMiddleware(...middleware) {
    if (middleware.length > 1) {
      this.parseMiddleWareArray(middleware);
    } else {
      this.middleware = middleware[0];
    }
  }
  parseMiddleWareArray(middlewareArray) {
    middlewareArray.forEach((element, index) => {
      if (index < middlewareArray.length - 1) {
        element.setNext(middlewareArray[index + 1]);
      }
    });
    this.middleware = middlewareArray[0];
  }
  sendRequest(context) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (typeof context.request === "string" && context.options === void 0) {
        const error = new Error();
        error.name = "InvalidRequestOptions";
        error.message = "Unable to execute the middleware, Please provide valid options for a request";
        throw error;
      }
      yield this.middleware.execute(context);
      return context;
    });
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/HTTPClientFactory.js
var isNodeEnvironment = () => {
  return typeof process === "object" && typeof require === "function";
};
var HTTPClientFactory = class {
  static createWithAuthenticationProvider(authProvider) {
    const authenticationHandler = new AuthenticationHandler(authProvider);
    const retryHandler = new RetryHandler(new RetryHandlerOptions());
    const telemetryHandler = new TelemetryHandler();
    const httpMessageHandler = new HTTPMessageHandler();
    authenticationHandler.setNext(retryHandler);
    if (isNodeEnvironment()) {
      const redirectHandler = new RedirectHandler(new RedirectHandlerOptions());
      retryHandler.setNext(redirectHandler);
      redirectHandler.setNext(telemetryHandler);
    } else {
      retryHandler.setNext(telemetryHandler);
    }
    telemetryHandler.setNext(httpMessageHandler);
    return HTTPClientFactory.createWithMiddleware(authenticationHandler);
  }
  static createWithMiddleware(...middleware) {
    return new HTTPClient(...middleware);
  }
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/ValidatePolyFilling.js
var validatePolyFilling = () => {
  if (typeof Promise === "undefined" && typeof fetch === "undefined") {
    const error = new Error("Library cannot function without Promise and fetch. So, please provide polyfill for them.");
    error.name = "PolyFillNotAvailable";
    throw error;
  } else if (typeof Promise === "undefined") {
    const error = new Error("Library cannot function without Promise. So, please provide polyfill for it.");
    error.name = "PolyFillNotAvailable";
    throw error;
  } else if (typeof fetch === "undefined") {
    const error = new Error("Library cannot function without fetch. So, please provide polyfill for it.");
    error.name = "PolyFillNotAvailable";
    throw error;
  }
  return true;
};

// node_modules/@microsoft/microsoft-graph-client/lib/es/src/Client.js
var Client = class {
  constructor(clientOptions) {
    this.config = {
      baseUrl: GRAPH_BASE_URL,
      debugLogging: false,
      defaultVersion: GRAPH_API_VERSION
    };
    validatePolyFilling();
    for (const key in clientOptions) {
      if (Object.prototype.hasOwnProperty.call(clientOptions, key)) {
        this.config[key] = clientOptions[key];
      }
    }
    let httpClient;
    if (clientOptions.authProvider !== void 0 && clientOptions.middleware !== void 0) {
      const error = new Error();
      error.name = "AmbiguityInInitialization";
      error.message = "Unable to Create Client, Please provide either authentication provider for default middleware chain or custom middleware chain not both";
      throw error;
    } else if (clientOptions.authProvider !== void 0) {
      httpClient = HTTPClientFactory.createWithAuthenticationProvider(clientOptions.authProvider);
    } else if (clientOptions.middleware !== void 0) {
      httpClient = new HTTPClient(...[].concat(clientOptions.middleware));
    } else {
      const error = new Error();
      error.name = "InvalidMiddlewareChain";
      error.message = "Unable to Create Client, Please provide either authentication provider for default middleware chain or custom middleware chain";
      throw error;
    }
    this.httpClient = httpClient;
  }
  static init(options) {
    const clientOptions = {};
    for (const i in options) {
      if (Object.prototype.hasOwnProperty.call(options, i)) {
        clientOptions[i] = i === "authProvider" ? new CustomAuthenticationProvider(options[i]) : options[i];
      }
    }
    return Client.initWithMiddleware(clientOptions);
  }
  static initWithMiddleware(clientOptions) {
    return new Client(clientOptions);
  }
  api(path) {
    return new GraphRequest(this.httpClient, this.config, path);
  }
};

// src/api/todoApi.ts
var import_obsidian2 = require("obsidian");

// src/gui/microsoftAuthModal.ts
var import_obsidian = require("obsidian");
var MicrosoftAuthModal = class extends import_obsidian.Modal {
  constructor(deviceCode, authUrl) {
    super(app);
    this.deviceCode = deviceCode;
    this.authUrl = authUrl;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("auth-modal");
    contentEl.createEl("h2", { text: "\u9996\u6B21\u4F7F\u7528\u9700\u8981\u8FDB\u884C\u5FAE\u8F6F\u9A8C\u8BC1" });
    contentEl.createEl("h4", { text: this.deviceCode });
    contentEl.createEl("div", { text: "\u8BBE\u5907\u4EE3\u7801\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F\uFF0C\u8BF7\u70B9\u51FB\u4E0B\u9762\u7684\u94FE\u63A5\u9A8C\u8BC1" });
    contentEl.createEl("a", { text: this.authUrl, href: this.authUrl });
    contentEl.createEl("hr");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/api/todoApi.ts
var TodoApi = class {
  constructor() {
    new MicrosoftClientProvider().getClient().then((client) => this.client = client);
  }
  async getLists(searchPattern) {
    const endpoint = "/me/todo/lists";
    const todoLists = (await this.client.api(endpoint).get()).value;
    return await Promise.all(todoLists.map(async (taskList) => {
      const containedTasks = await this.getListTasks(taskList.id, searchPattern);
      return {
        ...taskList,
        tasks: containedTasks
      };
    }));
  }
  async getListIdByName(listName) {
    if (!listName)
      return;
    const endpoint = "/me/todo/lists";
    const res = (await this.client.api(endpoint).filter(`contains(displayName,'${listName}')`).get()).value;
    if (!res || res.length == 0)
      return;
    const target = res[0];
    return target.id;
  }
  async getList(listId) {
    if (!listId)
      return;
    const endpoint = `/me/todo/lists/${listId}`;
    return await this.client.api(endpoint).get();
  }
  async createTaskList(displayName) {
    if (!displayName)
      return;
    return await this.client.api("/me/todo/lists").post({
      displayName
    });
  }
  async getListTasks(listId, searchText) {
    if (!listId)
      return;
    const endpoint = `/me/todo/lists/${listId}/tasks`;
    if (!searchText)
      return;
    const res = await this.client.api(endpoint).filter(searchText).get().catch((err) => {
      new import_obsidian2.Notice("\u83B7\u53D6\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u540C\u6B65\u5217\u8868\u662F\u5426\u5DF2\u5220\u9664");
      return;
    });
    if (!res)
      return;
    return res.value;
  }
  async getTask(listId, taskId) {
    const endpoint = `/me/todo/lists/${listId}/tasks/${taskId}`;
    return await this.client.api(endpoint).get();
  }
  async createTask(listId, title, body) {
    const endpoint = `/me/todo/lists/${listId}/tasks`;
    return await this.client.api(endpoint).post({
      title,
      body: {
        content: body,
        contentType: "text"
      }
    });
  }
  async updateTask(listId, taskId, title) {
    const endpoint = `/me/todo/lists/${listId}/tasks/${taskId}`;
    return await this.client.api(endpoint).patch({
      title
    });
  }
};
var MicrosoftClientProvider = class {
  constructor() {
    this.clientId = "a1172059-5f55-45cd-9665-8dccc98c2587";
    this.authority = "https://login.microsoftonline.com/consumers";
    this.scopes = ["Tasks.ReadWrite", "openid", "profile"];
    this.adapter = app.vault.adapter;
    this.cachePath = `${app.vault.configDir}/Microsoft_cache.json`;
    const beforeCacheAccess = async (cacheContext) => {
      if (await this.adapter.exists(this.cachePath)) {
        cacheContext.tokenCache.deserialize(await this.adapter.read(this.cachePath));
      }
    };
    const afterCacheAccess = async (cacheContext) => {
      if (cacheContext.cacheHasChanged) {
        await this.adapter.write(this.cachePath, cacheContext.tokenCache.serialize());
      }
    };
    const cachePlugin = {
      beforeCacheAccess,
      afterCacheAccess
    };
    const config = {
      auth: {
        clientId: this.clientId,
        authority: this.authority
      },
      cache: {
        cachePlugin
      }
    };
    this.pca = new PublicClientApplication(config);
  }
  async getAccessToken() {
    const msalCacheManager = this.pca.getTokenCache();
    if (await this.adapter.exists(this.cachePath)) {
      msalCacheManager.deserialize(await this.adapter.read(this.cachePath));
    }
    const accounts = await msalCacheManager.getAllAccounts();
    if (accounts.length == 0) {
      return await this.authByDevice();
    } else {
      return await this.authByCache(accounts[0]);
    }
  }
  async authByDevice() {
    const deviceCodeRequest = {
      deviceCodeCallback: (response) => {
        new import_obsidian2.Notice("\u8BBE\u5907\u4EE3\u7801\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F,\u8BF7\u5728\u6253\u5F00\u7684\u6D4F\u89C8\u5668\u754C\u9762\u8F93\u5165");
        navigator.clipboard.writeText(response["userCode"]);
        new MicrosoftAuthModal(response["userCode"], response["verificationUri"]).open();
        console.log("\u8BBE\u5907\u4EE3\u7801\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F", response["userCode"]);
      },
      scopes: this.scopes
    };
    return await this.pca.acquireTokenByDeviceCode(deviceCodeRequest).then((res) => {
      return res == null ? "error" : res["accessToken"];
    });
  }
  async authByCache(account) {
    const silentRequest = {
      account,
      scopes: this.scopes
    };
    return await this.pca.acquireTokenSilent(silentRequest).then((res) => {
      return res == null ? "error" : res["accessToken"];
    }).catch(async (err) => {
      return await this.authByDevice();
    });
  }
  async getClient() {
    const authProvider = async (callback) => {
      const accessToken = await this.getAccessToken();
      const error = " ";
      callback(error, accessToken);
    };
    return Client.init({
      authProvider
    });
  }
};

// src/gui/msTodoSyncSettingTab.ts
var import_obsidian3 = require("obsidian");

// src/lib/locale/en.json
var en_default = {
  Language: "English",
  Complete: "Complete",
  Archive: "Archive",
  Untitled: "Untitled",
  default: "default",
  "Search...": "Search...",
  Enter: "Enter",
  Prepend: "Prepend",
  Append: "Append",
  Sunday: "Sunday",
  Monday: "Monday",
  Tuesday: "Tuesday",
  Wednesday: "Wednesday",
  Thursday: "Thursday",
  Friday: "Friday",
  Saturday: "Saturday",
  Delete: "Delete",
  Cancel: "Cancel",
  today: "today",
  yesterday: "yesterday",
  tomorrow: "tomorrow",
  Close: "Close",
  Submit: "Submit",
  EditorMenu_SyncToTodo: "Sync to Microsoft Todo",
  EditorMenu_SyncToTodoAndReplace: "Sync to Microsoft Todo and replace",
  PluginTitle: "Microsoft To Do Sync",
  PluginDescription: "An obsidian plugin that syncs Microsoft Todo",
  Settings_Todo_DefaultListName: "The default synchronization Microsoft Todo list name",
  Settings_Todo_DefaultListNameDescription: "If it does not exist, the list is created with that name",
  Settings_Uptimer: "Uptimer",
  Settings_Uptimer_UpTimerEmail: "Uptimer registration email",
  Settings_Uptimer_UpTimerPassword: "Uptimer password",
  Settings_JournalFormatting: "Journal formatting",
  Settings_JournalFormatting_PeriodicNotes: "Consistent with the Periodic Notes plugin",
  Settings_JournalFormatting_DateFormat: "Date format",
  Settings_JournalFormatting_DateFormatDescription: "The current format is",
  Settings_JournalFormatting_Folder: "Folder",
  Settings_JournalFormatting_FolderDescription: "Folder where the diary is stored",
  displayOptions_CreatedInFile: "Created in",
  displayOptions_CreatedAtTime: "Created at",
  Settings_Todo_Display_Heading: "\u{1F3A8} Task Formatting Options",
  Settings_Todo_Display_DateFormat: "Date format",
  Settings_Todo_Display_DateFormatDescription: "The format used when adding or rendering a date for a task.",
  Settings_Todo_Display_TimeFormat: "Time format",
  Settings_Todo_Display_TimeFormatDescription: "The format used when adding or rendering a time for a task.",
  Settings_Todo_Display_ReplacementFormat: "Replacement Format",
  Settings_Todo_Display_ReplacementFormatDescription: "If you select to replace the task and this is the replacement format, use {{TASK}} as the placeholder",
  Settings_Todo_Display_AddCreatedAtOnReplace: "Add Created At on Replace",
  Settings_Todo_Display_AddCreatedAtOnReplaceDescription: "If you select to replace the task and this is enabled 'Created at {Time Format}'",
  EditorMenu_OpenToDo: "Open To Do",
  Settings_Todo_OpenUsingApplicationProtocolTitle: "Open with application protocol?",
  Settings_Todo_OpenUsingApplicationProtocolDescription: "If this is set to true it will open the todo in the locally installed application, set it to off if you want to open the todo in the browser."
};

// src/lib/locale/zh-cn.json
var zh_cn_default = {
  Language: "\u7B80\u4F53\u4E2D\u6587",
  Complete: "\u5B8C\u6210",
  Archive: "\u5F52\u6863",
  Untitled: "\u672A\u547D\u540D",
  default: "\u9ED8\u8BA4",
  "Search...": "\u641C\u7D22\u2026\u2026",
  Enter: "\u8F93\u5165",
  Prepend: "\u5934\u90E8",
  Append: "\u5C3E\u90E8",
  Sunday: "\u5468\u65E5",
  Monday: "\u5468\u4E00",
  Tuesday: "\u5468\u4E8C",
  Wednesday: "\u5468\u4E09",
  Thursday: "\u5468\u56DB",
  Friday: "\u5468\u4E94",
  Saturday: "\u5468\u516D",
  Delete: "\u5220\u9664",
  Cancel: "\u53D6\u6D88",
  today: "\u4ECA\u5929",
  yesterday: "\u6628\u5929",
  tomorrow: "\u660E\u5929",
  Close: "\u5173\u95ED",
  Submit: "\u63D0\u4EA4",
  EditorMenu_SyncToTodo: "\u540C\u6B65\u5230\u5FAE\u8F6F\u5F85\u529E",
  EditorMenu_SyncToTodoAndReplace: "\u540C\u6B65\u5230\u5FAE\u8F6F\u5F85\u529E\u5E76\u66FF\u6362",
  PluginTitle: "Microsoft To Do Sync",
  PluginDescription: "\u4E00\u4E2A\u53EF\u4EE5\u540C\u6B65\u5FAE\u8F6FTodo\u7684obsidian\u63D2\u4EF6",
  Settings_Todo_DefaultListName: "\u9ED8\u8BA4\u7684\u540C\u6B65\u5FAE\u8F6FTodo\u5217\u8868\u540D\u79F0",
  Settings_Todo_DefaultListNameDescription: "\u5982\u4E0D\u5B58\u5728\u5219\u4EE5\u8BE5\u540D\u79F0\u521B\u5EFA\u5217\u8868",
  Settings_Uptimer: "Uptimer\u8BBE\u7F6E",
  Settings_Uptimer_UpTimerEmail: "uptimer\u6CE8\u518C\u90AE\u7BB1",
  Settings_Uptimer_UpTimerPassword: "uptimer\u5BC6\u7801",
  Settings_JournalFormatting: "\u65E5\u8BB0\u683C\u5F0F\u8BBE\u7F6E",
  Settings_JournalFormatting_PeriodicNotes: "\u4E0E Periodic Notes \u63D2\u4EF6\u4FDD\u6301\u4E00\u81F4",
  Settings_JournalFormatting_DateFormat: "\u65E5\u671F\u683C\u5F0F",
  Settings_JournalFormatting_DateFormatDescription: "\u5F53\u524D\u683C\u5F0F\u4E3A",
  Settings_JournalFormatting_Folder: "\u6587\u4EF6\u5939",
  Settings_JournalFormatting_FolderDescription: "\u65E5\u8BB0\u5B58\u653E\u7684\u6587\u4EF6\u5939",
  displayOptions_CreatedInFile: "\u6765\u81EA\u7B14\u8BB0",
  displayOptions_CreatedAtTime: "\u521B\u5EFA\u4E8E",
  Settings_Todo_Display_Heading: "\u{1F3A8} \u5F85\u529E\u683C\u5F0F\u8BBE\u7F6E",
  Settings_Todo_Display_DateFormat: "\u65E5\u671F\u683C\u5F0F",
  Settings_Todo_Display_DateFormatDescription: "\u6DFB\u52A0\u6216\u751F\u6210\u5F85\u529E\u65F6\u663E\u793A\u7684\u65E5\u671F\u683C\u5F0F",
  Settings_Todo_Display_TimeFormat: "\u65F6\u95F4\u683C\u5F0F",
  Settings_Todo_Display_TimeFormatDescription: "\u6DFB\u52A0\u6216\u751F\u6210\u5F85\u529E\u65F6\u663E\u793A\u7684\u65F6\u95F4\u683C\u5F0F",
  Settings_Todo_Display_ReplacementFormat: "\u5F85\u529E\u66FF\u6362\u683C\u5F0F",
  Settings_Todo_Display_ReplacementFormatDescription: "\u5728\u9009\u62E9\u201C\u521B\u5EFA\u5F85\u529E\u5E76\u66FF\u6362\u201D\u65F6\u4F7F\u7528\u7684\u66FF\u6362\u683C\u5F0F\uFF0C \u53EF\u4EE5\u4F7F\u7528{{TASK}}\u4F5C\u4E3A\u5360\u4F4D\u7B26",
  Settings_Todo_Display_AddCreatedAtOnReplace: "\u201C\u521B\u5EFA\u5F85\u529E\u5E76\u66FF\u6362\u201D\u65F6\u6DFB\u52A0\u65F6\u95F4",
  Settings_Todo_Display_AddCreatedAtOnReplaceDescription: "\u5728\u9009\u62E9\u201C\u521B\u5EFA\u5F85\u529E\u5E76\u66FF\u6362\u201D\u65F6\u6DFB\u52A0\u5F53\u524D\u65F6\u95F4\uFF0C\u683C\u5F0F\u4E3A\u4E0A\u9762\u586B\u5199\u7684\u65F6\u95F4\u683C\u5F0F",
  EditorMenu_OpenToDo: "\u5728\u5FAE\u8F6FTodo\u4E2D\u6253\u5F00",
  Settings_Todo_OpenUsingApplicationProtocolTitle: "\u4F7F\u7528\u5FAE\u8F6FTodo\u684C\u9762\u5E94\u7528\u6253\u5F00\u5F85\u529E",
  Settings_Todo_OpenUsingApplicationProtocolDescription: "\u9009\u4E2D\u5219\u4F7F\u7528\u5FAE\u8F6FTodo\u684C\u9762\u5E94\u7528\u6253\u5F00\u5F85\u529E\uFF0C\u672A\u9009\u4E2D\u5219\u5728\u6D4F\u89C8\u5668\u4E2D\u6253\u5F00"
};

// src/lib/lang.ts
var localeMap = {
  en: en_default,
  zh: zh_cn_default
};
var lang = window.localStorage.getItem("language");
var locale = localeMap[lang || "en"];
function t(str) {
  if (!locale) {
    console.error("Error: locale not found", lang);
  }
  return locale && locale[str] || str;
}

// src/gui/msTodoSyncSettingTab.ts
var DEFAULT_SETTINGS = {
  todoListSync: {
    listName: void 0,
    listId: void 0
  },
  diary: {
    folder: "",
    format: "",
    stayWithPN: false
  },
  displayOptions_DateFormat: "YYYY-MM-DD",
  displayOptions_TimeFormat: "HH:mm",
  displayOptions_TaskCreatedPrefix: "\u{1F50E}",
  displayOptions_TaskDuePrefix: "\u{1F4C5}",
  displayOptions_TaskStartPrefix: "\u{1F6EB}",
  displayOptions_TaskBodyPrefix: "\u{1F4A1}",
  displayOptions_ReplaceAddCreatedAt: false,
  displayOptions_ReplacementFormat: "- [ ] {{TASK}}",
  todo_OpenUsingApplicationProtocol: true,
  loggingOptions: {
    minLevels: {
      "": "info"
    }
  },
  taskIdLookup: { ["0000ABCD"]: "0" },
  taskIdIndex: 0
};
var MsTodoSyncSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.settings = plugin.settings;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", {
      text: `${this.plugin.manifest.name}`
    });
    const span = containerEl.createSpan();
    span.style.fontSize = "0.8em";
    span.innerHTML = `Version ${this.plugin.manifest.version} <br /> ${this.plugin.manifest.description} created by ${this.plugin.manifest.author}`;
    new import_obsidian3.Setting(containerEl).setName(t("Settings_Todo_DefaultListName")).setDesc(t("Settings_Todo_DefaultListNameDescription")).addText((text) => {
      var _a;
      return text.setValue((_a = this.settings.todoListSync.listName) != null ? _a : "").onChange(async (value) => {
        this.settings.todoListSync.listName = value;
      });
    });
    new import_obsidian3.Setting(containerEl).setName(t("Settings_Todo_OpenUsingApplicationProtocolTitle")).setDesc(t("Settings_Todo_OpenUsingApplicationProtocolDescription")).addToggle((toggle) => toggle.setValue(this.settings.todo_OpenUsingApplicationProtocol).onChange(async (value) => {
      this.settings.todo_OpenUsingApplicationProtocol = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", {
      text: t("Settings_Todo_Display_Heading")
    });
    new import_obsidian3.Setting(containerEl).setName(t("Settings_Todo_Display_DateFormat")).setDesc(t("Settings_Todo_Display_DateFormatDescription")).addText((text) => {
      var _a;
      return text.setValue((_a = this.settings.displayOptions_DateFormat) != null ? _a : "").onChange(async (value) => {
        this.settings.displayOptions_DateFormat = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName(t("Settings_Todo_Display_TimeFormat")).setDesc(t("Settings_Todo_Display_TimeFormatDescription")).addText((text) => {
      var _a;
      return text.setValue((_a = this.settings.displayOptions_TimeFormat) != null ? _a : "").onChange(async (value) => {
        this.settings.displayOptions_TimeFormat = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName(t("Settings_Todo_Display_AddCreatedAtOnReplace")).setDesc(t("Settings_Todo_Display_AddCreatedAtOnReplaceDescription")).addToggle((toggle) => toggle.setValue(this.settings.displayOptions_ReplaceAddCreatedAt).onChange(async (value) => {
      this.settings.displayOptions_ReplaceAddCreatedAt = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(t("Settings_Todo_Display_ReplacementFormat")).setDesc(t("Settings_Todo_Display_ReplacementFormatDescription")).addText((text) => text.setValue(this.settings.displayOptions_ReplacementFormat).onChange(async (value) => {
      this.settings.displayOptions_ReplacementFormat = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: t("Settings_JournalFormatting") });
    new import_obsidian3.Setting(containerEl).setName(t("Settings_JournalFormatting_PeriodicNotes")).addToggle((toggle) => toggle.setValue(this.settings.diary.stayWithPN).onChange(async (value) => {
      if (value) {
        const PNsetting = app.plugins.plugins["periodic-notes"];
        if (PNsetting) {
          const { format, folder } = PNsetting.settings.daily;
          this.settings.diary = {
            format,
            folder,
            stayWithPN: true
          };
          console.log("\u{1F680} ~ this.settings.diary", this.settings.diary);
          await this.plugin.saveSettings();
          this.display();
        } else {
          new import_obsidian3.Notice("Periodic Notes \u4E2D\u672A\u8BBE\u7F6E");
          this.display();
        }
      } else {
        this.settings.diary.stayWithPN = false;
        await this.plugin.saveSettings();
        this.display();
      }
    }));
    const dateFormat = new import_obsidian3.Setting(containerEl).setName(t("Settings_JournalFormatting_DateFormat")).setDesc(`${t("Settings_JournalFormatting_DateFormatDescription")}  ${!this.settings.diary.format ? "" : window.moment().format(this.settings.diary.format)}`).addText((text) => text.setValue(this.settings.diary.format).onChange(async (value) => {
      this.settings.diary.format = value;
      dateFormat.setDesc(`${t("Settings_JournalFormatting_DateFormatDescription")}  ${!this.settings.diary.format ? "" : window.moment().format(this.settings.diary.format)}`);
      await this.plugin.saveSettings();
    })).setDisabled(this.settings.diary.stayWithPN);
    new import_obsidian3.Setting(containerEl).setName(t("Settings_JournalFormatting_Folder")).setDesc(t("Settings_JournalFormatting_FolderDescription")).addText((text) => text.setValue(this.settings.diary.folder).onChange(async (value) => {
      this.settings.diary.format = value;
      await this.plugin.saveSettings();
    })).setDisabled(this.settings.diary.stayWithPN);
  }
  async hide() {
    var _a;
    const listName = this.settings.todoListSync.listName;
    if (this.settings.todoListSync.listId != void 0 || !listName) {
      if (!listName)
        new import_obsidian3.Notice("\u5FAE\u8F6F\u540C\u6B65\u5217\u8868\u672A\u8BBE\u7F6E");
    } else {
      let listId = await this.plugin.todoApi.getListIdByName(listName);
      if (!listId) {
        listId = (_a = await this.plugin.todoApi.createTaskList(listName)) == null ? void 0 : _a.id;
      }
      if (!listId) {
        new import_obsidian3.Notice("\u521B\u5EFA\u5217\u8868\u5931\u8D25");
        return;
      } else {
        this.settings.todoListSync = {
          listName,
          listId
        };
        new import_obsidian3.Notice("\u8BBE\u7F6E\u540C\u6B65\u5217\u8868\u6210\u529F\u221A");
        await this.plugin.saveSettings();
      }
    }
  }
};

// src/command/msTodoCommand.ts
var import_obsidian5 = require("obsidian");

// src/constants.ts
var TASK_REGEX = new RegExp(/{{TASK}}/);

// src/utils/formatter.ts
var formatTask = (plugin, line) => {
  let output;
  const format = plugin.settings.displayOptions_ReplacementFormat;
  output = format.replace(TASK_REGEX, line);
  return output;
};

// src/lib/logging.ts
var import_moment = __toESM(require_moment());
var import_obsidian4 = require("obsidian");
var import_eventemitter2 = __toESM(require_eventemitter2());
var LogManager = class extends import_eventemitter2.EventEmitter2 {
  constructor() {
    super(...arguments);
    this.options = {
      minLevels: {
        "": "info",
        "mstodo-sync": "info"
      }
    };
    this.consoleLoggerRegistered = false;
    this.arrAvg = (arr) => arr.reduce((a, b) => a + b, 0) / arr.length;
  }
  configure(options) {
    this.options = Object.assign({}, this.options, options);
    return this;
  }
  getLogger(moduleName) {
    let currentMinimumLevel = "none";
    let match = "";
    for (const key in this.options.minLevels) {
      if (moduleName.startsWith(key) && key.length >= match.length) {
        currentMinimumLevel = this.options.minLevels[key];
        match = key;
      }
    }
    return new Logger2(this, moduleName, currentMinimumLevel);
  }
  onLogEntry(listener) {
    this.on("log", listener);
    return this;
  }
  registerConsoleLogger() {
    if (this.consoleLoggerRegistered)
      return this;
    this.onLogEntry((logEntry) => {
      let msg = `[${(0, import_moment.default)().format("YYYYMMDDHHmmss")}][${logEntry.level}][${logEntry.module}]`;
      if (logEntry.traceId) {
        msg += `[${logEntry.traceId}]`;
      }
      msg += ` ${logEntry.message}`;
      if (logEntry.objects === void 0) {
        logEntry.objects = "";
      }
      switch (logEntry.level) {
        case "trace":
          console.trace(msg, logEntry.objects);
          break;
        case "debug":
          console.debug(msg, logEntry.objects);
          break;
        case "info":
          console.info(msg, logEntry.objects);
          break;
        case "warn":
          console.warn(msg, logEntry.objects);
          break;
        case "error":
          console.error(msg, logEntry.objects);
          break;
        default:
          console.log(`{${logEntry.level}} ${msg}`, logEntry.objects);
      }
    });
    this.consoleLoggerRegistered = true;
    return this;
  }
};
var logging = new LogManager();
var Logger2 = class {
  constructor(logManager, module2, minLevel) {
    this.levels = {
      trace: 1,
      debug: 2,
      info: 3,
      warn: 4,
      error: 5
    };
    this.logManager = logManager;
    this.module = module2;
    this.minLevel = this.levelToInt(minLevel);
  }
  levelToInt(minLevel) {
    if (minLevel.toLowerCase() in this.levels)
      return this.levels[minLevel.toLowerCase()];
    else
      return 99;
  }
  log(logLevel, message, objects) {
    const level = this.levelToInt(logLevel);
    if (level < this.minLevel)
      return;
    const logEntry = {
      level: logLevel,
      module: this.module,
      message,
      objects,
      traceId: void 0
    };
    this.logManager.emit("log", logEntry);
  }
  trace(message, objects) {
    this.log("trace", message, objects);
  }
  debug(message, objects) {
    this.log("debug", message, objects);
  }
  info(message, objects) {
    this.log("info", message, objects);
  }
  warn(message, objects) {
    this.log("warn", message, objects);
  }
  error(message, objects) {
    this.log("error", message, objects);
  }
  logWithId(logLevel, traceId, message, objects) {
    const level = this.levelToInt(logLevel);
    if (level < this.minLevel)
      return;
    const logEntry = {
      level: logLevel,
      module: this.module,
      message,
      objects,
      traceId
    };
    this.logManager.emit("log", logEntry);
  }
  traceWithId(traceId, message, objects) {
    this.logWithId("trace", traceId, message, objects);
  }
  debugWithId(traceId, message, objects) {
    this.logWithId("debug", traceId, message, objects);
  }
  infoWithId(traceId, message, objects) {
    this.logWithId("info", traceId, message, objects);
  }
  warnWithId(traceId, message, objects) {
    this.logWithId("warn", traceId, message, objects);
  }
  errorWithId(traceId, message, objects) {
    this.logWithId("error", traceId, message, objects);
  }
};
function log(logLevel, message) {
  const logger = logging.getLogger("mstodo-sync");
  switch (logLevel) {
    case "trace":
      logger.trace(message);
      break;
    case "debug":
      logger.debug(message);
      break;
    case "info":
      logger.info(message);
      break;
    case "warn":
      logger.warn(message);
      break;
    case "error":
      logger.error(message);
      break;
    default:
      break;
  }
}

// src/command/msTodoCommand.ts
function getTaskIdFromLine(line, plugin) {
  const regex = /\^(?!.*\^)([A-Za-z0-9]+)/gm;
  const blocklistMatch = regex.exec(line.trim());
  if (blocklistMatch) {
    const blocklink = blocklistMatch[1];
    const taskId = plugin.settings.taskIdLookup[blocklink];
    console.log(taskId);
    return taskId;
  }
  return "";
}
async function postTask(todoApi, listId, editor, fileName, plugin, replace) {
  if (!editor.somethingSelected()) {
    new import_obsidian5.Notice("\u597D\u50CF\u6CA1\u6709\u9009\u4E2D\u4EC0\u4E48");
    return;
  }
  if (!listId) {
    new import_obsidian5.Notice("\u8BF7\u5148\u8BBE\u7F6E\u540C\u6B65\u5217\u8868");
    return;
  }
  new import_obsidian5.Notice("\u521B\u5EFA\u5F85\u529E\u4E2D...", 3e3);
  const body = `${t("displayOptions_CreatedInFile")} [[${fileName}]]`;
  const formatted = editor.getSelection().replace(/(- \[ \] )|\*|^> |^#* |- /gm, "").split("\n").filter((s) => s != "");
  log("debug", formatted.join(" :: "));
  Promise.all(formatted.map(async (s) => {
    const line = s.trim();
    const regex = /\^(?!.*\^)([A-Za-z0-9]+)/gm;
    const blocklistMatch = regex.exec(line);
    if (blocklistMatch) {
      const blocklink = blocklistMatch[1];
      const taskId = plugin.settings.taskIdLookup[blocklink];
      const cleanTaskTitle = line.replace(`^${blocklink}`, "");
      console.log(blocklink);
      console.log(taskId);
      const updatedTask = await todoApi.updateTask(listId, taskId, cleanTaskTitle);
      console.log(updatedTask);
      return { line: cleanTaskTitle, index: blocklink };
    } else {
      const newTask = await todoApi.createTask(listId, line, body);
      plugin.settings.taskIdIndex = plugin.settings.taskIdIndex + 1;
      const index = `${Math.random().toString(20).substring(2, 6)}${plugin.settings.taskIdIndex.toString().padStart(5, "0")}`;
      plugin.settings.taskIdLookup[index] = newTask.id === void 0 ? "" : newTask.id;
      await plugin.saveSettings();
      return { line, index };
    }
  })).then((res) => {
    new import_obsidian5.Notice("\u521B\u5EFA\u5F85\u529E\u6210\u529F\u221A");
    if (replace) {
      editor.replaceSelection(res.map((i) => {
        let createdAt = "";
        const blocklink = `^${i.index}`;
        const formattedTask = formatTask(plugin, i.line);
        if (plugin.settings.displayOptions_ReplaceAddCreatedAt) {
          createdAt = `${t("displayOptions_CreatedAtTime")} ${window.moment().format(plugin.settings.displayOptions_TimeFormat)}`;
        }
        return `${formattedTask} ${createdAt} ${blocklink}`;
      }).join("\n"));
    }
  });
}
async function createTodayTasks(todoApi, settings, editor) {
  new import_obsidian5.Notice("\u83B7\u53D6\u5FAE\u8F6F\u5F85\u529E\u4E2D", 3e3);
  const now = window.moment();
  const pattern = `status ne 'completed' or completedDateTime/dateTime ge '${now.format("yyyy-MM-DD")}'`;
  const taskLists = await todoApi.getLists(pattern);
  if (!taskLists || taskLists.length == 0) {
    new import_obsidian5.Notice("\u4EFB\u52A1\u5217\u8868\u4E3A\u7A7A");
    return;
  }
  const segments = taskLists.map((taskList) => {
    var _a;
    if (!taskList.tasks || taskList.tasks.length == 0)
      return;
    taskList.tasks.sort((a, b) => a.status == "completed" ? 1 : -1);
    const lines = (_a = taskList.tasks) == null ? void 0 : _a.map((task) => {
      var _a2;
      const formattedCreateDate = window.moment(task.createdDateTime).format(settings.displayOptions_DateFormat);
      const done = task.status == "completed" ? "x" : " ";
      const createDate = formattedCreateDate == now.format(settings.displayOptions_DateFormat) ? "" : `${settings.displayOptions_TaskCreatedPrefix}[[${formattedCreateDate}]]`;
      const body = !((_a2 = task.body) == null ? void 0 : _a2.content) ? "" : `${settings.displayOptions_TaskBodyPrefix}${task.body.content}`;
      return `- [${done}] ${task.title}  ${createDate}  ${body}`;
    });
    return `**${taskList.displayName}**
${lines == null ? void 0 : lines.join("\n")}
`;
  }).filter((s) => s != void 0).join("\n\n");
  new import_obsidian5.Notice("\u5F85\u529E\u5217\u8868\u5DF2\u83B7\u53D6");
  if (editor)
    editor.replaceSelection(segments);
  else
    return segments;
}

// src/main.ts
var MsTodoSync = class extends import_obsidian6.Plugin {
  async onload() {
    logging.registerConsoleLogger();
    log("info", `loading plugin "${this.manifest.name}" v${this.manifest.version}`);
    await this.loadSettings();
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
      menu.addItem((item) => {
        item.setTitle(t("EditorMenu_SyncToTodo")).onClick(async () => {
          var _a, _b;
          return await postTask(this.todoApi, (_a = this.settings.todoListSync) == null ? void 0 : _a.listId, editor, (_b = this.app.workspace.getActiveFile()) == null ? void 0 : _b.basename, this);
        });
      });
    }));
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
      menu.addItem((item) => {
        item.setTitle(t("EditorMenu_SyncToTodoAndReplace")).onClick(async () => {
          var _a, _b;
          return await postTask(this.todoApi, (_a = this.settings.todoListSync) == null ? void 0 : _a.listId, editor, (_b = this.app.workspace.getActiveFile()) == null ? void 0 : _b.basename, this, true);
        });
      });
    }));
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
      menu.addItem((item) => {
        item.setTitle(t("EditorMenu_OpenToDo")).onClick(async () => {
          const cursorLocation = editor.getCursor();
          const line = editor.getLine(cursorLocation.line);
          const taskId = getTaskIdFromLine(line, this);
          if (taskId !== "") {
            if (!this.app.isMobile && this.settings.todo_OpenUsingApplicationProtocol) {
              window.open(`ms-todo://tasks/id/${taskId}/details`, "_blank");
            } else {
              window.open(`https://to-do.live.com/tasks/id/${taskId}/details`, "_blank");
            }
          }
        });
      });
    }));
    this.addCommand({
      id: "only-create-task",
      name: "Post the selection as todos to MsTodo.",
      editorCallback: async (editor, view) => {
        var _a, _b;
        return await postTask(this.todoApi, (_a = this.settings.todoListSync) == null ? void 0 : _a.listId, editor, (_b = this.app.workspace.getActiveFile()) == null ? void 0 : _b.basename, this);
      }
    });
    this.addCommand({
      id: "create-task-replace",
      name: "Post the selection as todos to MsTodo and Replace.",
      editorCallback: async (editor, view) => {
        var _a, _b;
        return await postTask(this.todoApi, (_a = this.settings.todoListSync) == null ? void 0 : _a.listId, editor, (_b = this.app.workspace.getActiveFile()) == null ? void 0 : _b.basename, this, true);
      }
    });
    this.addCommand({
      id: "open-task-link",
      name: "Open To Do",
      editorCallback: async (editor, view) => {
        const cursorLocation = editor.getCursor();
        const line = editor.getLine(cursorLocation.line);
        const taskId = getTaskIdFromLine(line, this);
        if (taskId !== "") {
          if (!this.app.isMobile && this.settings.todo_OpenUsingApplicationProtocol) {
            window.open(`ms-todo://tasks/id/${taskId}/details`, "_blank");
          } else {
            window.open(`https://to-do.live.com/tasks/id/${taskId}/details`, "_blank");
          }
        }
      }
    });
    this.addCommand({
      id: "add-microsoft-todo",
      name: "Insert the MsTodo summary.",
      editorCallback: async (editor, view) => {
        await createTodayTasks(this.todoApi, this.settings, editor);
      }
    });
    this.addSettingTab(new MsTodoSyncSettingTab(this));
    this.todoApi = new TodoApi();
  }
  async onunload() {
    log("info", `unloading plugin "${this.manifest.name}" v${this.manifest.version}`);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! @azure/msal-common v7.6.0 2022-10-10 */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! moment.js
//! momentjs.com
//! version : 2.29.4
